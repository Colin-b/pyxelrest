"""
This file was generated. DO NOT EDIT manually.
Source file: user_defined_functions.jinja2
Generation date \(UTC\): \d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d.\d\d\d\d\d\d
"""
import xlwings as xw
import requests
import requests.exceptions
import datetime
import logging
from pyxelrest import custom_logging
from pyxelrest.caching import caching
from pyxelrest import session
import ujson
from collections import OrderedDict
from pyxelrest.fast_deserializer import Flattenizer
from pyxelrest.definition_deserializer import Response
from pyxelrest import definition_deserializer
from pyxelrest import authentication

logger = logging.getLogger(__name__)







all_definitions = {}

all_definitions['empty_methods_test'] = None


@caching
@xw.func(category='empty_methods_test', call_in_wizard=False)
def empty_methods_test_get_test_date():
    logger.info("[status=Calling] [function=empty_methods_test_get_test_date]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8943/test/date'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=empty_methods_test_get_test_date] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value'), (u'schema', OrderedDict([(u'format', u'date'), (u'type', u'string')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('empty_methods_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=empty_methods_test_get_test_date] [url=http://localhost:8943/test/date].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=empty_methods_test_get_test_date] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=empty_methods_test_get_test_date] [url=http://localhost:8943/test/date].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='empty_methods_test', call_in_wizard=False)
def empty_methods_test_get_test_date_time():
    logger.info("[status=Calling] [function=empty_methods_test_get_test_date_time]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8943/test/datetime'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=empty_methods_test_get_test_date_time] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'format', u'date-time'), (u'type', u'string')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('empty_methods_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=empty_methods_test_get_test_date_time] [url=http://localhost:8943/test/datetime].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=empty_methods_test_get_test_date_time] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=empty_methods_test_get_test_date_time] [url=http://localhost:8943/test/datetime].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='empty_methods_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def empty_methods_test_delete_test_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=empty_methods_test_delete_test_with_all_optional_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('delete', 'http://localhost:8943/test/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=empty_methods_test_delete_test_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('empty_methods_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=empty_methods_test_delete_test_with_all_optional_parameters_types] [url=http://localhost:8943/test/with/all/optional/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=empty_methods_test_delete_test_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=empty_methods_test_delete_test_with_all_optional_parameters_types] [url=http://localhost:8943/test/with/all/optional/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='empty_methods_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def empty_methods_test_get_test_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=empty_methods_test_get_test_with_all_optional_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8943/test/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=empty_methods_test_get_test_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('empty_methods_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=empty_methods_test_get_test_with_all_optional_parameters_types] [url=http://localhost:8943/test/with/all/optional/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=empty_methods_test_get_test_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=empty_methods_test_get_test_with_all_optional_parameters_types] [url=http://localhost:8943/test/with/all/optional/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='empty_methods_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def empty_methods_test_post_test_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=empty_methods_test_post_test_with_all_optional_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8943/test/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=empty_methods_test_post_test_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('empty_methods_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=empty_methods_test_post_test_with_all_optional_parameters_types] [url=http://localhost:8943/test/with/all/optional/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=empty_methods_test_post_test_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=empty_methods_test_post_test_with_all_optional_parameters_types] [url=http://localhost:8943/test/with/all/optional/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='empty_methods_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def empty_methods_test_put_test_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=empty_methods_test_put_test_with_all_optional_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8943/test/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=empty_methods_test_put_test_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('empty_methods_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=empty_methods_test_put_test_with_all_optional_parameters_types] [url=http://localhost:8943/test/with/all/optional/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=empty_methods_test_put_test_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=empty_methods_test_put_test_with_all_optional_parameters_types] [url=http://localhost:8943/test/with/all/optional/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='empty_methods_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def empty_methods_test_delete_test_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=empty_methods_test_delete_test_with_all_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return 'query_integer is required.'
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return 'query_integer32 is required.'
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return 'query_integer64 is required.'
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return 'query_number is required.'
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return 'query_float is required.'
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return 'query_double is required.'
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return 'query_string is required.'
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return 'query_string_byte is required.'
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return 'query_string_binary is required.'
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return 'query_boolean is required.'
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return 'query_date is required.'
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return 'query_date_time is required.'
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return 'query_password is required.'
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return 'query_array_integer is required.'
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return 'query_array_integer32 is required.'
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return 'query_array_integer64 is required.'
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return 'query_array_number is required.'
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return 'query_array_float is required.'
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return 'query_array_double is required.'
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return 'query_array_string is required.'
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return 'query_array_string_byte is required.'
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return 'query_array_string_binary is required.'
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return 'query_array_boolean is required.'
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return 'query_array_date is required.'
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return 'query_array_date_time is required.'
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return 'query_array_password is required.'
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('delete', 'http://localhost:8943/test/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=empty_methods_test_delete_test_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('empty_methods_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=empty_methods_test_delete_test_with_all_parameters_types] [url=http://localhost:8943/test/with/all/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=empty_methods_test_delete_test_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=empty_methods_test_delete_test_with_all_parameters_types] [url=http://localhost:8943/test/with/all/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='empty_methods_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def empty_methods_test_get_test_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=empty_methods_test_get_test_with_all_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return 'query_integer is required.'
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return 'query_integer32 is required.'
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return 'query_integer64 is required.'
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return 'query_number is required.'
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return 'query_float is required.'
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return 'query_double is required.'
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return 'query_string is required.'
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return 'query_string_byte is required.'
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return 'query_string_binary is required.'
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return 'query_boolean is required.'
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return 'query_date is required.'
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return 'query_date_time is required.'
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return 'query_password is required.'
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return 'query_array_integer is required.'
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return 'query_array_integer32 is required.'
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return 'query_array_integer64 is required.'
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return 'query_array_number is required.'
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return 'query_array_float is required.'
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return 'query_array_double is required.'
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return 'query_array_string is required.'
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return 'query_array_string_byte is required.'
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return 'query_array_string_binary is required.'
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return 'query_array_boolean is required.'
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return 'query_array_date is required.'
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return 'query_array_date_time is required.'
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return 'query_array_password is required.'
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8943/test/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=empty_methods_test_get_test_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('empty_methods_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=empty_methods_test_get_test_with_all_parameters_types] [url=http://localhost:8943/test/with/all/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=empty_methods_test_get_test_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=empty_methods_test_get_test_with_all_parameters_types] [url=http://localhost:8943/test/with/all/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='empty_methods_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def empty_methods_test_post_test_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=empty_methods_test_post_test_with_all_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return 'query_integer is required.'
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return 'query_integer32 is required.'
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return 'query_integer64 is required.'
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return 'query_number is required.'
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return 'query_float is required.'
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return 'query_double is required.'
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return 'query_string is required.'
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return 'query_string_byte is required.'
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return 'query_string_binary is required.'
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return 'query_boolean is required.'
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return 'query_date is required.'
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return 'query_date_time is required.'
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return 'query_password is required.'
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return 'query_array_integer is required.'
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return 'query_array_integer32 is required.'
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return 'query_array_integer64 is required.'
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return 'query_array_number is required.'
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return 'query_array_float is required.'
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return 'query_array_double is required.'
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return 'query_array_string is required.'
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return 'query_array_string_byte is required.'
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return 'query_array_string_binary is required.'
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return 'query_array_boolean is required.'
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return 'query_array_date is required.'
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return 'query_array_date_time is required.'
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return 'query_array_password is required.'
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8943/test/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=empty_methods_test_post_test_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('empty_methods_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=empty_methods_test_post_test_with_all_parameters_types] [url=http://localhost:8943/test/with/all/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=empty_methods_test_post_test_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=empty_methods_test_post_test_with_all_parameters_types] [url=http://localhost:8943/test/with/all/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='empty_methods_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def empty_methods_test_put_test_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=empty_methods_test_put_test_with_all_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return 'query_integer is required.'
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return 'query_integer32 is required.'
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return 'query_integer64 is required.'
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return 'query_number is required.'
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return 'query_float is required.'
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return 'query_double is required.'
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return 'query_string is required.'
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return 'query_string_byte is required.'
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return 'query_string_binary is required.'
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return 'query_boolean is required.'
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return 'query_date is required.'
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return 'query_date_time is required.'
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return 'query_password is required.'
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return 'query_array_integer is required.'
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return 'query_array_integer32 is required.'
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return 'query_array_integer64 is required.'
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return 'query_array_number is required.'
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return 'query_array_float is required.'
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return 'query_array_double is required.'
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return 'query_array_string is required.'
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return 'query_array_string_byte is required.'
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return 'query_array_string_binary is required.'
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return 'query_array_boolean is required.'
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return 'query_array_date is required.'
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return 'query_array_date_time is required.'
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return 'query_array_password is required.'
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8943/test/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=empty_methods_test_put_test_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('empty_methods_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=empty_methods_test_put_test_with_all_parameters_types] [url=http://localhost:8943/test/with/all/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=empty_methods_test_put_test_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=empty_methods_test_put_test_with_all_parameters_types] [url=http://localhost:8943/test/with/all/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='empty_methods_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
def empty_methods_test_delete_test_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=empty_methods_test_delete_test_with_all_paths_types]...")
    request_header = {}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return 'path_integer is required.'

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return 'path_integer32 is required.'

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return 'path_integer64 is required.'

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return 'path_number is required.'

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return 'path_float is required.'

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return 'path_double is required.'

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return 'path_string is required.'

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return 'path_string_byte is required.'

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return 'path_string_binary is required.'

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return 'path_boolean is required.'

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return 'path_date is required.'

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return 'path_date_time is required.'

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return 'path_password is required.'

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return 'path_array_integer is required.'

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return 'path_array_integer32 is required.'

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return 'path_array_integer64 is required.'

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return 'path_array_number is required.'

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return 'path_array_float is required.'

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return 'path_array_double is required.'

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return 'path_array_string is required.'

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return 'path_array_string_byte is required.'

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return 'path_array_string_binary is required.'

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return 'path_array_boolean is required.'

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return 'path_array_date is required.'

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return 'path_array_date_time is required.'

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return 'path_array_password is required.'


    response = None
    try:
        response = session.get(5).request('delete', 'http://localhost:8943/test/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=empty_methods_test_delete_test_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('empty_methods_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=empty_methods_test_delete_test_with_all_paths_types] [url=http://localhost:8943/test/with/all/paths/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=empty_methods_test_delete_test_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=empty_methods_test_delete_test_with_all_paths_types] [url=http://localhost:8943/test/with/all/paths/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='empty_methods_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
def empty_methods_test_get_test_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=empty_methods_test_get_test_with_all_paths_types]...")
    request_header = {}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return 'path_integer is required.'

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return 'path_integer32 is required.'

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return 'path_integer64 is required.'

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return 'path_number is required.'

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return 'path_float is required.'

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return 'path_double is required.'

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return 'path_string is required.'

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return 'path_string_byte is required.'

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return 'path_string_binary is required.'

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return 'path_boolean is required.'

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return 'path_date is required.'

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return 'path_date_time is required.'

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return 'path_password is required.'

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return 'path_array_integer is required.'

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return 'path_array_integer32 is required.'

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return 'path_array_integer64 is required.'

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return 'path_array_number is required.'

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return 'path_array_float is required.'

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return 'path_array_double is required.'

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return 'path_array_string is required.'

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return 'path_array_string_byte is required.'

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return 'path_array_string_binary is required.'

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return 'path_array_boolean is required.'

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return 'path_array_date is required.'

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return 'path_array_date_time is required.'

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return 'path_array_password is required.'


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8943/test/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=empty_methods_test_get_test_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('empty_methods_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=empty_methods_test_get_test_with_all_paths_types] [url=http://localhost:8943/test/with/all/paths/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=empty_methods_test_get_test_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=empty_methods_test_get_test_with_all_paths_types] [url=http://localhost:8943/test/with/all/paths/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='empty_methods_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
def empty_methods_test_post_test_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=empty_methods_test_post_test_with_all_paths_types]...")
    request_header = {}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return 'path_integer is required.'

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return 'path_integer32 is required.'

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return 'path_integer64 is required.'

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return 'path_number is required.'

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return 'path_float is required.'

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return 'path_double is required.'

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return 'path_string is required.'

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return 'path_string_byte is required.'

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return 'path_string_binary is required.'

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return 'path_boolean is required.'

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return 'path_date is required.'

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return 'path_date_time is required.'

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return 'path_password is required.'

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return 'path_array_integer is required.'

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return 'path_array_integer32 is required.'

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return 'path_array_integer64 is required.'

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return 'path_array_number is required.'

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return 'path_array_float is required.'

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return 'path_array_double is required.'

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return 'path_array_string is required.'

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return 'path_array_string_byte is required.'

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return 'path_array_string_binary is required.'

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return 'path_array_boolean is required.'

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return 'path_array_date is required.'

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return 'path_array_date_time is required.'

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return 'path_array_password is required.'


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8943/test/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=empty_methods_test_post_test_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('empty_methods_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=empty_methods_test_post_test_with_all_paths_types] [url=http://localhost:8943/test/with/all/paths/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=empty_methods_test_post_test_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=empty_methods_test_post_test_with_all_paths_types] [url=http://localhost:8943/test/with/all/paths/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='empty_methods_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
def empty_methods_test_put_test_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=empty_methods_test_put_test_with_all_paths_types]...")
    request_header = {}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return 'path_integer is required.'

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return 'path_integer32 is required.'

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return 'path_integer64 is required.'

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return 'path_number is required.'

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return 'path_float is required.'

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return 'path_double is required.'

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return 'path_string is required.'

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return 'path_string_byte is required.'

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return 'path_string_binary is required.'

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return 'path_boolean is required.'

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return 'path_date is required.'

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return 'path_date_time is required.'

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return 'path_password is required.'

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return 'path_array_integer is required.'

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return 'path_array_integer32 is required.'

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return 'path_array_integer64 is required.'

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return 'path_array_number is required.'

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return 'path_array_float is required.'

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return 'path_array_double is required.'

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return 'path_array_string is required.'

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return 'path_array_string_byte is required.'

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return 'path_array_string_binary is required.'

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return 'path_array_boolean is required.'

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return 'path_array_date is required.'

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return 'path_array_date_time is required.'

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return 'path_array_password is required.'


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8943/test/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=empty_methods_test_put_test_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('empty_methods_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=empty_methods_test_put_test_with_all_paths_types] [url=http://localhost:8943/test/with/all/paths/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=empty_methods_test_put_test_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=empty_methods_test_put_test_with_all_paths_types] [url=http://localhost:8943/test/with/all/paths/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

all_definitions['usual_parameters_test'] = None


@caching
@xw.func(category='usual_parameters_test', call_in_wizard=False)
def usual_parameters_test_get_test_date():
    logger.info("[status=Calling] [function=usual_parameters_test_get_test_date]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8943/test/date'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=usual_parameters_test_get_test_date] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value'), (u'schema', OrderedDict([(u'format', u'date'), (u'type', u'string')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('usual_parameters_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=usual_parameters_test_get_test_date] [url=http://localhost:8943/test/date].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=usual_parameters_test_get_test_date] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=usual_parameters_test_get_test_date] [url=http://localhost:8943/test/date].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='usual_parameters_test', call_in_wizard=False)
def usual_parameters_test_get_test_date_time():
    logger.info("[status=Calling] [function=usual_parameters_test_get_test_date_time]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8943/test/datetime'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=usual_parameters_test_get_test_date_time] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'format', u'date-time'), (u'type', u'string')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('usual_parameters_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=usual_parameters_test_get_test_date_time] [url=http://localhost:8943/test/datetime].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=usual_parameters_test_get_test_date_time] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=usual_parameters_test_get_test_date_time] [url=http://localhost:8943/test/datetime].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='usual_parameters_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def usual_parameters_test_delete_test_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=usual_parameters_test_delete_test_with_all_optional_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('delete', 'http://localhost:8943/test/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=usual_parameters_test_delete_test_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('usual_parameters_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=usual_parameters_test_delete_test_with_all_optional_parameters_types] [url=http://localhost:8943/test/with/all/optional/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=usual_parameters_test_delete_test_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=usual_parameters_test_delete_test_with_all_optional_parameters_types] [url=http://localhost:8943/test/with/all/optional/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='usual_parameters_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def usual_parameters_test_get_test_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=usual_parameters_test_get_test_with_all_optional_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8943/test/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=usual_parameters_test_get_test_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('usual_parameters_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=usual_parameters_test_get_test_with_all_optional_parameters_types] [url=http://localhost:8943/test/with/all/optional/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=usual_parameters_test_get_test_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=usual_parameters_test_get_test_with_all_optional_parameters_types] [url=http://localhost:8943/test/with/all/optional/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='usual_parameters_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def usual_parameters_test_post_test_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=usual_parameters_test_post_test_with_all_optional_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8943/test/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=usual_parameters_test_post_test_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('usual_parameters_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=usual_parameters_test_post_test_with_all_optional_parameters_types] [url=http://localhost:8943/test/with/all/optional/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=usual_parameters_test_post_test_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=usual_parameters_test_post_test_with_all_optional_parameters_types] [url=http://localhost:8943/test/with/all/optional/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='usual_parameters_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def usual_parameters_test_put_test_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=usual_parameters_test_put_test_with_all_optional_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8943/test/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=usual_parameters_test_put_test_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('usual_parameters_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=usual_parameters_test_put_test_with_all_optional_parameters_types] [url=http://localhost:8943/test/with/all/optional/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=usual_parameters_test_put_test_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=usual_parameters_test_put_test_with_all_optional_parameters_types] [url=http://localhost:8943/test/with/all/optional/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='usual_parameters_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def usual_parameters_test_delete_test_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=usual_parameters_test_delete_test_with_all_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return 'query_integer is required.'
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return 'query_integer32 is required.'
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return 'query_integer64 is required.'
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return 'query_number is required.'
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return 'query_float is required.'
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return 'query_double is required.'
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return 'query_string is required.'
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return 'query_string_byte is required.'
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return 'query_string_binary is required.'
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return 'query_boolean is required.'
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return 'query_date is required.'
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return 'query_date_time is required.'
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return 'query_password is required.'
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return 'query_array_integer is required.'
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return 'query_array_integer32 is required.'
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return 'query_array_integer64 is required.'
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return 'query_array_number is required.'
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return 'query_array_float is required.'
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return 'query_array_double is required.'
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return 'query_array_string is required.'
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return 'query_array_string_byte is required.'
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return 'query_array_string_binary is required.'
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return 'query_array_boolean is required.'
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return 'query_array_date is required.'
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return 'query_array_date_time is required.'
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return 'query_array_password is required.'
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('delete', 'http://localhost:8943/test/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=usual_parameters_test_delete_test_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('usual_parameters_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=usual_parameters_test_delete_test_with_all_parameters_types] [url=http://localhost:8943/test/with/all/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=usual_parameters_test_delete_test_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=usual_parameters_test_delete_test_with_all_parameters_types] [url=http://localhost:8943/test/with/all/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='usual_parameters_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def usual_parameters_test_get_test_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=usual_parameters_test_get_test_with_all_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return 'query_integer is required.'
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return 'query_integer32 is required.'
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return 'query_integer64 is required.'
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return 'query_number is required.'
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return 'query_float is required.'
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return 'query_double is required.'
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return 'query_string is required.'
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return 'query_string_byte is required.'
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return 'query_string_binary is required.'
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return 'query_boolean is required.'
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return 'query_date is required.'
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return 'query_date_time is required.'
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return 'query_password is required.'
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return 'query_array_integer is required.'
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return 'query_array_integer32 is required.'
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return 'query_array_integer64 is required.'
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return 'query_array_number is required.'
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return 'query_array_float is required.'
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return 'query_array_double is required.'
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return 'query_array_string is required.'
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return 'query_array_string_byte is required.'
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return 'query_array_string_binary is required.'
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return 'query_array_boolean is required.'
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return 'query_array_date is required.'
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return 'query_array_date_time is required.'
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return 'query_array_password is required.'
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8943/test/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=usual_parameters_test_get_test_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('usual_parameters_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=usual_parameters_test_get_test_with_all_parameters_types] [url=http://localhost:8943/test/with/all/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=usual_parameters_test_get_test_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=usual_parameters_test_get_test_with_all_parameters_types] [url=http://localhost:8943/test/with/all/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='usual_parameters_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def usual_parameters_test_post_test_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=usual_parameters_test_post_test_with_all_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return 'query_integer is required.'
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return 'query_integer32 is required.'
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return 'query_integer64 is required.'
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return 'query_number is required.'
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return 'query_float is required.'
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return 'query_double is required.'
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return 'query_string is required.'
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return 'query_string_byte is required.'
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return 'query_string_binary is required.'
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return 'query_boolean is required.'
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return 'query_date is required.'
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return 'query_date_time is required.'
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return 'query_password is required.'
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return 'query_array_integer is required.'
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return 'query_array_integer32 is required.'
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return 'query_array_integer64 is required.'
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return 'query_array_number is required.'
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return 'query_array_float is required.'
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return 'query_array_double is required.'
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return 'query_array_string is required.'
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return 'query_array_string_byte is required.'
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return 'query_array_string_binary is required.'
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return 'query_array_boolean is required.'
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return 'query_array_date is required.'
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return 'query_array_date_time is required.'
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return 'query_array_password is required.'
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8943/test/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=usual_parameters_test_post_test_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('usual_parameters_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=usual_parameters_test_post_test_with_all_parameters_types] [url=http://localhost:8943/test/with/all/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=usual_parameters_test_post_test_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=usual_parameters_test_post_test_with_all_parameters_types] [url=http://localhost:8943/test/with/all/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='usual_parameters_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def usual_parameters_test_put_test_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=usual_parameters_test_put_test_with_all_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return 'query_integer is required.'
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return 'query_integer32 is required.'
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return 'query_integer64 is required.'
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return 'query_number is required.'
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return 'query_float is required.'
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return 'query_double is required.'
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return 'query_string is required.'
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return 'query_string_byte is required.'
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return 'query_string_binary is required.'
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return 'query_boolean is required.'
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return 'query_date is required.'
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return 'query_date_time is required.'
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return 'query_password is required.'
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return 'query_array_integer is required.'
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return 'query_array_integer32 is required.'
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return 'query_array_integer64 is required.'
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return 'query_array_number is required.'
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return 'query_array_float is required.'
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return 'query_array_double is required.'
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return 'query_array_string is required.'
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return 'query_array_string_byte is required.'
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return 'query_array_string_binary is required.'
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return 'query_array_boolean is required.'
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return 'query_array_date is required.'
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return 'query_array_date_time is required.'
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return 'query_array_password is required.'
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8943/test/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=usual_parameters_test_put_test_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('usual_parameters_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=usual_parameters_test_put_test_with_all_parameters_types] [url=http://localhost:8943/test/with/all/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=usual_parameters_test_put_test_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=usual_parameters_test_put_test_with_all_parameters_types] [url=http://localhost:8943/test/with/all/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='usual_parameters_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
def usual_parameters_test_delete_test_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=usual_parameters_test_delete_test_with_all_paths_types]...")
    request_header = {}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return 'path_integer is required.'

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return 'path_integer32 is required.'

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return 'path_integer64 is required.'

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return 'path_number is required.'

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return 'path_float is required.'

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return 'path_double is required.'

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return 'path_string is required.'

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return 'path_string_byte is required.'

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return 'path_string_binary is required.'

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return 'path_boolean is required.'

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return 'path_date is required.'

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return 'path_date_time is required.'

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return 'path_password is required.'

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return 'path_array_integer is required.'

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return 'path_array_integer32 is required.'

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return 'path_array_integer64 is required.'

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return 'path_array_number is required.'

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return 'path_array_float is required.'

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return 'path_array_double is required.'

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return 'path_array_string is required.'

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return 'path_array_string_byte is required.'

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return 'path_array_string_binary is required.'

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return 'path_array_boolean is required.'

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return 'path_array_date is required.'

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return 'path_array_date_time is required.'

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return 'path_array_password is required.'


    response = None
    try:
        response = session.get(5).request('delete', 'http://localhost:8943/test/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=usual_parameters_test_delete_test_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('usual_parameters_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=usual_parameters_test_delete_test_with_all_paths_types] [url=http://localhost:8943/test/with/all/paths/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=usual_parameters_test_delete_test_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=usual_parameters_test_delete_test_with_all_paths_types] [url=http://localhost:8943/test/with/all/paths/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='usual_parameters_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
def usual_parameters_test_get_test_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=usual_parameters_test_get_test_with_all_paths_types]...")
    request_header = {}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return 'path_integer is required.'

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return 'path_integer32 is required.'

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return 'path_integer64 is required.'

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return 'path_number is required.'

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return 'path_float is required.'

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return 'path_double is required.'

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return 'path_string is required.'

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return 'path_string_byte is required.'

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return 'path_string_binary is required.'

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return 'path_boolean is required.'

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return 'path_date is required.'

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return 'path_date_time is required.'

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return 'path_password is required.'

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return 'path_array_integer is required.'

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return 'path_array_integer32 is required.'

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return 'path_array_integer64 is required.'

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return 'path_array_number is required.'

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return 'path_array_float is required.'

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return 'path_array_double is required.'

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return 'path_array_string is required.'

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return 'path_array_string_byte is required.'

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return 'path_array_string_binary is required.'

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return 'path_array_boolean is required.'

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return 'path_array_date is required.'

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return 'path_array_date_time is required.'

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return 'path_array_password is required.'


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8943/test/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=usual_parameters_test_get_test_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('usual_parameters_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=usual_parameters_test_get_test_with_all_paths_types] [url=http://localhost:8943/test/with/all/paths/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=usual_parameters_test_get_test_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=usual_parameters_test_get_test_with_all_paths_types] [url=http://localhost:8943/test/with/all/paths/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='usual_parameters_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
def usual_parameters_test_post_test_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=usual_parameters_test_post_test_with_all_paths_types]...")
    request_header = {}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return 'path_integer is required.'

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return 'path_integer32 is required.'

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return 'path_integer64 is required.'

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return 'path_number is required.'

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return 'path_float is required.'

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return 'path_double is required.'

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return 'path_string is required.'

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return 'path_string_byte is required.'

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return 'path_string_binary is required.'

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return 'path_boolean is required.'

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return 'path_date is required.'

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return 'path_date_time is required.'

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return 'path_password is required.'

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return 'path_array_integer is required.'

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return 'path_array_integer32 is required.'

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return 'path_array_integer64 is required.'

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return 'path_array_number is required.'

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return 'path_array_float is required.'

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return 'path_array_double is required.'

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return 'path_array_string is required.'

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return 'path_array_string_byte is required.'

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return 'path_array_string_binary is required.'

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return 'path_array_boolean is required.'

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return 'path_array_date is required.'

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return 'path_array_date_time is required.'

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return 'path_array_password is required.'


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8943/test/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=usual_parameters_test_post_test_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('usual_parameters_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=usual_parameters_test_post_test_with_all_paths_types] [url=http://localhost:8943/test/with/all/paths/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=usual_parameters_test_post_test_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=usual_parameters_test_post_test_with_all_paths_types] [url=http://localhost:8943/test/with/all/paths/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='usual_parameters_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
def usual_parameters_test_put_test_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=usual_parameters_test_put_test_with_all_paths_types]...")
    request_header = {}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return 'path_integer is required.'

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return 'path_integer32 is required.'

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return 'path_integer64 is required.'

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return 'path_number is required.'

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return 'path_float is required.'

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return 'path_double is required.'

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return 'path_string is required.'

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return 'path_string_byte is required.'

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return 'path_string_binary is required.'

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return 'path_boolean is required.'

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return 'path_date is required.'

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return 'path_date_time is required.'

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return 'path_password is required.'

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return 'path_array_integer is required.'

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return 'path_array_integer32 is required.'

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return 'path_array_integer64 is required.'

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return 'path_array_number is required.'

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return 'path_array_float is required.'

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return 'path_array_double is required.'

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return 'path_array_string is required.'

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return 'path_array_string_byte is required.'

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return 'path_array_string_binary is required.'

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return 'path_array_boolean is required.'

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return 'path_array_date is required.'

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return 'path_array_date_time is required.'

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return 'path_array_password is required.'


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8943/test/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=usual_parameters_test_put_test_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('usual_parameters_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=usual_parameters_test_put_test_with_all_paths_types] [url=http://localhost:8943/test/with/all/paths/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=usual_parameters_test_put_test_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=usual_parameters_test_put_test_with_all_paths_types] [url=http://localhost:8943/test/with/all/paths/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

all_definitions['filtered_tags_test'] = OrderedDict([(u'TestObject', OrderedDict([(u'properties', OrderedDict([(u'test', OrderedDict([(u'description', u'test'), (u'type', u'string')]))])), (u'title', u'Test'), (u'type', u'object')]))])


@caching
@xw.func(category='filtered_tags_test', call_in_wizard=False)
def filtered_tags_test_get_test_with_tags():
    logger.info("[status=Calling] [function=filtered_tags_test_get_test_with_tags]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8944/test/with/tags'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=filtered_tags_test_get_test_with_tags] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('filtered_tags_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=filtered_tags_test_get_test_with_tags] [url=http://localhost:8944/test/with/tags].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=filtered_tags_test_get_test_with_tags] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=filtered_tags_test_get_test_with_tags] [url=http://localhost:8944/test/with/tags].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='filtered_tags_test', call_in_wizard=False)
def filtered_tags_test_post_test_with_tags():
    logger.info("[status=Calling] [function=filtered_tags_test_post_test_with_tags]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8944/test/with/tags'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=filtered_tags_test_post_test_with_tags] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('filtered_tags_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=filtered_tags_test_post_test_with_tags] [url=http://localhost:8944/test/with/tags].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=filtered_tags_test_post_test_with_tags] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=filtered_tags_test_post_test_with_tags] [url=http://localhost:8944/test/with/tags].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='filtered_tags_test', call_in_wizard=False)
def filtered_tags_test_put_test_with_tags():
    logger.info("[status=Calling] [function=filtered_tags_test_put_test_with_tags]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8944/test/with/tags'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=filtered_tags_test_put_test_with_tags] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('filtered_tags_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=filtered_tags_test_put_test_with_tags] [url=http://localhost:8944/test/with/tags].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=filtered_tags_test_put_test_with_tags] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=filtered_tags_test_put_test_with_tags] [url=http://localhost:8944/test/with/tags].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

all_definitions['values_false_test'] = OrderedDict([(u'Empty', OrderedDict([(u'properties', OrderedDict())])), (u'EmptyDictionary', OrderedDict([(u'properties', OrderedDict([(u'empty_dictionary', OrderedDict([(u'$ref', u'#/definitions/Empty'), (u'type', u'object')]))]))])), (u'EmptyList', OrderedDict([(u'properties', OrderedDict([(u'empty_list', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/Empty')])), (u'type', u'array')]))]))])), (u'EmptyString', OrderedDict([(u'properties', OrderedDict([(u'empty_string', OrderedDict([(u'type', u'string')]))]))])), (u'FalseBoolean', OrderedDict([(u'properties', OrderedDict([(u'false_boolean', OrderedDict([(u'type', u'boolean')]))]))])), (u'ZeroFloat', OrderedDict([(u'properties', OrderedDict([(u'zero_float', OrderedDict([(u'format', u'float'), (u'type', u'number')]))]))])), (u'ZeroInteger', OrderedDict([(u'properties', OrderedDict([(u'zero_integer', OrderedDict([(u'format', u'int32'), (u'type', u'integer')]))]))]))])


@caching
@xw.func(category='values_false_test', call_in_wizard=False)
def values_false_test_get_test_with_empty_dictionary():
    logger.info("[status=Calling] [function=values_false_test_get_test_with_empty_dictionary]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8945/test/with/empty/dictionary'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=values_false_test_get_test_with_empty_dictionary] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/EmptyDictionary')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('values_false_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=values_false_test_get_test_with_empty_dictionary] [url=http://localhost:8945/test/with/empty/dictionary].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=values_false_test_get_test_with_empty_dictionary] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=values_false_test_get_test_with_empty_dictionary] [url=http://localhost:8945/test/with/empty/dictionary].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='values_false_test', call_in_wizard=False)
def values_false_test_get_test_with_empty_list():
    logger.info("[status=Calling] [function=values_false_test_get_test_with_empty_list]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8945/test/with/empty/list'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=values_false_test_get_test_with_empty_list] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/EmptyList')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('values_false_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=values_false_test_get_test_with_empty_list] [url=http://localhost:8945/test/with/empty/list].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=values_false_test_get_test_with_empty_list] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=values_false_test_get_test_with_empty_list] [url=http://localhost:8945/test/with/empty/list].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='values_false_test', call_in_wizard=False)
def values_false_test_get_test_with_empty_string():
    logger.info("[status=Calling] [function=values_false_test_get_test_with_empty_string]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8945/test/with/empty/string'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=values_false_test_get_test_with_empty_string] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/EmptyString')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('values_false_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=values_false_test_get_test_with_empty_string] [url=http://localhost:8945/test/with/empty/string].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=values_false_test_get_test_with_empty_string] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=values_false_test_get_test_with_empty_string] [url=http://localhost:8945/test/with/empty/string].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='values_false_test', call_in_wizard=False)
def values_false_test_get_test_with_false_boolean():
    logger.info("[status=Calling] [function=values_false_test_get_test_with_false_boolean]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8945/test/with/false/boolean'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=values_false_test_get_test_with_false_boolean] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/FalseBoolean')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('values_false_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=values_false_test_get_test_with_false_boolean] [url=http://localhost:8945/test/with/false/boolean].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=values_false_test_get_test_with_false_boolean] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=values_false_test_get_test_with_false_boolean] [url=http://localhost:8945/test/with/false/boolean].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='values_false_test', call_in_wizard=False)
def values_false_test_get_test_with_zero_float():
    logger.info("[status=Calling] [function=values_false_test_get_test_with_zero_float]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8945/test/with/zero/float'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=values_false_test_get_test_with_zero_float] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/ZeroFloat')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('values_false_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=values_false_test_get_test_with_zero_float] [url=http://localhost:8945/test/with/zero/float].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=values_false_test_get_test_with_zero_float] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=values_false_test_get_test_with_zero_float] [url=http://localhost:8945/test/with/zero/float].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='values_false_test', call_in_wizard=False)
def values_false_test_get_test_with_zero_integer():
    logger.info("[status=Calling] [function=values_false_test_get_test_with_zero_integer]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8945/test/with/zero/integer'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=values_false_test_get_test_with_zero_integer] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/ZeroInteger')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('values_false_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=values_false_test_get_test_with_zero_integer] [url=http://localhost:8945/test/with/zero/integer].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=values_false_test_get_test_with_zero_integer] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=values_false_test_get_test_with_zero_integer] [url=http://localhost:8945/test/with/zero/integer].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

all_definitions['output_order_test'] = OrderedDict([(u'Price', OrderedDict([(u'required', [u'curve', u'date', u'mat', u'ts']), (u'type', u'object'), (u'properties', OrderedDict([(u'ts', OrderedDict([(u'type', u'string'), (u'description', u'timeslot'), (u'maxLength', 2)])), (u'date', OrderedDict([(u'type', u'string'), (u'description', u'date'), (u'format', u'date')])), (u'curve', OrderedDict([(u'type', u'string'), (u'description', u'curvename'), (u'maxLength', 20)])), (u'mat', OrderedDict([(u'type', u'string'), (u'description', u'maturity'), (u'maxLength', 4)]))])), (u'title', u'RealizedPrice')]))])


@caching
@xw.func(category='output_order_test', call_in_wizard=False)
@xw.arg('date_visual_basic', dates=datetime.date, doc='date')
@xw.arg('curve', doc='curvename')
@xw.arg('ts', doc='timeslot')
@xw.arg('mat', doc='maturity')
def output_order_test_get_test_price_unordered(date_visual_basic=None, curve=None, ts=None, mat=None):
    logger.info("[status=Calling] [function=output_order_test_get_test_price_unordered]...")
    request_header = {}
    request_parameters = {}

    if date_visual_basic is not None:
        if not isinstance(date_visual_basic, datetime.date):
            logger.error('date_visual_basic must be a date.')
            return 'date_visual_basic must be a date.'

        request_parameters['date'] = date_visual_basic

    if curve is not None:

        request_parameters['curve'] = curve

    if ts is not None:

        request_parameters['ts'] = ts

    if mat is not None:

        request_parameters['mat'] = mat


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8946/price/unordered'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=output_order_test_get_test_price_unordered] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/Price')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('output_order_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=output_order_test_get_test_price_unordered] [url=http://localhost:8946/price/unordered].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=output_order_test_get_test_price_unordered] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=output_order_test_get_test_price_unordered] [url=http://localhost:8946/price/unordered].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

all_definitions['nested_data_test'] = OrderedDict([(u'Column', OrderedDict([(u'properties', OrderedDict([(u'Column 1', OrderedDict([(u'description', u'column1'), (u'type', u'string')])), (u'Column 2', OrderedDict([(u'description', u'column2'), (u'items', OrderedDict([(u'$ref', u'#/definitions/Column')])), (u'type', u'array')])), (u'Column 3', OrderedDict([(u'description', u'column3'), (u'type', u'string')]))])), (u'title', u'Column'), (u'type', u'object')])), (u'Column1', OrderedDict([(u'properties', OrderedDict([(u'Column 1', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/Column2And3')])), (u'type', u'array')]))])), (u'title', u'Column1'), (u'type', u'object')])), (u'Column1List', OrderedDict([(u'properties', OrderedDict([(u'Column 1', OrderedDict([(u'items', OrderedDict([(u'type', u'string')])), (u'type', u'array')]))])), (u'title', u'Column1'), (u'type', u'object')])), (u'Column2And3', OrderedDict([(u'properties', OrderedDict([(u'Column 2', OrderedDict([(u'description', u'column1'), (u'type', u'string')])), (u'Column 3', OrderedDict([(u'description', u'column3'), (u'type', u'string')]))])), (u'title', u'Column2+3'), (u'type', u'object')]))])


@caching
@xw.func(category='nested_data_test', call_in_wizard=False)
def nested_data_test_get_test_dict_with_empty_nested_list():
    logger.info("[status=Calling] [function=nested_data_test_get_test_dict_with_empty_nested_list]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8947/test/dict/with/empty/nested/list'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=nested_data_test_get_test_dict_with_empty_nested_list] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'$ref', u'#/definitions/Column')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('nested_data_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=nested_data_test_get_test_dict_with_empty_nested_list] [url=http://localhost:8947/test/dict/with/empty/nested/list].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=nested_data_test_get_test_dict_with_empty_nested_list] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=nested_data_test_get_test_dict_with_empty_nested_list] [url=http://localhost:8947/test/dict/with/empty/nested/list].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='nested_data_test', call_in_wizard=False)
def nested_data_test_get_test_dict_with_four_imbricated_levels():
    logger.info("[status=Calling] [function=nested_data_test_get_test_dict_with_four_imbricated_levels]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8947/test/dict/with/four/imbricated/levels'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=nested_data_test_get_test_dict_with_four_imbricated_levels] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'$ref', u'#/definitions/Column')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('nested_data_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=nested_data_test_get_test_dict_with_four_imbricated_levels] [url=http://localhost:8947/test/dict/with/four/imbricated/levels].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=nested_data_test_get_test_dict_with_four_imbricated_levels] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=nested_data_test_get_test_dict_with_four_imbricated_levels] [url=http://localhost:8947/test/dict/with/four/imbricated/levels].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='nested_data_test', call_in_wizard=False)
def nested_data_test_get_test_dict_with_list():
    logger.info("[status=Calling] [function=nested_data_test_get_test_dict_with_list]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8947/test/dict/with/list'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=nested_data_test_get_test_dict_with_list] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation')]))])
            return json_as_list(response, all_responses, all_definitions.get('nested_data_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=nested_data_test_get_test_dict_with_list] [url=http://localhost:8947/test/dict/with/list].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=nested_data_test_get_test_dict_with_list] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=nested_data_test_get_test_dict_with_list] [url=http://localhost:8947/test/dict/with/list].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='nested_data_test', call_in_wizard=False)
def nested_data_test_get_test_dict_with_list_of_different_size():
    logger.info("[status=Calling] [function=nested_data_test_get_test_dict_with_list_of_different_size]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8947/test/dict/with/list/of/different/size'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=nested_data_test_get_test_dict_with_list_of_different_size] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation')]))])
            return json_as_list(response, all_responses, all_definitions.get('nested_data_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=nested_data_test_get_test_dict_with_list_of_different_size] [url=http://localhost:8947/test/dict/with/list/of/different/size].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=nested_data_test_get_test_dict_with_list_of_different_size] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=nested_data_test_get_test_dict_with_list_of_different_size] [url=http://localhost:8947/test/dict/with/list/of/different/size].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='nested_data_test', call_in_wizard=False)
def nested_data_test_get_test_dict_with_multiple_imbricated_levels_and_duplicate_keys():
    logger.info("[status=Calling] [function=nested_data_test_get_test_dict_with_multiple_imbricated_levels_and_duplicate_keys]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8947/test/dict/with/multiple/imbricated/levels/and/duplicate/keys'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=nested_data_test_get_test_dict_with_multiple_imbricated_levels_and_duplicate_keys] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'$ref', u'#/definitions/Column')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('nested_data_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=nested_data_test_get_test_dict_with_multiple_imbricated_levels_and_duplicate_keys] [url=http://localhost:8947/test/dict/with/multiple/imbricated/levels/and/duplicate/keys].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=nested_data_test_get_test_dict_with_multiple_imbricated_levels_and_duplicate_keys] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=nested_data_test_get_test_dict_with_multiple_imbricated_levels_and_duplicate_keys] [url=http://localhost:8947/test/dict/with/multiple/imbricated/levels/and/duplicate/keys].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='nested_data_test', call_in_wizard=False)
def nested_data_test_get_test_dict_with_three_imbricated_levels():
    logger.info("[status=Calling] [function=nested_data_test_get_test_dict_with_three_imbricated_levels]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8947/test/dict/with/three/imbricated/levels'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=nested_data_test_get_test_dict_with_three_imbricated_levels] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'$ref', u'#/definitions/Column')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('nested_data_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=nested_data_test_get_test_dict_with_three_imbricated_levels] [url=http://localhost:8947/test/dict/with/three/imbricated/levels].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=nested_data_test_get_test_dict_with_three_imbricated_levels] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=nested_data_test_get_test_dict_with_three_imbricated_levels] [url=http://localhost:8947/test/dict/with/three/imbricated/levels].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='nested_data_test', call_in_wizard=False)
def nested_data_test_get_test_dict_with_various_columns():
    logger.info("[status=Calling] [function=nested_data_test_get_test_dict_with_various_columns]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8947/test/dict/with/various/columns'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=nested_data_test_get_test_dict_with_various_columns] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation')]))])
            return json_as_list(response, all_responses, all_definitions.get('nested_data_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=nested_data_test_get_test_dict_with_various_columns] [url=http://localhost:8947/test/dict/with/various/columns].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=nested_data_test_get_test_dict_with_various_columns] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=nested_data_test_get_test_dict_with_various_columns] [url=http://localhost:8947/test/dict/with/various/columns].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='nested_data_test', call_in_wizard=False)
def nested_data_test_get_test_empty_dict():
    logger.info("[status=Calling] [function=nested_data_test_get_test_empty_dict]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8947/test/empty/dict'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=nested_data_test_get_test_empty_dict] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'$ref', u'#/definitions/Column')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('nested_data_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=nested_data_test_get_test_empty_dict] [url=http://localhost:8947/test/empty/dict].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=nested_data_test_get_test_empty_dict] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=nested_data_test_get_test_empty_dict] [url=http://localhost:8947/test/empty/dict].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='nested_data_test', call_in_wizard=False)
def nested_data_test_get_test_empty_list():
    logger.info("[status=Calling] [function=nested_data_test_get_test_empty_list]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8947/test/empty/list'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=nested_data_test_get_test_empty_list] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/Column')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('nested_data_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=nested_data_test_get_test_empty_list] [url=http://localhost:8947/test/empty/list].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=nested_data_test_get_test_empty_list] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=nested_data_test_get_test_empty_list] [url=http://localhost:8947/test/empty/list].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='nested_data_test', call_in_wizard=False)
def nested_data_test_get_test_list_of_dict():
    logger.info("[status=Calling] [function=nested_data_test_get_test_list_of_dict]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8947/test/list/of/dict'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=nested_data_test_get_test_list_of_dict] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/Column2And3')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('nested_data_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=nested_data_test_get_test_list_of_dict] [url=http://localhost:8947/test/list/of/dict].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=nested_data_test_get_test_list_of_dict] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=nested_data_test_get_test_list_of_dict] [url=http://localhost:8947/test/list/of/dict].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='nested_data_test', call_in_wizard=False)
def nested_data_test_get_test_one_dict_entry_with_a_list():
    logger.info("[status=Calling] [function=nested_data_test_get_test_one_dict_entry_with_a_list]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8947/test/one/dict/entry/with/a/list'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=nested_data_test_get_test_one_dict_entry_with_a_list] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'$ref', u'#/definitions/Column1List')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('nested_data_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=nested_data_test_get_test_one_dict_entry_with_a_list] [url=http://localhost:8947/test/one/dict/entry/with/a/list].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=nested_data_test_get_test_one_dict_entry_with_a_list] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=nested_data_test_get_test_one_dict_entry_with_a_list] [url=http://localhost:8947/test/one/dict/entry/with/a/list].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='nested_data_test', call_in_wizard=False)
def nested_data_test_get_test_one_dict_entry_with_a_list_of_dict():
    logger.info("[status=Calling] [function=nested_data_test_get_test_one_dict_entry_with_a_list_of_dict]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8947/test/one/dict/entry/with/a/list/of/dict'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=nested_data_test_get_test_one_dict_entry_with_a_list_of_dict] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'$ref', u'#/definitions/Column1')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('nested_data_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=nested_data_test_get_test_one_dict_entry_with_a_list_of_dict] [url=http://localhost:8947/test/one/dict/entry/with/a/list/of/dict].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=nested_data_test_get_test_one_dict_entry_with_a_list_of_dict] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=nested_data_test_get_test_one_dict_entry_with_a_list_of_dict] [url=http://localhost:8947/test/one/dict/entry/with/a/list/of/dict].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='nested_data_test', call_in_wizard=False)
def nested_data_test_get_test_one_level_dict():
    logger.info("[status=Calling] [function=nested_data_test_get_test_one_level_dict]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8947/test/one/level/dict'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=nested_data_test_get_test_one_level_dict] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'$ref', u'#/definitions/Column2And3')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('nested_data_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=nested_data_test_get_test_one_level_dict] [url=http://localhost:8947/test/one/level/dict].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=nested_data_test_get_test_one_level_dict] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=nested_data_test_get_test_one_level_dict] [url=http://localhost:8947/test/one/level/dict].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='nested_data_test', call_in_wizard=False)
def nested_data_test_get_test_one_level_list():
    logger.info("[status=Calling] [function=nested_data_test_get_test_one_level_list]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8947/test/one/level/list'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=nested_data_test_get_test_one_level_list] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'type', u'string')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('nested_data_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=nested_data_test_get_test_one_level_list] [url=http://localhost:8947/test/one/level/list].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=nested_data_test_get_test_one_level_list] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=nested_data_test_get_test_one_level_list] [url=http://localhost:8947/test/one/level/list].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

all_definitions['vba_keywords_test'] = OrderedDict([(u'VBAKeywords', OrderedDict([(u'properties', OrderedDict([(u'addhandler', OrderedDict()), (u'addressof', OrderedDict()), (u'alias', OrderedDict()), (u'and', OrderedDict()), (u'andalso', OrderedDict()), (u'as', OrderedDict()), (u'boolean', OrderedDict()), (u'byref', OrderedDict()), (u'byte', OrderedDict()), (u'byval', OrderedDict()), (u'call', OrderedDict()), (u'case', OrderedDict()), (u'catch', OrderedDict()), (u'cbool', OrderedDict()), (u'cbyte', OrderedDict()), (u'cchar', OrderedDict()), (u'cdate', OrderedDict()), (u'cdbl', OrderedDict()), (u'cdec', OrderedDict()), (u'char', OrderedDict()), (u'cint', OrderedDict()), (u'class', OrderedDict()), (u'clng', OrderedDict()), (u'cobj', OrderedDict()), (u'const', OrderedDict()), (u'continue', OrderedDict()), (u'csbyte', OrderedDict()), (u'cshort', OrderedDict()), (u'csng', OrderedDict()), (u'cstr', OrderedDict()), (u'ctype', OrderedDict()), (u'cuint', OrderedDict()), (u'culng', OrderedDict()), (u'currency', OrderedDict()), (u'cushort', OrderedDict()), (u'date', OrderedDict()), (u'decimal', OrderedDict()), (u'declare', OrderedDict()), (u'default', OrderedDict()), (u'delegate', OrderedDict()), (u'dim', OrderedDict()), (u'directcast', OrderedDict()), (u'do', OrderedDict()), (u'double', OrderedDict()), (u'each', OrderedDict()), (u'else', OrderedDict()), (u'elseif', OrderedDict()), (u'end', OrderedDict()), (u'endif', OrderedDict()), (u'enum', OrderedDict()), (u'erase', OrderedDict()), (u'error', OrderedDict()), (u'event', OrderedDict()), (u'exit', OrderedDict()), (u'finally', OrderedDict()), (u'for', OrderedDict()), (u'friend', OrderedDict()), (u'function', OrderedDict()), (u'get', OrderedDict()), (u'gettype', OrderedDict()), (u'getxmlnamespace', OrderedDict()), (u'global', OrderedDict()), (u'gosub', OrderedDict()), (u'goto', OrderedDict()), (u'handles', OrderedDict()), (u'if', OrderedDict()), (u'implements', OrderedDict()), (u'imports', OrderedDict()), (u'in', OrderedDict()), (u'inherits', OrderedDict()), (u'integer', OrderedDict()), (u'interface', OrderedDict()), (u'is', OrderedDict()), (u'isnot', OrderedDict()), (u'let', OrderedDict()), (u'lib', OrderedDict()), (u'like', OrderedDict()), (u'long', OrderedDict()), (u'loop', OrderedDict()), (u'me', OrderedDict()), (u'mod', OrderedDict()), (u'module', OrderedDict()), (u'mustinherit', OrderedDict()), (u'mustoverride', OrderedDict()), (u'mybase', OrderedDict()), (u'myclass', OrderedDict()), (u'namespace', OrderedDict()), (u'narrowing', OrderedDict()), (u'new', OrderedDict()), (u'next', OrderedDict()), (u'not', OrderedDict()), (u'nothing', OrderedDict()), (u'notinheritable', OrderedDict()), (u'notoverridable', OrderedDict()), (u'object', OrderedDict()), (u'of', OrderedDict()), (u'on', OrderedDict()), (u'operator', OrderedDict()), (u'option', OrderedDict()), (u'optional', OrderedDict()), (u'or', OrderedDict()), (u'orelse', OrderedDict()), (u'overloads', OrderedDict()), (u'overridable', OrderedDict()), (u'overrides', OrderedDict()), (u'paramarray', OrderedDict()), (u'partial', OrderedDict()), (u'private', OrderedDict()), (u'property', OrderedDict()), (u'protected', OrderedDict()), (u'public', OrderedDict()), (u'raiseevent', OrderedDict()), (u'readonly', OrderedDict()), (u'redim', OrderedDict()), (u'rem', OrderedDict()), (u'removehandler', OrderedDict()), (u'resume', OrderedDict()), (u'return', OrderedDict()), (u'sbyte', OrderedDict()), (u'select', OrderedDict()), (u'set', OrderedDict()), (u'shadows', OrderedDict()), (u'shared', OrderedDict()), (u'short', OrderedDict()), (u'single', OrderedDict()), (u'static', OrderedDict()), (u'step', OrderedDict()), (u'stop', OrderedDict()), (u'string', OrderedDict()), (u'structure', OrderedDict()), (u'sub', OrderedDict()), (u'synclock', OrderedDict()), (u'then', OrderedDict()), (u'throw', OrderedDict()), (u'to', OrderedDict()), (u'try', OrderedDict()), (u'trycast', OrderedDict()), (u'type', OrderedDict()), (u'typeof', OrderedDict()), (u'uinteger', OrderedDict()), (u'ulong', OrderedDict()), (u'ushort', OrderedDict()), (u'using', OrderedDict()), (u'variant', OrderedDict()), (u'wend', OrderedDict()), (u'when', OrderedDict()), (u'while', OrderedDict()), (u'widening', OrderedDict()), (u'with', OrderedDict()), (u'withevents', OrderedDict()), (u'writeonly', OrderedDict()), (u'xor', OrderedDict())]))]))])


@caching
@xw.func(category='vba_keywords_test', call_in_wizard=False)
@xw.arg('addhandler_visual_basic', doc='')
@xw.arg('addressof_visual_basic', doc='')
@xw.arg('alias_visual_basic', doc='')
@xw.arg('and_visual_basic', doc='')
@xw.arg('andalso_visual_basic', doc='')
@xw.arg('as_visual_basic', doc='')
@xw.arg('boolean_visual_basic', doc='')
@xw.arg('byref_visual_basic', doc='')
@xw.arg('byte_visual_basic', doc='')
@xw.arg('byval_visual_basic', doc='')
@xw.arg('call_visual_basic', doc='')
@xw.arg('case_visual_basic', doc='')
@xw.arg('catch_visual_basic', doc='')
@xw.arg('cbool_visual_basic', doc='')
@xw.arg('cbyte_visual_basic', doc='')
@xw.arg('cchar_visual_basic', doc='')
@xw.arg('cdate_visual_basic', doc='')
@xw.arg('cdbl_visual_basic', doc='')
@xw.arg('cdec_visual_basic', doc='')
@xw.arg('char_visual_basic', doc='')
@xw.arg('cint_visual_basic', doc='')
@xw.arg('class_visual_basic', doc='')
@xw.arg('clng_visual_basic', doc='')
@xw.arg('cobj_visual_basic', doc='')
@xw.arg('const_visual_basic', doc='')
@xw.arg('continue_visual_basic', doc='')
@xw.arg('csbyte_visual_basic', doc='')
@xw.arg('cshort_visual_basic', doc='')
@xw.arg('csng_visual_basic', doc='')
@xw.arg('cstr_visual_basic', doc='')
@xw.arg('ctype_visual_basic', doc='')
@xw.arg('cuint_visual_basic', doc='')
@xw.arg('culng_visual_basic', doc='')
@xw.arg('currency_visual_basic', doc='')
@xw.arg('cushort_visual_basic', doc='')
@xw.arg('date_visual_basic', doc='')
@xw.arg('decimal_visual_basic', doc='')
@xw.arg('declare_visual_basic', doc='')
@xw.arg('default_visual_basic', doc='')
@xw.arg('delegate_visual_basic', doc='')
@xw.arg('dim_visual_basic', doc='')
@xw.arg('directcast_visual_basic', doc='')
@xw.arg('do_visual_basic', doc='')
@xw.arg('double_visual_basic', doc='')
@xw.arg('each_visual_basic', doc='')
@xw.arg('else_visual_basic', doc='')
@xw.arg('elseif_visual_basic', doc='')
@xw.arg('end_visual_basic', doc='')
@xw.arg('endif_visual_basic', doc='')
@xw.arg('enum_visual_basic', doc='')
@xw.arg('erase_visual_basic', doc='')
@xw.arg('error_visual_basic', doc='')
@xw.arg('event_visual_basic', doc='')
@xw.arg('exit_visual_basic', doc='')
@xw.arg('finally_visual_basic', doc='')
@xw.arg('for_visual_basic', doc='')
@xw.arg('friend_visual_basic', doc='')
@xw.arg('function_visual_basic', doc='')
@xw.arg('get_visual_basic', doc='')
@xw.arg('gettype_visual_basic', doc='')
@xw.arg('getxmlnamespace_visual_basic', doc='')
@xw.arg('global_visual_basic', doc='')
@xw.arg('gosub_visual_basic', doc='')
@xw.arg('goto_visual_basic', doc='')
@xw.arg('handles_visual_basic', doc='')
@xw.arg('if_visual_basic', doc='')
@xw.arg('implements_visual_basic', doc='')
@xw.arg('imports_visual_basic', doc='')
@xw.arg('in_visual_basic', doc='')
@xw.arg('inherits_visual_basic', doc='')
@xw.arg('integer_visual_basic', doc='')
@xw.arg('interface_visual_basic', doc='')
@xw.arg('is_visual_basic', doc='')
@xw.arg('isnot_visual_basic', doc='')
@xw.arg('let_visual_basic', doc='')
@xw.arg('lib_visual_basic', doc='')
@xw.arg('like_visual_basic', doc='')
@xw.arg('long_visual_basic', doc='')
@xw.arg('loop_visual_basic', doc='')
@xw.arg('me_visual_basic', doc='')
@xw.arg('mod_visual_basic', doc='')
@xw.arg('module_visual_basic', doc='')
@xw.arg('mustinherit_visual_basic', doc='')
@xw.arg('mustoverride_visual_basic', doc='')
@xw.arg('mybase_visual_basic', doc='')
@xw.arg('myclass_visual_basic', doc='')
@xw.arg('namespace_visual_basic', doc='')
@xw.arg('narrowing_visual_basic', doc='')
@xw.arg('new_visual_basic', doc='')
@xw.arg('next_visual_basic', doc='')
@xw.arg('not_visual_basic', doc='')
@xw.arg('nothing_visual_basic', doc='')
@xw.arg('notinheritable_visual_basic', doc='')
@xw.arg('notoverridable_visual_basic', doc='')
@xw.arg('object_visual_basic', doc='')
@xw.arg('of_visual_basic', doc='')
@xw.arg('on_visual_basic', doc='')
@xw.arg('operator_visual_basic', doc='')
@xw.arg('option_visual_basic', doc='')
@xw.arg('optional_visual_basic', doc='')
@xw.arg('or_visual_basic', doc='')
@xw.arg('orelse_visual_basic', doc='')
@xw.arg('overloads_visual_basic', doc='')
@xw.arg('overridable_visual_basic', doc='')
@xw.arg('overrides_visual_basic', doc='')
@xw.arg('paramarray_visual_basic', doc='')
@xw.arg('partial_visual_basic', doc='')
@xw.arg('private_visual_basic', doc='')
@xw.arg('property_visual_basic', doc='')
@xw.arg('protected_visual_basic', doc='')
@xw.arg('public_visual_basic', doc='')
@xw.arg('raiseevent_visual_basic', doc='')
@xw.arg('readonly_visual_basic', doc='')
@xw.arg('redim_visual_basic', doc='')
@xw.arg('rem_visual_basic', doc='')
@xw.arg('removehandler_visual_basic', doc='')
@xw.arg('resume_visual_basic', doc='')
@xw.arg('return_visual_basic', doc='')
@xw.arg('sbyte_visual_basic', doc='')
@xw.arg('select_visual_basic', doc='')
@xw.arg('set_visual_basic', doc='')
@xw.arg('shadows_visual_basic', doc='')
@xw.arg('shared_visual_basic', doc='')
@xw.arg('short_visual_basic', doc='')
@xw.arg('single_visual_basic', doc='')
@xw.arg('static_visual_basic', doc='')
@xw.arg('step_visual_basic', doc='')
@xw.arg('stop_visual_basic', doc='')
@xw.arg('string_visual_basic', doc='')
@xw.arg('structure_visual_basic', doc='')
@xw.arg('sub_visual_basic', doc='')
@xw.arg('synclock_visual_basic', doc='')
@xw.arg('then_visual_basic', doc='')
@xw.arg('throw_visual_basic', doc='')
@xw.arg('to_visual_basic', doc='')
@xw.arg('try_visual_basic', doc='')
@xw.arg('trycast_visual_basic', doc='')
@xw.arg('type_visual_basic', doc='')
@xw.arg('typeof_visual_basic', doc='')
@xw.arg('uinteger_visual_basic', doc='')
@xw.arg('ulong_visual_basic', doc='')
@xw.arg('ushort_visual_basic', doc='')
@xw.arg('using_visual_basic', doc='')
@xw.arg('variant_visual_basic', doc='')
@xw.arg('wend_visual_basic', doc='')
@xw.arg('when_visual_basic', doc='')
@xw.arg('while_visual_basic', doc='')
@xw.arg('widening_visual_basic', doc='')
@xw.arg('with_visual_basic', doc='')
@xw.arg('withevents_visual_basic', doc='')
@xw.arg('writeonly_visual_basic', doc='')
@xw.arg('xor_visual_basic', doc='')
@xw.ret(expand='table')
def vba_keywords_test_delete_test_vba_restricted_keywords(addhandler_visual_basic, addressof_visual_basic, alias_visual_basic, and_visual_basic, andalso_visual_basic, as_visual_basic, boolean_visual_basic, byref_visual_basic, byte_visual_basic, byval_visual_basic, call_visual_basic, case_visual_basic, catch_visual_basic, cbool_visual_basic, cbyte_visual_basic, cchar_visual_basic, cdate_visual_basic, cdbl_visual_basic, cdec_visual_basic, char_visual_basic, cint_visual_basic, class_visual_basic, clng_visual_basic, cobj_visual_basic, const_visual_basic, continue_visual_basic, csbyte_visual_basic, cshort_visual_basic, csng_visual_basic, cstr_visual_basic, ctype_visual_basic, cuint_visual_basic, culng_visual_basic, currency_visual_basic, cushort_visual_basic, date_visual_basic, decimal_visual_basic, declare_visual_basic, default_visual_basic, delegate_visual_basic, dim_visual_basic, directcast_visual_basic, do_visual_basic, double_visual_basic, each_visual_basic, else_visual_basic, elseif_visual_basic, end_visual_basic, endif_visual_basic, enum_visual_basic, erase_visual_basic, error_visual_basic, event_visual_basic, exit_visual_basic, finally_visual_basic, for_visual_basic, friend_visual_basic, function_visual_basic, get_visual_basic, gettype_visual_basic, getxmlnamespace_visual_basic, global_visual_basic, gosub_visual_basic, goto_visual_basic, handles_visual_basic, if_visual_basic, implements_visual_basic, imports_visual_basic, in_visual_basic, inherits_visual_basic, integer_visual_basic, interface_visual_basic, is_visual_basic, isnot_visual_basic, let_visual_basic, lib_visual_basic, like_visual_basic, long_visual_basic, loop_visual_basic, me_visual_basic, mod_visual_basic, module_visual_basic, mustinherit_visual_basic, mustoverride_visual_basic, mybase_visual_basic, myclass_visual_basic, namespace_visual_basic, narrowing_visual_basic, new_visual_basic, next_visual_basic, not_visual_basic, nothing_visual_basic, notinheritable_visual_basic, notoverridable_visual_basic, object_visual_basic, of_visual_basic, on_visual_basic, operator_visual_basic, option_visual_basic, optional_visual_basic, or_visual_basic, orelse_visual_basic, overloads_visual_basic, overridable_visual_basic, overrides_visual_basic, paramarray_visual_basic, partial_visual_basic, private_visual_basic, property_visual_basic, protected_visual_basic, public_visual_basic, raiseevent_visual_basic, readonly_visual_basic, redim_visual_basic, rem_visual_basic, removehandler_visual_basic, resume_visual_basic, return_visual_basic, sbyte_visual_basic, select_visual_basic, set_visual_basic, shadows_visual_basic, shared_visual_basic, short_visual_basic, single_visual_basic, static_visual_basic, step_visual_basic, stop_visual_basic, string_visual_basic, structure_visual_basic, sub_visual_basic, synclock_visual_basic, then_visual_basic, throw_visual_basic, to_visual_basic, try_visual_basic, trycast_visual_basic, type_visual_basic, typeof_visual_basic, uinteger_visual_basic, ulong_visual_basic, ushort_visual_basic, using_visual_basic, variant_visual_basic, wend_visual_basic, when_visual_basic, while_visual_basic, widening_visual_basic, with_visual_basic, withevents_visual_basic, writeonly_visual_basic, xor_visual_basic):
    logger.info("[status=Calling] [function=vba_keywords_test_delete_test_vba_restricted_keywords]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if addhandler_visual_basic is None or isinstance(addhandler_visual_basic, list) and all(x is None for x in addhandler_visual_basic):
        logger.error('addhandler_visual_basic is required.')
        return ['addhandler_visual_basic is required.']
    if addhandler_visual_basic is not None:

        request_parameters['addhandler'] = addhandler_visual_basic

    if addressof_visual_basic is None or isinstance(addressof_visual_basic, list) and all(x is None for x in addressof_visual_basic):
        logger.error('addressof_visual_basic is required.')
        return ['addressof_visual_basic is required.']
    if addressof_visual_basic is not None:

        request_parameters['addressof'] = addressof_visual_basic

    if alias_visual_basic is None or isinstance(alias_visual_basic, list) and all(x is None for x in alias_visual_basic):
        logger.error('alias_visual_basic is required.')
        return ['alias_visual_basic is required.']
    if alias_visual_basic is not None:

        request_parameters['alias'] = alias_visual_basic

    if and_visual_basic is None or isinstance(and_visual_basic, list) and all(x is None for x in and_visual_basic):
        logger.error('and_visual_basic is required.')
        return ['and_visual_basic is required.']
    if and_visual_basic is not None:

        request_parameters['and'] = and_visual_basic

    if andalso_visual_basic is None or isinstance(andalso_visual_basic, list) and all(x is None for x in andalso_visual_basic):
        logger.error('andalso_visual_basic is required.')
        return ['andalso_visual_basic is required.']
    if andalso_visual_basic is not None:

        request_parameters['andalso'] = andalso_visual_basic

    if as_visual_basic is None or isinstance(as_visual_basic, list) and all(x is None for x in as_visual_basic):
        logger.error('as_visual_basic is required.')
        return ['as_visual_basic is required.']
    if as_visual_basic is not None:

        request_parameters['as'] = as_visual_basic

    if boolean_visual_basic is None or isinstance(boolean_visual_basic, list) and all(x is None for x in boolean_visual_basic):
        logger.error('boolean_visual_basic is required.')
        return ['boolean_visual_basic is required.']
    if boolean_visual_basic is not None:

        request_parameters['boolean'] = boolean_visual_basic

    if byref_visual_basic is None or isinstance(byref_visual_basic, list) and all(x is None for x in byref_visual_basic):
        logger.error('byref_visual_basic is required.')
        return ['byref_visual_basic is required.']
    if byref_visual_basic is not None:

        request_parameters['byref'] = byref_visual_basic

    if byte_visual_basic is None or isinstance(byte_visual_basic, list) and all(x is None for x in byte_visual_basic):
        logger.error('byte_visual_basic is required.')
        return ['byte_visual_basic is required.']
    if byte_visual_basic is not None:

        request_parameters['byte'] = byte_visual_basic

    if byval_visual_basic is None or isinstance(byval_visual_basic, list) and all(x is None for x in byval_visual_basic):
        logger.error('byval_visual_basic is required.')
        return ['byval_visual_basic is required.']
    if byval_visual_basic is not None:

        request_parameters['byval'] = byval_visual_basic

    if call_visual_basic is None or isinstance(call_visual_basic, list) and all(x is None for x in call_visual_basic):
        logger.error('call_visual_basic is required.')
        return ['call_visual_basic is required.']
    if call_visual_basic is not None:

        request_parameters['call'] = call_visual_basic

    if case_visual_basic is None or isinstance(case_visual_basic, list) and all(x is None for x in case_visual_basic):
        logger.error('case_visual_basic is required.')
        return ['case_visual_basic is required.']
    if case_visual_basic is not None:

        request_parameters['case'] = case_visual_basic

    if catch_visual_basic is None or isinstance(catch_visual_basic, list) and all(x is None for x in catch_visual_basic):
        logger.error('catch_visual_basic is required.')
        return ['catch_visual_basic is required.']
    if catch_visual_basic is not None:

        request_parameters['catch'] = catch_visual_basic

    if cbool_visual_basic is None or isinstance(cbool_visual_basic, list) and all(x is None for x in cbool_visual_basic):
        logger.error('cbool_visual_basic is required.')
        return ['cbool_visual_basic is required.']
    if cbool_visual_basic is not None:

        request_parameters['cbool'] = cbool_visual_basic

    if cbyte_visual_basic is None or isinstance(cbyte_visual_basic, list) and all(x is None for x in cbyte_visual_basic):
        logger.error('cbyte_visual_basic is required.')
        return ['cbyte_visual_basic is required.']
    if cbyte_visual_basic is not None:

        request_parameters['cbyte'] = cbyte_visual_basic

    if cchar_visual_basic is None or isinstance(cchar_visual_basic, list) and all(x is None for x in cchar_visual_basic):
        logger.error('cchar_visual_basic is required.')
        return ['cchar_visual_basic is required.']
    if cchar_visual_basic is not None:

        request_parameters['cchar'] = cchar_visual_basic

    if cdate_visual_basic is None or isinstance(cdate_visual_basic, list) and all(x is None for x in cdate_visual_basic):
        logger.error('cdate_visual_basic is required.')
        return ['cdate_visual_basic is required.']
    if cdate_visual_basic is not None:

        request_parameters['cdate'] = cdate_visual_basic

    if cdbl_visual_basic is None or isinstance(cdbl_visual_basic, list) and all(x is None for x in cdbl_visual_basic):
        logger.error('cdbl_visual_basic is required.')
        return ['cdbl_visual_basic is required.']
    if cdbl_visual_basic is not None:

        request_parameters['cdbl'] = cdbl_visual_basic

    if cdec_visual_basic is None or isinstance(cdec_visual_basic, list) and all(x is None for x in cdec_visual_basic):
        logger.error('cdec_visual_basic is required.')
        return ['cdec_visual_basic is required.']
    if cdec_visual_basic is not None:

        request_parameters['cdec'] = cdec_visual_basic

    if char_visual_basic is None or isinstance(char_visual_basic, list) and all(x is None for x in char_visual_basic):
        logger.error('char_visual_basic is required.')
        return ['char_visual_basic is required.']
    if char_visual_basic is not None:

        request_parameters['char'] = char_visual_basic

    if cint_visual_basic is None or isinstance(cint_visual_basic, list) and all(x is None for x in cint_visual_basic):
        logger.error('cint_visual_basic is required.')
        return ['cint_visual_basic is required.']
    if cint_visual_basic is not None:

        request_parameters['cint'] = cint_visual_basic

    if class_visual_basic is None or isinstance(class_visual_basic, list) and all(x is None for x in class_visual_basic):
        logger.error('class_visual_basic is required.')
        return ['class_visual_basic is required.']
    if class_visual_basic is not None:

        request_parameters['class'] = class_visual_basic

    if clng_visual_basic is None or isinstance(clng_visual_basic, list) and all(x is None for x in clng_visual_basic):
        logger.error('clng_visual_basic is required.')
        return ['clng_visual_basic is required.']
    if clng_visual_basic is not None:

        request_parameters['clng'] = clng_visual_basic

    if cobj_visual_basic is None or isinstance(cobj_visual_basic, list) and all(x is None for x in cobj_visual_basic):
        logger.error('cobj_visual_basic is required.')
        return ['cobj_visual_basic is required.']
    if cobj_visual_basic is not None:

        request_parameters['cobj'] = cobj_visual_basic

    if const_visual_basic is None or isinstance(const_visual_basic, list) and all(x is None for x in const_visual_basic):
        logger.error('const_visual_basic is required.')
        return ['const_visual_basic is required.']
    if const_visual_basic is not None:

        request_parameters['const'] = const_visual_basic

    if continue_visual_basic is None or isinstance(continue_visual_basic, list) and all(x is None for x in continue_visual_basic):
        logger.error('continue_visual_basic is required.')
        return ['continue_visual_basic is required.']
    if continue_visual_basic is not None:

        request_parameters['continue'] = continue_visual_basic

    if csbyte_visual_basic is None or isinstance(csbyte_visual_basic, list) and all(x is None for x in csbyte_visual_basic):
        logger.error('csbyte_visual_basic is required.')
        return ['csbyte_visual_basic is required.']
    if csbyte_visual_basic is not None:

        request_parameters['csbyte'] = csbyte_visual_basic

    if cshort_visual_basic is None or isinstance(cshort_visual_basic, list) and all(x is None for x in cshort_visual_basic):
        logger.error('cshort_visual_basic is required.')
        return ['cshort_visual_basic is required.']
    if cshort_visual_basic is not None:

        request_parameters['cshort'] = cshort_visual_basic

    if csng_visual_basic is None or isinstance(csng_visual_basic, list) and all(x is None for x in csng_visual_basic):
        logger.error('csng_visual_basic is required.')
        return ['csng_visual_basic is required.']
    if csng_visual_basic is not None:

        request_parameters['csng'] = csng_visual_basic

    if cstr_visual_basic is None or isinstance(cstr_visual_basic, list) and all(x is None for x in cstr_visual_basic):
        logger.error('cstr_visual_basic is required.')
        return ['cstr_visual_basic is required.']
    if cstr_visual_basic is not None:

        request_parameters['cstr'] = cstr_visual_basic

    if ctype_visual_basic is None or isinstance(ctype_visual_basic, list) and all(x is None for x in ctype_visual_basic):
        logger.error('ctype_visual_basic is required.')
        return ['ctype_visual_basic is required.']
    if ctype_visual_basic is not None:

        request_parameters['ctype'] = ctype_visual_basic

    if cuint_visual_basic is None or isinstance(cuint_visual_basic, list) and all(x is None for x in cuint_visual_basic):
        logger.error('cuint_visual_basic is required.')
        return ['cuint_visual_basic is required.']
    if cuint_visual_basic is not None:

        request_parameters['cuint'] = cuint_visual_basic

    if culng_visual_basic is None or isinstance(culng_visual_basic, list) and all(x is None for x in culng_visual_basic):
        logger.error('culng_visual_basic is required.')
        return ['culng_visual_basic is required.']
    if culng_visual_basic is not None:

        request_parameters['culng'] = culng_visual_basic

    if currency_visual_basic is None or isinstance(currency_visual_basic, list) and all(x is None for x in currency_visual_basic):
        logger.error('currency_visual_basic is required.')
        return ['currency_visual_basic is required.']
    if currency_visual_basic is not None:

        request_parameters['currency'] = currency_visual_basic

    if cushort_visual_basic is None or isinstance(cushort_visual_basic, list) and all(x is None for x in cushort_visual_basic):
        logger.error('cushort_visual_basic is required.')
        return ['cushort_visual_basic is required.']
    if cushort_visual_basic is not None:

        request_parameters['cushort'] = cushort_visual_basic

    if date_visual_basic is None or isinstance(date_visual_basic, list) and all(x is None for x in date_visual_basic):
        logger.error('date_visual_basic is required.')
        return ['date_visual_basic is required.']
    if date_visual_basic is not None:

        request_parameters['date'] = date_visual_basic

    if decimal_visual_basic is None or isinstance(decimal_visual_basic, list) and all(x is None for x in decimal_visual_basic):
        logger.error('decimal_visual_basic is required.')
        return ['decimal_visual_basic is required.']
    if decimal_visual_basic is not None:

        request_parameters['decimal'] = decimal_visual_basic

    if declare_visual_basic is None or isinstance(declare_visual_basic, list) and all(x is None for x in declare_visual_basic):
        logger.error('declare_visual_basic is required.')
        return ['declare_visual_basic is required.']
    if declare_visual_basic is not None:

        request_parameters['declare'] = declare_visual_basic

    if default_visual_basic is None or isinstance(default_visual_basic, list) and all(x is None for x in default_visual_basic):
        logger.error('default_visual_basic is required.')
        return ['default_visual_basic is required.']
    if default_visual_basic is not None:

        request_parameters['default'] = default_visual_basic

    if delegate_visual_basic is None or isinstance(delegate_visual_basic, list) and all(x is None for x in delegate_visual_basic):
        logger.error('delegate_visual_basic is required.')
        return ['delegate_visual_basic is required.']
    if delegate_visual_basic is not None:

        request_parameters['delegate'] = delegate_visual_basic

    if dim_visual_basic is None or isinstance(dim_visual_basic, list) and all(x is None for x in dim_visual_basic):
        logger.error('dim_visual_basic is required.')
        return ['dim_visual_basic is required.']
    if dim_visual_basic is not None:

        request_parameters['dim'] = dim_visual_basic

    if directcast_visual_basic is None or isinstance(directcast_visual_basic, list) and all(x is None for x in directcast_visual_basic):
        logger.error('directcast_visual_basic is required.')
        return ['directcast_visual_basic is required.']
    if directcast_visual_basic is not None:

        request_parameters['directcast'] = directcast_visual_basic

    if do_visual_basic is None or isinstance(do_visual_basic, list) and all(x is None for x in do_visual_basic):
        logger.error('do_visual_basic is required.')
        return ['do_visual_basic is required.']
    if do_visual_basic is not None:

        request_parameters['do'] = do_visual_basic

    if double_visual_basic is None or isinstance(double_visual_basic, list) and all(x is None for x in double_visual_basic):
        logger.error('double_visual_basic is required.')
        return ['double_visual_basic is required.']
    if double_visual_basic is not None:

        request_parameters['double'] = double_visual_basic

    if each_visual_basic is None or isinstance(each_visual_basic, list) and all(x is None for x in each_visual_basic):
        logger.error('each_visual_basic is required.')
        return ['each_visual_basic is required.']
    if each_visual_basic is not None:

        request_parameters['each'] = each_visual_basic

    if else_visual_basic is None or isinstance(else_visual_basic, list) and all(x is None for x in else_visual_basic):
        logger.error('else_visual_basic is required.')
        return ['else_visual_basic is required.']
    if else_visual_basic is not None:

        request_parameters['else'] = else_visual_basic

    if elseif_visual_basic is None or isinstance(elseif_visual_basic, list) and all(x is None for x in elseif_visual_basic):
        logger.error('elseif_visual_basic is required.')
        return ['elseif_visual_basic is required.']
    if elseif_visual_basic is not None:

        request_parameters['elseif'] = elseif_visual_basic

    if end_visual_basic is None or isinstance(end_visual_basic, list) and all(x is None for x in end_visual_basic):
        logger.error('end_visual_basic is required.')
        return ['end_visual_basic is required.']
    if end_visual_basic is not None:

        request_parameters['end'] = end_visual_basic

    if endif_visual_basic is None or isinstance(endif_visual_basic, list) and all(x is None for x in endif_visual_basic):
        logger.error('endif_visual_basic is required.')
        return ['endif_visual_basic is required.']
    if endif_visual_basic is not None:

        request_parameters['endif'] = endif_visual_basic

    if enum_visual_basic is None or isinstance(enum_visual_basic, list) and all(x is None for x in enum_visual_basic):
        logger.error('enum_visual_basic is required.')
        return ['enum_visual_basic is required.']
    if enum_visual_basic is not None:

        request_parameters['enum'] = enum_visual_basic

    if erase_visual_basic is None or isinstance(erase_visual_basic, list) and all(x is None for x in erase_visual_basic):
        logger.error('erase_visual_basic is required.')
        return ['erase_visual_basic is required.']
    if erase_visual_basic is not None:

        request_parameters['erase'] = erase_visual_basic

    if error_visual_basic is None or isinstance(error_visual_basic, list) and all(x is None for x in error_visual_basic):
        logger.error('error_visual_basic is required.')
        return ['error_visual_basic is required.']
    if error_visual_basic is not None:

        request_parameters['error'] = error_visual_basic

    if event_visual_basic is None or isinstance(event_visual_basic, list) and all(x is None for x in event_visual_basic):
        logger.error('event_visual_basic is required.')
        return ['event_visual_basic is required.']
    if event_visual_basic is not None:

        request_parameters['event'] = event_visual_basic

    if exit_visual_basic is None or isinstance(exit_visual_basic, list) and all(x is None for x in exit_visual_basic):
        logger.error('exit_visual_basic is required.')
        return ['exit_visual_basic is required.']
    if exit_visual_basic is not None:

        request_parameters['exit'] = exit_visual_basic

    if finally_visual_basic is None or isinstance(finally_visual_basic, list) and all(x is None for x in finally_visual_basic):
        logger.error('finally_visual_basic is required.')
        return ['finally_visual_basic is required.']
    if finally_visual_basic is not None:

        request_parameters['finally'] = finally_visual_basic

    if for_visual_basic is None or isinstance(for_visual_basic, list) and all(x is None for x in for_visual_basic):
        logger.error('for_visual_basic is required.')
        return ['for_visual_basic is required.']
    if for_visual_basic is not None:

        request_parameters['for'] = for_visual_basic

    if friend_visual_basic is None or isinstance(friend_visual_basic, list) and all(x is None for x in friend_visual_basic):
        logger.error('friend_visual_basic is required.')
        return ['friend_visual_basic is required.']
    if friend_visual_basic is not None:

        request_parameters['friend'] = friend_visual_basic

    if function_visual_basic is None or isinstance(function_visual_basic, list) and all(x is None for x in function_visual_basic):
        logger.error('function_visual_basic is required.')
        return ['function_visual_basic is required.']
    if function_visual_basic is not None:

        request_parameters['function'] = function_visual_basic

    if get_visual_basic is None or isinstance(get_visual_basic, list) and all(x is None for x in get_visual_basic):
        logger.error('get_visual_basic is required.')
        return ['get_visual_basic is required.']
    if get_visual_basic is not None:

        request_parameters['get'] = get_visual_basic

    if gettype_visual_basic is None or isinstance(gettype_visual_basic, list) and all(x is None for x in gettype_visual_basic):
        logger.error('gettype_visual_basic is required.')
        return ['gettype_visual_basic is required.']
    if gettype_visual_basic is not None:

        request_parameters['gettype'] = gettype_visual_basic

    if getxmlnamespace_visual_basic is None or isinstance(getxmlnamespace_visual_basic, list) and all(x is None for x in getxmlnamespace_visual_basic):
        logger.error('getxmlnamespace_visual_basic is required.')
        return ['getxmlnamespace_visual_basic is required.']
    if getxmlnamespace_visual_basic is not None:

        request_parameters['getxmlnamespace'] = getxmlnamespace_visual_basic

    if global_visual_basic is None or isinstance(global_visual_basic, list) and all(x is None for x in global_visual_basic):
        logger.error('global_visual_basic is required.')
        return ['global_visual_basic is required.']
    if global_visual_basic is not None:

        request_parameters['global'] = global_visual_basic

    if gosub_visual_basic is None or isinstance(gosub_visual_basic, list) and all(x is None for x in gosub_visual_basic):
        logger.error('gosub_visual_basic is required.')
        return ['gosub_visual_basic is required.']
    if gosub_visual_basic is not None:

        request_parameters['gosub'] = gosub_visual_basic

    if goto_visual_basic is None or isinstance(goto_visual_basic, list) and all(x is None for x in goto_visual_basic):
        logger.error('goto_visual_basic is required.')
        return ['goto_visual_basic is required.']
    if goto_visual_basic is not None:

        request_parameters['goto'] = goto_visual_basic

    if handles_visual_basic is None or isinstance(handles_visual_basic, list) and all(x is None for x in handles_visual_basic):
        logger.error('handles_visual_basic is required.')
        return ['handles_visual_basic is required.']
    if handles_visual_basic is not None:

        request_parameters['handles'] = handles_visual_basic

    if if_visual_basic is None or isinstance(if_visual_basic, list) and all(x is None for x in if_visual_basic):
        logger.error('if_visual_basic is required.')
        return ['if_visual_basic is required.']
    if if_visual_basic is not None:

        request_parameters['if'] = if_visual_basic

    if implements_visual_basic is None or isinstance(implements_visual_basic, list) and all(x is None for x in implements_visual_basic):
        logger.error('implements_visual_basic is required.')
        return ['implements_visual_basic is required.']
    if implements_visual_basic is not None:

        request_parameters['implements'] = implements_visual_basic

    if imports_visual_basic is None or isinstance(imports_visual_basic, list) and all(x is None for x in imports_visual_basic):
        logger.error('imports_visual_basic is required.')
        return ['imports_visual_basic is required.']
    if imports_visual_basic is not None:

        request_parameters['imports'] = imports_visual_basic

    if in_visual_basic is None or isinstance(in_visual_basic, list) and all(x is None for x in in_visual_basic):
        logger.error('in_visual_basic is required.')
        return ['in_visual_basic is required.']
    if in_visual_basic is not None:

        request_parameters['in'] = in_visual_basic

    if inherits_visual_basic is None or isinstance(inherits_visual_basic, list) and all(x is None for x in inherits_visual_basic):
        logger.error('inherits_visual_basic is required.')
        return ['inherits_visual_basic is required.']
    if inherits_visual_basic is not None:

        request_parameters['inherits'] = inherits_visual_basic

    if integer_visual_basic is None or isinstance(integer_visual_basic, list) and all(x is None for x in integer_visual_basic):
        logger.error('integer_visual_basic is required.')
        return ['integer_visual_basic is required.']
    if integer_visual_basic is not None:

        request_parameters['integer'] = integer_visual_basic

    if interface_visual_basic is None or isinstance(interface_visual_basic, list) and all(x is None for x in interface_visual_basic):
        logger.error('interface_visual_basic is required.')
        return ['interface_visual_basic is required.']
    if interface_visual_basic is not None:

        request_parameters['interface'] = interface_visual_basic

    if is_visual_basic is None or isinstance(is_visual_basic, list) and all(x is None for x in is_visual_basic):
        logger.error('is_visual_basic is required.')
        return ['is_visual_basic is required.']
    if is_visual_basic is not None:

        request_parameters['is'] = is_visual_basic

    if isnot_visual_basic is None or isinstance(isnot_visual_basic, list) and all(x is None for x in isnot_visual_basic):
        logger.error('isnot_visual_basic is required.')
        return ['isnot_visual_basic is required.']
    if isnot_visual_basic is not None:

        request_parameters['isnot'] = isnot_visual_basic

    if let_visual_basic is None or isinstance(let_visual_basic, list) and all(x is None for x in let_visual_basic):
        logger.error('let_visual_basic is required.')
        return ['let_visual_basic is required.']
    if let_visual_basic is not None:

        request_parameters['let'] = let_visual_basic

    if lib_visual_basic is None or isinstance(lib_visual_basic, list) and all(x is None for x in lib_visual_basic):
        logger.error('lib_visual_basic is required.')
        return ['lib_visual_basic is required.']
    if lib_visual_basic is not None:

        request_parameters['lib'] = lib_visual_basic

    if like_visual_basic is None or isinstance(like_visual_basic, list) and all(x is None for x in like_visual_basic):
        logger.error('like_visual_basic is required.')
        return ['like_visual_basic is required.']
    if like_visual_basic is not None:

        request_parameters['like'] = like_visual_basic

    if long_visual_basic is None or isinstance(long_visual_basic, list) and all(x is None for x in long_visual_basic):
        logger.error('long_visual_basic is required.')
        return ['long_visual_basic is required.']
    if long_visual_basic is not None:

        request_parameters['long'] = long_visual_basic

    if loop_visual_basic is None or isinstance(loop_visual_basic, list) and all(x is None for x in loop_visual_basic):
        logger.error('loop_visual_basic is required.')
        return ['loop_visual_basic is required.']
    if loop_visual_basic is not None:

        request_parameters['loop'] = loop_visual_basic

    if me_visual_basic is None or isinstance(me_visual_basic, list) and all(x is None for x in me_visual_basic):
        logger.error('me_visual_basic is required.')
        return ['me_visual_basic is required.']
    if me_visual_basic is not None:

        request_parameters['me'] = me_visual_basic

    if mod_visual_basic is None or isinstance(mod_visual_basic, list) and all(x is None for x in mod_visual_basic):
        logger.error('mod_visual_basic is required.')
        return ['mod_visual_basic is required.']
    if mod_visual_basic is not None:

        request_parameters['mod'] = mod_visual_basic

    if module_visual_basic is None or isinstance(module_visual_basic, list) and all(x is None for x in module_visual_basic):
        logger.error('module_visual_basic is required.')
        return ['module_visual_basic is required.']
    if module_visual_basic is not None:

        request_parameters['module'] = module_visual_basic

    if mustinherit_visual_basic is None or isinstance(mustinherit_visual_basic, list) and all(x is None for x in mustinherit_visual_basic):
        logger.error('mustinherit_visual_basic is required.')
        return ['mustinherit_visual_basic is required.']
    if mustinherit_visual_basic is not None:

        request_parameters['mustinherit'] = mustinherit_visual_basic

    if mustoverride_visual_basic is None or isinstance(mustoverride_visual_basic, list) and all(x is None for x in mustoverride_visual_basic):
        logger.error('mustoverride_visual_basic is required.')
        return ['mustoverride_visual_basic is required.']
    if mustoverride_visual_basic is not None:

        request_parameters['mustoverride'] = mustoverride_visual_basic

    if mybase_visual_basic is None or isinstance(mybase_visual_basic, list) and all(x is None for x in mybase_visual_basic):
        logger.error('mybase_visual_basic is required.')
        return ['mybase_visual_basic is required.']
    if mybase_visual_basic is not None:

        request_parameters['mybase'] = mybase_visual_basic

    if myclass_visual_basic is None or isinstance(myclass_visual_basic, list) and all(x is None for x in myclass_visual_basic):
        logger.error('myclass_visual_basic is required.')
        return ['myclass_visual_basic is required.']
    if myclass_visual_basic is not None:

        request_parameters['myclass'] = myclass_visual_basic

    if namespace_visual_basic is None or isinstance(namespace_visual_basic, list) and all(x is None for x in namespace_visual_basic):
        logger.error('namespace_visual_basic is required.')
        return ['namespace_visual_basic is required.']
    if namespace_visual_basic is not None:

        request_parameters['namespace'] = namespace_visual_basic

    if narrowing_visual_basic is None or isinstance(narrowing_visual_basic, list) and all(x is None for x in narrowing_visual_basic):
        logger.error('narrowing_visual_basic is required.')
        return ['narrowing_visual_basic is required.']
    if narrowing_visual_basic is not None:

        request_parameters['narrowing'] = narrowing_visual_basic

    if new_visual_basic is None or isinstance(new_visual_basic, list) and all(x is None for x in new_visual_basic):
        logger.error('new_visual_basic is required.')
        return ['new_visual_basic is required.']
    if new_visual_basic is not None:

        request_parameters['new'] = new_visual_basic

    if next_visual_basic is None or isinstance(next_visual_basic, list) and all(x is None for x in next_visual_basic):
        logger.error('next_visual_basic is required.')
        return ['next_visual_basic is required.']
    if next_visual_basic is not None:

        request_parameters['next'] = next_visual_basic

    if not_visual_basic is None or isinstance(not_visual_basic, list) and all(x is None for x in not_visual_basic):
        logger.error('not_visual_basic is required.')
        return ['not_visual_basic is required.']
    if not_visual_basic is not None:

        request_parameters['not'] = not_visual_basic

    if nothing_visual_basic is None or isinstance(nothing_visual_basic, list) and all(x is None for x in nothing_visual_basic):
        logger.error('nothing_visual_basic is required.')
        return ['nothing_visual_basic is required.']
    if nothing_visual_basic is not None:

        request_parameters['nothing'] = nothing_visual_basic

    if notinheritable_visual_basic is None or isinstance(notinheritable_visual_basic, list) and all(x is None for x in notinheritable_visual_basic):
        logger.error('notinheritable_visual_basic is required.')
        return ['notinheritable_visual_basic is required.']
    if notinheritable_visual_basic is not None:

        request_parameters['notinheritable'] = notinheritable_visual_basic

    if notoverridable_visual_basic is None or isinstance(notoverridable_visual_basic, list) and all(x is None for x in notoverridable_visual_basic):
        logger.error('notoverridable_visual_basic is required.')
        return ['notoverridable_visual_basic is required.']
    if notoverridable_visual_basic is not None:

        request_parameters['notoverridable'] = notoverridable_visual_basic

    if object_visual_basic is None or isinstance(object_visual_basic, list) and all(x is None for x in object_visual_basic):
        logger.error('object_visual_basic is required.')
        return ['object_visual_basic is required.']
    if object_visual_basic is not None:

        request_parameters['object'] = object_visual_basic

    if of_visual_basic is None or isinstance(of_visual_basic, list) and all(x is None for x in of_visual_basic):
        logger.error('of_visual_basic is required.')
        return ['of_visual_basic is required.']
    if of_visual_basic is not None:

        request_parameters['of'] = of_visual_basic

    if on_visual_basic is None or isinstance(on_visual_basic, list) and all(x is None for x in on_visual_basic):
        logger.error('on_visual_basic is required.')
        return ['on_visual_basic is required.']
    if on_visual_basic is not None:

        request_parameters['on'] = on_visual_basic

    if operator_visual_basic is None or isinstance(operator_visual_basic, list) and all(x is None for x in operator_visual_basic):
        logger.error('operator_visual_basic is required.')
        return ['operator_visual_basic is required.']
    if operator_visual_basic is not None:

        request_parameters['operator'] = operator_visual_basic

    if option_visual_basic is None or isinstance(option_visual_basic, list) and all(x is None for x in option_visual_basic):
        logger.error('option_visual_basic is required.')
        return ['option_visual_basic is required.']
    if option_visual_basic is not None:

        request_parameters['option'] = option_visual_basic

    if optional_visual_basic is None or isinstance(optional_visual_basic, list) and all(x is None for x in optional_visual_basic):
        logger.error('optional_visual_basic is required.')
        return ['optional_visual_basic is required.']
    if optional_visual_basic is not None:

        request_parameters['optional'] = optional_visual_basic

    if or_visual_basic is None or isinstance(or_visual_basic, list) and all(x is None for x in or_visual_basic):
        logger.error('or_visual_basic is required.')
        return ['or_visual_basic is required.']
    if or_visual_basic is not None:

        request_parameters['or'] = or_visual_basic

    if orelse_visual_basic is None or isinstance(orelse_visual_basic, list) and all(x is None for x in orelse_visual_basic):
        logger.error('orelse_visual_basic is required.')
        return ['orelse_visual_basic is required.']
    if orelse_visual_basic is not None:

        request_parameters['orelse'] = orelse_visual_basic

    if overloads_visual_basic is None or isinstance(overloads_visual_basic, list) and all(x is None for x in overloads_visual_basic):
        logger.error('overloads_visual_basic is required.')
        return ['overloads_visual_basic is required.']
    if overloads_visual_basic is not None:

        request_parameters['overloads'] = overloads_visual_basic

    if overridable_visual_basic is None or isinstance(overridable_visual_basic, list) and all(x is None for x in overridable_visual_basic):
        logger.error('overridable_visual_basic is required.')
        return ['overridable_visual_basic is required.']
    if overridable_visual_basic is not None:

        request_parameters['overridable'] = overridable_visual_basic

    if overrides_visual_basic is None or isinstance(overrides_visual_basic, list) and all(x is None for x in overrides_visual_basic):
        logger.error('overrides_visual_basic is required.')
        return ['overrides_visual_basic is required.']
    if overrides_visual_basic is not None:

        request_parameters['overrides'] = overrides_visual_basic

    if paramarray_visual_basic is None or isinstance(paramarray_visual_basic, list) and all(x is None for x in paramarray_visual_basic):
        logger.error('paramarray_visual_basic is required.')
        return ['paramarray_visual_basic is required.']
    if paramarray_visual_basic is not None:

        request_parameters['paramarray'] = paramarray_visual_basic

    if partial_visual_basic is None or isinstance(partial_visual_basic, list) and all(x is None for x in partial_visual_basic):
        logger.error('partial_visual_basic is required.')
        return ['partial_visual_basic is required.']
    if partial_visual_basic is not None:

        request_parameters['partial'] = partial_visual_basic

    if private_visual_basic is None or isinstance(private_visual_basic, list) and all(x is None for x in private_visual_basic):
        logger.error('private_visual_basic is required.')
        return ['private_visual_basic is required.']
    if private_visual_basic is not None:

        request_parameters['private'] = private_visual_basic

    if property_visual_basic is None or isinstance(property_visual_basic, list) and all(x is None for x in property_visual_basic):
        logger.error('property_visual_basic is required.')
        return ['property_visual_basic is required.']
    if property_visual_basic is not None:

        request_parameters['property'] = property_visual_basic

    if protected_visual_basic is None or isinstance(protected_visual_basic, list) and all(x is None for x in protected_visual_basic):
        logger.error('protected_visual_basic is required.')
        return ['protected_visual_basic is required.']
    if protected_visual_basic is not None:

        request_parameters['protected'] = protected_visual_basic

    if public_visual_basic is None or isinstance(public_visual_basic, list) and all(x is None for x in public_visual_basic):
        logger.error('public_visual_basic is required.')
        return ['public_visual_basic is required.']
    if public_visual_basic is not None:

        request_parameters['public'] = public_visual_basic

    if raiseevent_visual_basic is None or isinstance(raiseevent_visual_basic, list) and all(x is None for x in raiseevent_visual_basic):
        logger.error('raiseevent_visual_basic is required.')
        return ['raiseevent_visual_basic is required.']
    if raiseevent_visual_basic is not None:

        request_parameters['raiseevent'] = raiseevent_visual_basic

    if readonly_visual_basic is None or isinstance(readonly_visual_basic, list) and all(x is None for x in readonly_visual_basic):
        logger.error('readonly_visual_basic is required.')
        return ['readonly_visual_basic is required.']
    if readonly_visual_basic is not None:

        request_parameters['readonly'] = readonly_visual_basic

    if redim_visual_basic is None or isinstance(redim_visual_basic, list) and all(x is None for x in redim_visual_basic):
        logger.error('redim_visual_basic is required.')
        return ['redim_visual_basic is required.']
    if redim_visual_basic is not None:

        request_parameters['redim'] = redim_visual_basic

    if rem_visual_basic is None or isinstance(rem_visual_basic, list) and all(x is None for x in rem_visual_basic):
        logger.error('rem_visual_basic is required.')
        return ['rem_visual_basic is required.']
    if rem_visual_basic is not None:

        request_parameters['rem'] = rem_visual_basic

    if removehandler_visual_basic is None or isinstance(removehandler_visual_basic, list) and all(x is None for x in removehandler_visual_basic):
        logger.error('removehandler_visual_basic is required.')
        return ['removehandler_visual_basic is required.']
    if removehandler_visual_basic is not None:

        request_parameters['removehandler'] = removehandler_visual_basic

    if resume_visual_basic is None or isinstance(resume_visual_basic, list) and all(x is None for x in resume_visual_basic):
        logger.error('resume_visual_basic is required.')
        return ['resume_visual_basic is required.']
    if resume_visual_basic is not None:

        request_parameters['resume'] = resume_visual_basic

    if return_visual_basic is None or isinstance(return_visual_basic, list) and all(x is None for x in return_visual_basic):
        logger.error('return_visual_basic is required.')
        return ['return_visual_basic is required.']
    if return_visual_basic is not None:

        request_parameters['return'] = return_visual_basic

    if sbyte_visual_basic is None or isinstance(sbyte_visual_basic, list) and all(x is None for x in sbyte_visual_basic):
        logger.error('sbyte_visual_basic is required.')
        return ['sbyte_visual_basic is required.']
    if sbyte_visual_basic is not None:

        request_parameters['sbyte'] = sbyte_visual_basic

    if select_visual_basic is None or isinstance(select_visual_basic, list) and all(x is None for x in select_visual_basic):
        logger.error('select_visual_basic is required.')
        return ['select_visual_basic is required.']
    if select_visual_basic is not None:

        request_parameters['select'] = select_visual_basic

    if set_visual_basic is None or isinstance(set_visual_basic, list) and all(x is None for x in set_visual_basic):
        logger.error('set_visual_basic is required.')
        return ['set_visual_basic is required.']
    if set_visual_basic is not None:

        request_parameters['set'] = set_visual_basic

    if shadows_visual_basic is None or isinstance(shadows_visual_basic, list) and all(x is None for x in shadows_visual_basic):
        logger.error('shadows_visual_basic is required.')
        return ['shadows_visual_basic is required.']
    if shadows_visual_basic is not None:

        request_parameters['shadows'] = shadows_visual_basic

    if shared_visual_basic is None or isinstance(shared_visual_basic, list) and all(x is None for x in shared_visual_basic):
        logger.error('shared_visual_basic is required.')
        return ['shared_visual_basic is required.']
    if shared_visual_basic is not None:

        request_parameters['shared'] = shared_visual_basic

    if short_visual_basic is None or isinstance(short_visual_basic, list) and all(x is None for x in short_visual_basic):
        logger.error('short_visual_basic is required.')
        return ['short_visual_basic is required.']
    if short_visual_basic is not None:

        request_parameters['short'] = short_visual_basic

    if single_visual_basic is None or isinstance(single_visual_basic, list) and all(x is None for x in single_visual_basic):
        logger.error('single_visual_basic is required.')
        return ['single_visual_basic is required.']
    if single_visual_basic is not None:

        request_parameters['single'] = single_visual_basic

    if static_visual_basic is None or isinstance(static_visual_basic, list) and all(x is None for x in static_visual_basic):
        logger.error('static_visual_basic is required.')
        return ['static_visual_basic is required.']
    if static_visual_basic is not None:

        request_parameters['static'] = static_visual_basic

    if step_visual_basic is None or isinstance(step_visual_basic, list) and all(x is None for x in step_visual_basic):
        logger.error('step_visual_basic is required.')
        return ['step_visual_basic is required.']
    if step_visual_basic is not None:

        request_parameters['step'] = step_visual_basic

    if stop_visual_basic is None or isinstance(stop_visual_basic, list) and all(x is None for x in stop_visual_basic):
        logger.error('stop_visual_basic is required.')
        return ['stop_visual_basic is required.']
    if stop_visual_basic is not None:

        request_parameters['stop'] = stop_visual_basic

    if string_visual_basic is None or isinstance(string_visual_basic, list) and all(x is None for x in string_visual_basic):
        logger.error('string_visual_basic is required.')
        return ['string_visual_basic is required.']
    if string_visual_basic is not None:

        request_parameters['string'] = string_visual_basic

    if structure_visual_basic is None or isinstance(structure_visual_basic, list) and all(x is None for x in structure_visual_basic):
        logger.error('structure_visual_basic is required.')
        return ['structure_visual_basic is required.']
    if structure_visual_basic is not None:

        request_parameters['structure'] = structure_visual_basic

    if sub_visual_basic is None or isinstance(sub_visual_basic, list) and all(x is None for x in sub_visual_basic):
        logger.error('sub_visual_basic is required.')
        return ['sub_visual_basic is required.']
    if sub_visual_basic is not None:

        request_parameters['sub'] = sub_visual_basic

    if synclock_visual_basic is None or isinstance(synclock_visual_basic, list) and all(x is None for x in synclock_visual_basic):
        logger.error('synclock_visual_basic is required.')
        return ['synclock_visual_basic is required.']
    if synclock_visual_basic is not None:

        request_parameters['synclock'] = synclock_visual_basic

    if then_visual_basic is None or isinstance(then_visual_basic, list) and all(x is None for x in then_visual_basic):
        logger.error('then_visual_basic is required.')
        return ['then_visual_basic is required.']
    if then_visual_basic is not None:

        request_parameters['then'] = then_visual_basic

    if throw_visual_basic is None or isinstance(throw_visual_basic, list) and all(x is None for x in throw_visual_basic):
        logger.error('throw_visual_basic is required.')
        return ['throw_visual_basic is required.']
    if throw_visual_basic is not None:

        request_parameters['throw'] = throw_visual_basic

    if to_visual_basic is None or isinstance(to_visual_basic, list) and all(x is None for x in to_visual_basic):
        logger.error('to_visual_basic is required.')
        return ['to_visual_basic is required.']
    if to_visual_basic is not None:

        request_parameters['to'] = to_visual_basic

    if try_visual_basic is None or isinstance(try_visual_basic, list) and all(x is None for x in try_visual_basic):
        logger.error('try_visual_basic is required.')
        return ['try_visual_basic is required.']
    if try_visual_basic is not None:

        request_parameters['try'] = try_visual_basic

    if trycast_visual_basic is None or isinstance(trycast_visual_basic, list) and all(x is None for x in trycast_visual_basic):
        logger.error('trycast_visual_basic is required.')
        return ['trycast_visual_basic is required.']
    if trycast_visual_basic is not None:

        request_parameters['trycast'] = trycast_visual_basic

    if type_visual_basic is None or isinstance(type_visual_basic, list) and all(x is None for x in type_visual_basic):
        logger.error('type_visual_basic is required.')
        return ['type_visual_basic is required.']
    if type_visual_basic is not None:

        request_parameters['type'] = type_visual_basic

    if typeof_visual_basic is None or isinstance(typeof_visual_basic, list) and all(x is None for x in typeof_visual_basic):
        logger.error('typeof_visual_basic is required.')
        return ['typeof_visual_basic is required.']
    if typeof_visual_basic is not None:

        request_parameters['typeof'] = typeof_visual_basic

    if uinteger_visual_basic is None or isinstance(uinteger_visual_basic, list) and all(x is None for x in uinteger_visual_basic):
        logger.error('uinteger_visual_basic is required.')
        return ['uinteger_visual_basic is required.']
    if uinteger_visual_basic is not None:

        request_parameters['uinteger'] = uinteger_visual_basic

    if ulong_visual_basic is None or isinstance(ulong_visual_basic, list) and all(x is None for x in ulong_visual_basic):
        logger.error('ulong_visual_basic is required.')
        return ['ulong_visual_basic is required.']
    if ulong_visual_basic is not None:

        request_parameters['ulong'] = ulong_visual_basic

    if ushort_visual_basic is None or isinstance(ushort_visual_basic, list) and all(x is None for x in ushort_visual_basic):
        logger.error('ushort_visual_basic is required.')
        return ['ushort_visual_basic is required.']
    if ushort_visual_basic is not None:

        request_parameters['ushort'] = ushort_visual_basic

    if using_visual_basic is None or isinstance(using_visual_basic, list) and all(x is None for x in using_visual_basic):
        logger.error('using_visual_basic is required.')
        return ['using_visual_basic is required.']
    if using_visual_basic is not None:

        request_parameters['using'] = using_visual_basic

    if variant_visual_basic is None or isinstance(variant_visual_basic, list) and all(x is None for x in variant_visual_basic):
        logger.error('variant_visual_basic is required.')
        return ['variant_visual_basic is required.']
    if variant_visual_basic is not None:

        request_parameters['variant'] = variant_visual_basic

    if wend_visual_basic is None or isinstance(wend_visual_basic, list) and all(x is None for x in wend_visual_basic):
        logger.error('wend_visual_basic is required.')
        return ['wend_visual_basic is required.']
    if wend_visual_basic is not None:

        request_parameters['wend'] = wend_visual_basic

    if when_visual_basic is None or isinstance(when_visual_basic, list) and all(x is None for x in when_visual_basic):
        logger.error('when_visual_basic is required.')
        return ['when_visual_basic is required.']
    if when_visual_basic is not None:

        request_parameters['when'] = when_visual_basic

    if while_visual_basic is None or isinstance(while_visual_basic, list) and all(x is None for x in while_visual_basic):
        logger.error('while_visual_basic is required.')
        return ['while_visual_basic is required.']
    if while_visual_basic is not None:

        request_parameters['while'] = while_visual_basic

    if widening_visual_basic is None or isinstance(widening_visual_basic, list) and all(x is None for x in widening_visual_basic):
        logger.error('widening_visual_basic is required.')
        return ['widening_visual_basic is required.']
    if widening_visual_basic is not None:

        request_parameters['widening'] = widening_visual_basic

    if with_visual_basic is None or isinstance(with_visual_basic, list) and all(x is None for x in with_visual_basic):
        logger.error('with_visual_basic is required.')
        return ['with_visual_basic is required.']
    if with_visual_basic is not None:

        request_parameters['with'] = with_visual_basic

    if withevents_visual_basic is None or isinstance(withevents_visual_basic, list) and all(x is None for x in withevents_visual_basic):
        logger.error('withevents_visual_basic is required.')
        return ['withevents_visual_basic is required.']
    if withevents_visual_basic is not None:

        request_parameters['withevents'] = withevents_visual_basic

    if writeonly_visual_basic is None or isinstance(writeonly_visual_basic, list) and all(x is None for x in writeonly_visual_basic):
        logger.error('writeonly_visual_basic is required.')
        return ['writeonly_visual_basic is required.']
    if writeonly_visual_basic is not None:

        request_parameters['writeonly'] = writeonly_visual_basic

    if xor_visual_basic is None or isinstance(xor_visual_basic, list) and all(x is None for x in xor_visual_basic):
        logger.error('xor_visual_basic is required.')
        return ['xor_visual_basic is required.']
    if xor_visual_basic is not None:

        request_parameters['xor'] = xor_visual_basic


    response = None
    try:
        response = session.get(5).request('delete', 'http://localhost:8949/test/vba/restricted/keywords'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=vba_keywords_test_delete_test_vba_restricted_keywords] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'$ref', u'#/definitions/VBAKeywords'), (u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('vba_keywords_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=vba_keywords_test_delete_test_vba_restricted_keywords] [url=http://localhost:8949/test/vba/restricted/keywords].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=vba_keywords_test_delete_test_vba_restricted_keywords] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=vba_keywords_test_delete_test_vba_restricted_keywords] [url=http://localhost:8949/test/vba/restricted/keywords].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='vba_keywords_test', call_in_wizard=False)
@xw.arg('addhandler_visual_basic', doc='')
@xw.arg('addressof_visual_basic', doc='')
@xw.arg('alias_visual_basic', doc='')
@xw.arg('and_visual_basic', doc='')
@xw.arg('andalso_visual_basic', doc='')
@xw.arg('as_visual_basic', doc='')
@xw.arg('boolean_visual_basic', doc='')
@xw.arg('byref_visual_basic', doc='')
@xw.arg('byte_visual_basic', doc='')
@xw.arg('byval_visual_basic', doc='')
@xw.arg('call_visual_basic', doc='')
@xw.arg('case_visual_basic', doc='')
@xw.arg('catch_visual_basic', doc='')
@xw.arg('cbool_visual_basic', doc='')
@xw.arg('cbyte_visual_basic', doc='')
@xw.arg('cchar_visual_basic', doc='')
@xw.arg('cdate_visual_basic', doc='')
@xw.arg('cdbl_visual_basic', doc='')
@xw.arg('cdec_visual_basic', doc='')
@xw.arg('char_visual_basic', doc='')
@xw.arg('cint_visual_basic', doc='')
@xw.arg('class_visual_basic', doc='')
@xw.arg('clng_visual_basic', doc='')
@xw.arg('cobj_visual_basic', doc='')
@xw.arg('const_visual_basic', doc='')
@xw.arg('continue_visual_basic', doc='')
@xw.arg('csbyte_visual_basic', doc='')
@xw.arg('cshort_visual_basic', doc='')
@xw.arg('csng_visual_basic', doc='')
@xw.arg('cstr_visual_basic', doc='')
@xw.arg('ctype_visual_basic', doc='')
@xw.arg('cuint_visual_basic', doc='')
@xw.arg('culng_visual_basic', doc='')
@xw.arg('currency_visual_basic', doc='')
@xw.arg('cushort_visual_basic', doc='')
@xw.arg('date_visual_basic', doc='')
@xw.arg('decimal_visual_basic', doc='')
@xw.arg('declare_visual_basic', doc='')
@xw.arg('default_visual_basic', doc='')
@xw.arg('delegate_visual_basic', doc='')
@xw.arg('dim_visual_basic', doc='')
@xw.arg('directcast_visual_basic', doc='')
@xw.arg('do_visual_basic', doc='')
@xw.arg('double_visual_basic', doc='')
@xw.arg('each_visual_basic', doc='')
@xw.arg('else_visual_basic', doc='')
@xw.arg('elseif_visual_basic', doc='')
@xw.arg('end_visual_basic', doc='')
@xw.arg('endif_visual_basic', doc='')
@xw.arg('enum_visual_basic', doc='')
@xw.arg('erase_visual_basic', doc='')
@xw.arg('error_visual_basic', doc='')
@xw.arg('event_visual_basic', doc='')
@xw.arg('exit_visual_basic', doc='')
@xw.arg('finally_visual_basic', doc='')
@xw.arg('for_visual_basic', doc='')
@xw.arg('friend_visual_basic', doc='')
@xw.arg('function_visual_basic', doc='')
@xw.arg('get_visual_basic', doc='')
@xw.arg('gettype_visual_basic', doc='')
@xw.arg('getxmlnamespace_visual_basic', doc='')
@xw.arg('global_visual_basic', doc='')
@xw.arg('gosub_visual_basic', doc='')
@xw.arg('goto_visual_basic', doc='')
@xw.arg('handles_visual_basic', doc='')
@xw.arg('if_visual_basic', doc='')
@xw.arg('implements_visual_basic', doc='')
@xw.arg('imports_visual_basic', doc='')
@xw.arg('in_visual_basic', doc='')
@xw.arg('inherits_visual_basic', doc='')
@xw.arg('integer_visual_basic', doc='')
@xw.arg('interface_visual_basic', doc='')
@xw.arg('is_visual_basic', doc='')
@xw.arg('isnot_visual_basic', doc='')
@xw.arg('let_visual_basic', doc='')
@xw.arg('lib_visual_basic', doc='')
@xw.arg('like_visual_basic', doc='')
@xw.arg('long_visual_basic', doc='')
@xw.arg('loop_visual_basic', doc='')
@xw.arg('me_visual_basic', doc='')
@xw.arg('mod_visual_basic', doc='')
@xw.arg('module_visual_basic', doc='')
@xw.arg('mustinherit_visual_basic', doc='')
@xw.arg('mustoverride_visual_basic', doc='')
@xw.arg('mybase_visual_basic', doc='')
@xw.arg('myclass_visual_basic', doc='')
@xw.arg('namespace_visual_basic', doc='')
@xw.arg('narrowing_visual_basic', doc='')
@xw.arg('new_visual_basic', doc='')
@xw.arg('next_visual_basic', doc='')
@xw.arg('not_visual_basic', doc='')
@xw.arg('nothing_visual_basic', doc='')
@xw.arg('notinheritable_visual_basic', doc='')
@xw.arg('notoverridable_visual_basic', doc='')
@xw.arg('object_visual_basic', doc='')
@xw.arg('of_visual_basic', doc='')
@xw.arg('on_visual_basic', doc='')
@xw.arg('operator_visual_basic', doc='')
@xw.arg('option_visual_basic', doc='')
@xw.arg('optional_visual_basic', doc='')
@xw.arg('or_visual_basic', doc='')
@xw.arg('orelse_visual_basic', doc='')
@xw.arg('overloads_visual_basic', doc='')
@xw.arg('overridable_visual_basic', doc='')
@xw.arg('overrides_visual_basic', doc='')
@xw.arg('paramarray_visual_basic', doc='')
@xw.arg('partial_visual_basic', doc='')
@xw.arg('private_visual_basic', doc='')
@xw.arg('property_visual_basic', doc='')
@xw.arg('protected_visual_basic', doc='')
@xw.arg('public_visual_basic', doc='')
@xw.arg('raiseevent_visual_basic', doc='')
@xw.arg('readonly_visual_basic', doc='')
@xw.arg('redim_visual_basic', doc='')
@xw.arg('rem_visual_basic', doc='')
@xw.arg('removehandler_visual_basic', doc='')
@xw.arg('resume_visual_basic', doc='')
@xw.arg('return_visual_basic', doc='')
@xw.arg('sbyte_visual_basic', doc='')
@xw.arg('select_visual_basic', doc='')
@xw.arg('set_visual_basic', doc='')
@xw.arg('shadows_visual_basic', doc='')
@xw.arg('shared_visual_basic', doc='')
@xw.arg('short_visual_basic', doc='')
@xw.arg('single_visual_basic', doc='')
@xw.arg('static_visual_basic', doc='')
@xw.arg('step_visual_basic', doc='')
@xw.arg('stop_visual_basic', doc='')
@xw.arg('string_visual_basic', doc='')
@xw.arg('structure_visual_basic', doc='')
@xw.arg('sub_visual_basic', doc='')
@xw.arg('synclock_visual_basic', doc='')
@xw.arg('then_visual_basic', doc='')
@xw.arg('throw_visual_basic', doc='')
@xw.arg('to_visual_basic', doc='')
@xw.arg('try_visual_basic', doc='')
@xw.arg('trycast_visual_basic', doc='')
@xw.arg('type_visual_basic', doc='')
@xw.arg('typeof_visual_basic', doc='')
@xw.arg('uinteger_visual_basic', doc='')
@xw.arg('ulong_visual_basic', doc='')
@xw.arg('ushort_visual_basic', doc='')
@xw.arg('using_visual_basic', doc='')
@xw.arg('variant_visual_basic', doc='')
@xw.arg('wend_visual_basic', doc='')
@xw.arg('when_visual_basic', doc='')
@xw.arg('while_visual_basic', doc='')
@xw.arg('widening_visual_basic', doc='')
@xw.arg('with_visual_basic', doc='')
@xw.arg('withevents_visual_basic', doc='')
@xw.arg('writeonly_visual_basic', doc='')
@xw.arg('xor_visual_basic', doc='')
@xw.ret(expand='table')
def vba_keywords_test_get_test_vba_restricted_keywords(addhandler_visual_basic, addressof_visual_basic, alias_visual_basic, and_visual_basic, andalso_visual_basic, as_visual_basic, boolean_visual_basic, byref_visual_basic, byte_visual_basic, byval_visual_basic, call_visual_basic, case_visual_basic, catch_visual_basic, cbool_visual_basic, cbyte_visual_basic, cchar_visual_basic, cdate_visual_basic, cdbl_visual_basic, cdec_visual_basic, char_visual_basic, cint_visual_basic, class_visual_basic, clng_visual_basic, cobj_visual_basic, const_visual_basic, continue_visual_basic, csbyte_visual_basic, cshort_visual_basic, csng_visual_basic, cstr_visual_basic, ctype_visual_basic, cuint_visual_basic, culng_visual_basic, currency_visual_basic, cushort_visual_basic, date_visual_basic, decimal_visual_basic, declare_visual_basic, default_visual_basic, delegate_visual_basic, dim_visual_basic, directcast_visual_basic, do_visual_basic, double_visual_basic, each_visual_basic, else_visual_basic, elseif_visual_basic, end_visual_basic, endif_visual_basic, enum_visual_basic, erase_visual_basic, error_visual_basic, event_visual_basic, exit_visual_basic, finally_visual_basic, for_visual_basic, friend_visual_basic, function_visual_basic, get_visual_basic, gettype_visual_basic, getxmlnamespace_visual_basic, global_visual_basic, gosub_visual_basic, goto_visual_basic, handles_visual_basic, if_visual_basic, implements_visual_basic, imports_visual_basic, in_visual_basic, inherits_visual_basic, integer_visual_basic, interface_visual_basic, is_visual_basic, isnot_visual_basic, let_visual_basic, lib_visual_basic, like_visual_basic, long_visual_basic, loop_visual_basic, me_visual_basic, mod_visual_basic, module_visual_basic, mustinherit_visual_basic, mustoverride_visual_basic, mybase_visual_basic, myclass_visual_basic, namespace_visual_basic, narrowing_visual_basic, new_visual_basic, next_visual_basic, not_visual_basic, nothing_visual_basic, notinheritable_visual_basic, notoverridable_visual_basic, object_visual_basic, of_visual_basic, on_visual_basic, operator_visual_basic, option_visual_basic, optional_visual_basic, or_visual_basic, orelse_visual_basic, overloads_visual_basic, overridable_visual_basic, overrides_visual_basic, paramarray_visual_basic, partial_visual_basic, private_visual_basic, property_visual_basic, protected_visual_basic, public_visual_basic, raiseevent_visual_basic, readonly_visual_basic, redim_visual_basic, rem_visual_basic, removehandler_visual_basic, resume_visual_basic, return_visual_basic, sbyte_visual_basic, select_visual_basic, set_visual_basic, shadows_visual_basic, shared_visual_basic, short_visual_basic, single_visual_basic, static_visual_basic, step_visual_basic, stop_visual_basic, string_visual_basic, structure_visual_basic, sub_visual_basic, synclock_visual_basic, then_visual_basic, throw_visual_basic, to_visual_basic, try_visual_basic, trycast_visual_basic, type_visual_basic, typeof_visual_basic, uinteger_visual_basic, ulong_visual_basic, ushort_visual_basic, using_visual_basic, variant_visual_basic, wend_visual_basic, when_visual_basic, while_visual_basic, widening_visual_basic, with_visual_basic, withevents_visual_basic, writeonly_visual_basic, xor_visual_basic):
    logger.info("[status=Calling] [function=vba_keywords_test_get_test_vba_restricted_keywords]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if addhandler_visual_basic is None or isinstance(addhandler_visual_basic, list) and all(x is None for x in addhandler_visual_basic):
        logger.error('addhandler_visual_basic is required.')
        return ['addhandler_visual_basic is required.']
    if addhandler_visual_basic is not None:

        request_parameters['addhandler'] = addhandler_visual_basic

    if addressof_visual_basic is None or isinstance(addressof_visual_basic, list) and all(x is None for x in addressof_visual_basic):
        logger.error('addressof_visual_basic is required.')
        return ['addressof_visual_basic is required.']
    if addressof_visual_basic is not None:

        request_parameters['addressof'] = addressof_visual_basic

    if alias_visual_basic is None or isinstance(alias_visual_basic, list) and all(x is None for x in alias_visual_basic):
        logger.error('alias_visual_basic is required.')
        return ['alias_visual_basic is required.']
    if alias_visual_basic is not None:

        request_parameters['alias'] = alias_visual_basic

    if and_visual_basic is None or isinstance(and_visual_basic, list) and all(x is None for x in and_visual_basic):
        logger.error('and_visual_basic is required.')
        return ['and_visual_basic is required.']
    if and_visual_basic is not None:

        request_parameters['and'] = and_visual_basic

    if andalso_visual_basic is None or isinstance(andalso_visual_basic, list) and all(x is None for x in andalso_visual_basic):
        logger.error('andalso_visual_basic is required.')
        return ['andalso_visual_basic is required.']
    if andalso_visual_basic is not None:

        request_parameters['andalso'] = andalso_visual_basic

    if as_visual_basic is None or isinstance(as_visual_basic, list) and all(x is None for x in as_visual_basic):
        logger.error('as_visual_basic is required.')
        return ['as_visual_basic is required.']
    if as_visual_basic is not None:

        request_parameters['as'] = as_visual_basic

    if boolean_visual_basic is None or isinstance(boolean_visual_basic, list) and all(x is None for x in boolean_visual_basic):
        logger.error('boolean_visual_basic is required.')
        return ['boolean_visual_basic is required.']
    if boolean_visual_basic is not None:

        request_parameters['boolean'] = boolean_visual_basic

    if byref_visual_basic is None or isinstance(byref_visual_basic, list) and all(x is None for x in byref_visual_basic):
        logger.error('byref_visual_basic is required.')
        return ['byref_visual_basic is required.']
    if byref_visual_basic is not None:

        request_parameters['byref'] = byref_visual_basic

    if byte_visual_basic is None or isinstance(byte_visual_basic, list) and all(x is None for x in byte_visual_basic):
        logger.error('byte_visual_basic is required.')
        return ['byte_visual_basic is required.']
    if byte_visual_basic is not None:

        request_parameters['byte'] = byte_visual_basic

    if byval_visual_basic is None or isinstance(byval_visual_basic, list) and all(x is None for x in byval_visual_basic):
        logger.error('byval_visual_basic is required.')
        return ['byval_visual_basic is required.']
    if byval_visual_basic is not None:

        request_parameters['byval'] = byval_visual_basic

    if call_visual_basic is None or isinstance(call_visual_basic, list) and all(x is None for x in call_visual_basic):
        logger.error('call_visual_basic is required.')
        return ['call_visual_basic is required.']
    if call_visual_basic is not None:

        request_parameters['call'] = call_visual_basic

    if case_visual_basic is None or isinstance(case_visual_basic, list) and all(x is None for x in case_visual_basic):
        logger.error('case_visual_basic is required.')
        return ['case_visual_basic is required.']
    if case_visual_basic is not None:

        request_parameters['case'] = case_visual_basic

    if catch_visual_basic is None or isinstance(catch_visual_basic, list) and all(x is None for x in catch_visual_basic):
        logger.error('catch_visual_basic is required.')
        return ['catch_visual_basic is required.']
    if catch_visual_basic is not None:

        request_parameters['catch'] = catch_visual_basic

    if cbool_visual_basic is None or isinstance(cbool_visual_basic, list) and all(x is None for x in cbool_visual_basic):
        logger.error('cbool_visual_basic is required.')
        return ['cbool_visual_basic is required.']
    if cbool_visual_basic is not None:

        request_parameters['cbool'] = cbool_visual_basic

    if cbyte_visual_basic is None or isinstance(cbyte_visual_basic, list) and all(x is None for x in cbyte_visual_basic):
        logger.error('cbyte_visual_basic is required.')
        return ['cbyte_visual_basic is required.']
    if cbyte_visual_basic is not None:

        request_parameters['cbyte'] = cbyte_visual_basic

    if cchar_visual_basic is None or isinstance(cchar_visual_basic, list) and all(x is None for x in cchar_visual_basic):
        logger.error('cchar_visual_basic is required.')
        return ['cchar_visual_basic is required.']
    if cchar_visual_basic is not None:

        request_parameters['cchar'] = cchar_visual_basic

    if cdate_visual_basic is None or isinstance(cdate_visual_basic, list) and all(x is None for x in cdate_visual_basic):
        logger.error('cdate_visual_basic is required.')
        return ['cdate_visual_basic is required.']
    if cdate_visual_basic is not None:

        request_parameters['cdate'] = cdate_visual_basic

    if cdbl_visual_basic is None or isinstance(cdbl_visual_basic, list) and all(x is None for x in cdbl_visual_basic):
        logger.error('cdbl_visual_basic is required.')
        return ['cdbl_visual_basic is required.']
    if cdbl_visual_basic is not None:

        request_parameters['cdbl'] = cdbl_visual_basic

    if cdec_visual_basic is None or isinstance(cdec_visual_basic, list) and all(x is None for x in cdec_visual_basic):
        logger.error('cdec_visual_basic is required.')
        return ['cdec_visual_basic is required.']
    if cdec_visual_basic is not None:

        request_parameters['cdec'] = cdec_visual_basic

    if char_visual_basic is None or isinstance(char_visual_basic, list) and all(x is None for x in char_visual_basic):
        logger.error('char_visual_basic is required.')
        return ['char_visual_basic is required.']
    if char_visual_basic is not None:

        request_parameters['char'] = char_visual_basic

    if cint_visual_basic is None or isinstance(cint_visual_basic, list) and all(x is None for x in cint_visual_basic):
        logger.error('cint_visual_basic is required.')
        return ['cint_visual_basic is required.']
    if cint_visual_basic is not None:

        request_parameters['cint'] = cint_visual_basic

    if class_visual_basic is None or isinstance(class_visual_basic, list) and all(x is None for x in class_visual_basic):
        logger.error('class_visual_basic is required.')
        return ['class_visual_basic is required.']
    if class_visual_basic is not None:

        request_parameters['class'] = class_visual_basic

    if clng_visual_basic is None or isinstance(clng_visual_basic, list) and all(x is None for x in clng_visual_basic):
        logger.error('clng_visual_basic is required.')
        return ['clng_visual_basic is required.']
    if clng_visual_basic is not None:

        request_parameters['clng'] = clng_visual_basic

    if cobj_visual_basic is None or isinstance(cobj_visual_basic, list) and all(x is None for x in cobj_visual_basic):
        logger.error('cobj_visual_basic is required.')
        return ['cobj_visual_basic is required.']
    if cobj_visual_basic is not None:

        request_parameters['cobj'] = cobj_visual_basic

    if const_visual_basic is None or isinstance(const_visual_basic, list) and all(x is None for x in const_visual_basic):
        logger.error('const_visual_basic is required.')
        return ['const_visual_basic is required.']
    if const_visual_basic is not None:

        request_parameters['const'] = const_visual_basic

    if continue_visual_basic is None or isinstance(continue_visual_basic, list) and all(x is None for x in continue_visual_basic):
        logger.error('continue_visual_basic is required.')
        return ['continue_visual_basic is required.']
    if continue_visual_basic is not None:

        request_parameters['continue'] = continue_visual_basic

    if csbyte_visual_basic is None or isinstance(csbyte_visual_basic, list) and all(x is None for x in csbyte_visual_basic):
        logger.error('csbyte_visual_basic is required.')
        return ['csbyte_visual_basic is required.']
    if csbyte_visual_basic is not None:

        request_parameters['csbyte'] = csbyte_visual_basic

    if cshort_visual_basic is None or isinstance(cshort_visual_basic, list) and all(x is None for x in cshort_visual_basic):
        logger.error('cshort_visual_basic is required.')
        return ['cshort_visual_basic is required.']
    if cshort_visual_basic is not None:

        request_parameters['cshort'] = cshort_visual_basic

    if csng_visual_basic is None or isinstance(csng_visual_basic, list) and all(x is None for x in csng_visual_basic):
        logger.error('csng_visual_basic is required.')
        return ['csng_visual_basic is required.']
    if csng_visual_basic is not None:

        request_parameters['csng'] = csng_visual_basic

    if cstr_visual_basic is None or isinstance(cstr_visual_basic, list) and all(x is None for x in cstr_visual_basic):
        logger.error('cstr_visual_basic is required.')
        return ['cstr_visual_basic is required.']
    if cstr_visual_basic is not None:

        request_parameters['cstr'] = cstr_visual_basic

    if ctype_visual_basic is None or isinstance(ctype_visual_basic, list) and all(x is None for x in ctype_visual_basic):
        logger.error('ctype_visual_basic is required.')
        return ['ctype_visual_basic is required.']
    if ctype_visual_basic is not None:

        request_parameters['ctype'] = ctype_visual_basic

    if cuint_visual_basic is None or isinstance(cuint_visual_basic, list) and all(x is None for x in cuint_visual_basic):
        logger.error('cuint_visual_basic is required.')
        return ['cuint_visual_basic is required.']
    if cuint_visual_basic is not None:

        request_parameters['cuint'] = cuint_visual_basic

    if culng_visual_basic is None or isinstance(culng_visual_basic, list) and all(x is None for x in culng_visual_basic):
        logger.error('culng_visual_basic is required.')
        return ['culng_visual_basic is required.']
    if culng_visual_basic is not None:

        request_parameters['culng'] = culng_visual_basic

    if currency_visual_basic is None or isinstance(currency_visual_basic, list) and all(x is None for x in currency_visual_basic):
        logger.error('currency_visual_basic is required.')
        return ['currency_visual_basic is required.']
    if currency_visual_basic is not None:

        request_parameters['currency'] = currency_visual_basic

    if cushort_visual_basic is None or isinstance(cushort_visual_basic, list) and all(x is None for x in cushort_visual_basic):
        logger.error('cushort_visual_basic is required.')
        return ['cushort_visual_basic is required.']
    if cushort_visual_basic is not None:

        request_parameters['cushort'] = cushort_visual_basic

    if date_visual_basic is None or isinstance(date_visual_basic, list) and all(x is None for x in date_visual_basic):
        logger.error('date_visual_basic is required.')
        return ['date_visual_basic is required.']
    if date_visual_basic is not None:

        request_parameters['date'] = date_visual_basic

    if decimal_visual_basic is None or isinstance(decimal_visual_basic, list) and all(x is None for x in decimal_visual_basic):
        logger.error('decimal_visual_basic is required.')
        return ['decimal_visual_basic is required.']
    if decimal_visual_basic is not None:

        request_parameters['decimal'] = decimal_visual_basic

    if declare_visual_basic is None or isinstance(declare_visual_basic, list) and all(x is None for x in declare_visual_basic):
        logger.error('declare_visual_basic is required.')
        return ['declare_visual_basic is required.']
    if declare_visual_basic is not None:

        request_parameters['declare'] = declare_visual_basic

    if default_visual_basic is None or isinstance(default_visual_basic, list) and all(x is None for x in default_visual_basic):
        logger.error('default_visual_basic is required.')
        return ['default_visual_basic is required.']
    if default_visual_basic is not None:

        request_parameters['default'] = default_visual_basic

    if delegate_visual_basic is None or isinstance(delegate_visual_basic, list) and all(x is None for x in delegate_visual_basic):
        logger.error('delegate_visual_basic is required.')
        return ['delegate_visual_basic is required.']
    if delegate_visual_basic is not None:

        request_parameters['delegate'] = delegate_visual_basic

    if dim_visual_basic is None or isinstance(dim_visual_basic, list) and all(x is None for x in dim_visual_basic):
        logger.error('dim_visual_basic is required.')
        return ['dim_visual_basic is required.']
    if dim_visual_basic is not None:

        request_parameters['dim'] = dim_visual_basic

    if directcast_visual_basic is None or isinstance(directcast_visual_basic, list) and all(x is None for x in directcast_visual_basic):
        logger.error('directcast_visual_basic is required.')
        return ['directcast_visual_basic is required.']
    if directcast_visual_basic is not None:

        request_parameters['directcast'] = directcast_visual_basic

    if do_visual_basic is None or isinstance(do_visual_basic, list) and all(x is None for x in do_visual_basic):
        logger.error('do_visual_basic is required.')
        return ['do_visual_basic is required.']
    if do_visual_basic is not None:

        request_parameters['do'] = do_visual_basic

    if double_visual_basic is None or isinstance(double_visual_basic, list) and all(x is None for x in double_visual_basic):
        logger.error('double_visual_basic is required.')
        return ['double_visual_basic is required.']
    if double_visual_basic is not None:

        request_parameters['double'] = double_visual_basic

    if each_visual_basic is None or isinstance(each_visual_basic, list) and all(x is None for x in each_visual_basic):
        logger.error('each_visual_basic is required.')
        return ['each_visual_basic is required.']
    if each_visual_basic is not None:

        request_parameters['each'] = each_visual_basic

    if else_visual_basic is None or isinstance(else_visual_basic, list) and all(x is None for x in else_visual_basic):
        logger.error('else_visual_basic is required.')
        return ['else_visual_basic is required.']
    if else_visual_basic is not None:

        request_parameters['else'] = else_visual_basic

    if elseif_visual_basic is None or isinstance(elseif_visual_basic, list) and all(x is None for x in elseif_visual_basic):
        logger.error('elseif_visual_basic is required.')
        return ['elseif_visual_basic is required.']
    if elseif_visual_basic is not None:

        request_parameters['elseif'] = elseif_visual_basic

    if end_visual_basic is None or isinstance(end_visual_basic, list) and all(x is None for x in end_visual_basic):
        logger.error('end_visual_basic is required.')
        return ['end_visual_basic is required.']
    if end_visual_basic is not None:

        request_parameters['end'] = end_visual_basic

    if endif_visual_basic is None or isinstance(endif_visual_basic, list) and all(x is None for x in endif_visual_basic):
        logger.error('endif_visual_basic is required.')
        return ['endif_visual_basic is required.']
    if endif_visual_basic is not None:

        request_parameters['endif'] = endif_visual_basic

    if enum_visual_basic is None or isinstance(enum_visual_basic, list) and all(x is None for x in enum_visual_basic):
        logger.error('enum_visual_basic is required.')
        return ['enum_visual_basic is required.']
    if enum_visual_basic is not None:

        request_parameters['enum'] = enum_visual_basic

    if erase_visual_basic is None or isinstance(erase_visual_basic, list) and all(x is None for x in erase_visual_basic):
        logger.error('erase_visual_basic is required.')
        return ['erase_visual_basic is required.']
    if erase_visual_basic is not None:

        request_parameters['erase'] = erase_visual_basic

    if error_visual_basic is None or isinstance(error_visual_basic, list) and all(x is None for x in error_visual_basic):
        logger.error('error_visual_basic is required.')
        return ['error_visual_basic is required.']
    if error_visual_basic is not None:

        request_parameters['error'] = error_visual_basic

    if event_visual_basic is None or isinstance(event_visual_basic, list) and all(x is None for x in event_visual_basic):
        logger.error('event_visual_basic is required.')
        return ['event_visual_basic is required.']
    if event_visual_basic is not None:

        request_parameters['event'] = event_visual_basic

    if exit_visual_basic is None or isinstance(exit_visual_basic, list) and all(x is None for x in exit_visual_basic):
        logger.error('exit_visual_basic is required.')
        return ['exit_visual_basic is required.']
    if exit_visual_basic is not None:

        request_parameters['exit'] = exit_visual_basic

    if finally_visual_basic is None or isinstance(finally_visual_basic, list) and all(x is None for x in finally_visual_basic):
        logger.error('finally_visual_basic is required.')
        return ['finally_visual_basic is required.']
    if finally_visual_basic is not None:

        request_parameters['finally'] = finally_visual_basic

    if for_visual_basic is None or isinstance(for_visual_basic, list) and all(x is None for x in for_visual_basic):
        logger.error('for_visual_basic is required.')
        return ['for_visual_basic is required.']
    if for_visual_basic is not None:

        request_parameters['for'] = for_visual_basic

    if friend_visual_basic is None or isinstance(friend_visual_basic, list) and all(x is None for x in friend_visual_basic):
        logger.error('friend_visual_basic is required.')
        return ['friend_visual_basic is required.']
    if friend_visual_basic is not None:

        request_parameters['friend'] = friend_visual_basic

    if function_visual_basic is None or isinstance(function_visual_basic, list) and all(x is None for x in function_visual_basic):
        logger.error('function_visual_basic is required.')
        return ['function_visual_basic is required.']
    if function_visual_basic is not None:

        request_parameters['function'] = function_visual_basic

    if get_visual_basic is None or isinstance(get_visual_basic, list) and all(x is None for x in get_visual_basic):
        logger.error('get_visual_basic is required.')
        return ['get_visual_basic is required.']
    if get_visual_basic is not None:

        request_parameters['get'] = get_visual_basic

    if gettype_visual_basic is None or isinstance(gettype_visual_basic, list) and all(x is None for x in gettype_visual_basic):
        logger.error('gettype_visual_basic is required.')
        return ['gettype_visual_basic is required.']
    if gettype_visual_basic is not None:

        request_parameters['gettype'] = gettype_visual_basic

    if getxmlnamespace_visual_basic is None or isinstance(getxmlnamespace_visual_basic, list) and all(x is None for x in getxmlnamespace_visual_basic):
        logger.error('getxmlnamespace_visual_basic is required.')
        return ['getxmlnamespace_visual_basic is required.']
    if getxmlnamespace_visual_basic is not None:

        request_parameters['getxmlnamespace'] = getxmlnamespace_visual_basic

    if global_visual_basic is None or isinstance(global_visual_basic, list) and all(x is None for x in global_visual_basic):
        logger.error('global_visual_basic is required.')
        return ['global_visual_basic is required.']
    if global_visual_basic is not None:

        request_parameters['global'] = global_visual_basic

    if gosub_visual_basic is None or isinstance(gosub_visual_basic, list) and all(x is None for x in gosub_visual_basic):
        logger.error('gosub_visual_basic is required.')
        return ['gosub_visual_basic is required.']
    if gosub_visual_basic is not None:

        request_parameters['gosub'] = gosub_visual_basic

    if goto_visual_basic is None or isinstance(goto_visual_basic, list) and all(x is None for x in goto_visual_basic):
        logger.error('goto_visual_basic is required.')
        return ['goto_visual_basic is required.']
    if goto_visual_basic is not None:

        request_parameters['goto'] = goto_visual_basic

    if handles_visual_basic is None or isinstance(handles_visual_basic, list) and all(x is None for x in handles_visual_basic):
        logger.error('handles_visual_basic is required.')
        return ['handles_visual_basic is required.']
    if handles_visual_basic is not None:

        request_parameters['handles'] = handles_visual_basic

    if if_visual_basic is None or isinstance(if_visual_basic, list) and all(x is None for x in if_visual_basic):
        logger.error('if_visual_basic is required.')
        return ['if_visual_basic is required.']
    if if_visual_basic is not None:

        request_parameters['if'] = if_visual_basic

    if implements_visual_basic is None or isinstance(implements_visual_basic, list) and all(x is None for x in implements_visual_basic):
        logger.error('implements_visual_basic is required.')
        return ['implements_visual_basic is required.']
    if implements_visual_basic is not None:

        request_parameters['implements'] = implements_visual_basic

    if imports_visual_basic is None or isinstance(imports_visual_basic, list) and all(x is None for x in imports_visual_basic):
        logger.error('imports_visual_basic is required.')
        return ['imports_visual_basic is required.']
    if imports_visual_basic is not None:

        request_parameters['imports'] = imports_visual_basic

    if in_visual_basic is None or isinstance(in_visual_basic, list) and all(x is None for x in in_visual_basic):
        logger.error('in_visual_basic is required.')
        return ['in_visual_basic is required.']
    if in_visual_basic is not None:

        request_parameters['in'] = in_visual_basic

    if inherits_visual_basic is None or isinstance(inherits_visual_basic, list) and all(x is None for x in inherits_visual_basic):
        logger.error('inherits_visual_basic is required.')
        return ['inherits_visual_basic is required.']
    if inherits_visual_basic is not None:

        request_parameters['inherits'] = inherits_visual_basic

    if integer_visual_basic is None or isinstance(integer_visual_basic, list) and all(x is None for x in integer_visual_basic):
        logger.error('integer_visual_basic is required.')
        return ['integer_visual_basic is required.']
    if integer_visual_basic is not None:

        request_parameters['integer'] = integer_visual_basic

    if interface_visual_basic is None or isinstance(interface_visual_basic, list) and all(x is None for x in interface_visual_basic):
        logger.error('interface_visual_basic is required.')
        return ['interface_visual_basic is required.']
    if interface_visual_basic is not None:

        request_parameters['interface'] = interface_visual_basic

    if is_visual_basic is None or isinstance(is_visual_basic, list) and all(x is None for x in is_visual_basic):
        logger.error('is_visual_basic is required.')
        return ['is_visual_basic is required.']
    if is_visual_basic is not None:

        request_parameters['is'] = is_visual_basic

    if isnot_visual_basic is None or isinstance(isnot_visual_basic, list) and all(x is None for x in isnot_visual_basic):
        logger.error('isnot_visual_basic is required.')
        return ['isnot_visual_basic is required.']
    if isnot_visual_basic is not None:

        request_parameters['isnot'] = isnot_visual_basic

    if let_visual_basic is None or isinstance(let_visual_basic, list) and all(x is None for x in let_visual_basic):
        logger.error('let_visual_basic is required.')
        return ['let_visual_basic is required.']
    if let_visual_basic is not None:

        request_parameters['let'] = let_visual_basic

    if lib_visual_basic is None or isinstance(lib_visual_basic, list) and all(x is None for x in lib_visual_basic):
        logger.error('lib_visual_basic is required.')
        return ['lib_visual_basic is required.']
    if lib_visual_basic is not None:

        request_parameters['lib'] = lib_visual_basic

    if like_visual_basic is None or isinstance(like_visual_basic, list) and all(x is None for x in like_visual_basic):
        logger.error('like_visual_basic is required.')
        return ['like_visual_basic is required.']
    if like_visual_basic is not None:

        request_parameters['like'] = like_visual_basic

    if long_visual_basic is None or isinstance(long_visual_basic, list) and all(x is None for x in long_visual_basic):
        logger.error('long_visual_basic is required.')
        return ['long_visual_basic is required.']
    if long_visual_basic is not None:

        request_parameters['long'] = long_visual_basic

    if loop_visual_basic is None or isinstance(loop_visual_basic, list) and all(x is None for x in loop_visual_basic):
        logger.error('loop_visual_basic is required.')
        return ['loop_visual_basic is required.']
    if loop_visual_basic is not None:

        request_parameters['loop'] = loop_visual_basic

    if me_visual_basic is None or isinstance(me_visual_basic, list) and all(x is None for x in me_visual_basic):
        logger.error('me_visual_basic is required.')
        return ['me_visual_basic is required.']
    if me_visual_basic is not None:

        request_parameters['me'] = me_visual_basic

    if mod_visual_basic is None or isinstance(mod_visual_basic, list) and all(x is None for x in mod_visual_basic):
        logger.error('mod_visual_basic is required.')
        return ['mod_visual_basic is required.']
    if mod_visual_basic is not None:

        request_parameters['mod'] = mod_visual_basic

    if module_visual_basic is None or isinstance(module_visual_basic, list) and all(x is None for x in module_visual_basic):
        logger.error('module_visual_basic is required.')
        return ['module_visual_basic is required.']
    if module_visual_basic is not None:

        request_parameters['module'] = module_visual_basic

    if mustinherit_visual_basic is None or isinstance(mustinherit_visual_basic, list) and all(x is None for x in mustinherit_visual_basic):
        logger.error('mustinherit_visual_basic is required.')
        return ['mustinherit_visual_basic is required.']
    if mustinherit_visual_basic is not None:

        request_parameters['mustinherit'] = mustinherit_visual_basic

    if mustoverride_visual_basic is None or isinstance(mustoverride_visual_basic, list) and all(x is None for x in mustoverride_visual_basic):
        logger.error('mustoverride_visual_basic is required.')
        return ['mustoverride_visual_basic is required.']
    if mustoverride_visual_basic is not None:

        request_parameters['mustoverride'] = mustoverride_visual_basic

    if mybase_visual_basic is None or isinstance(mybase_visual_basic, list) and all(x is None for x in mybase_visual_basic):
        logger.error('mybase_visual_basic is required.')
        return ['mybase_visual_basic is required.']
    if mybase_visual_basic is not None:

        request_parameters['mybase'] = mybase_visual_basic

    if myclass_visual_basic is None or isinstance(myclass_visual_basic, list) and all(x is None for x in myclass_visual_basic):
        logger.error('myclass_visual_basic is required.')
        return ['myclass_visual_basic is required.']
    if myclass_visual_basic is not None:

        request_parameters['myclass'] = myclass_visual_basic

    if namespace_visual_basic is None or isinstance(namespace_visual_basic, list) and all(x is None for x in namespace_visual_basic):
        logger.error('namespace_visual_basic is required.')
        return ['namespace_visual_basic is required.']
    if namespace_visual_basic is not None:

        request_parameters['namespace'] = namespace_visual_basic

    if narrowing_visual_basic is None or isinstance(narrowing_visual_basic, list) and all(x is None for x in narrowing_visual_basic):
        logger.error('narrowing_visual_basic is required.')
        return ['narrowing_visual_basic is required.']
    if narrowing_visual_basic is not None:

        request_parameters['narrowing'] = narrowing_visual_basic

    if new_visual_basic is None or isinstance(new_visual_basic, list) and all(x is None for x in new_visual_basic):
        logger.error('new_visual_basic is required.')
        return ['new_visual_basic is required.']
    if new_visual_basic is not None:

        request_parameters['new'] = new_visual_basic

    if next_visual_basic is None or isinstance(next_visual_basic, list) and all(x is None for x in next_visual_basic):
        logger.error('next_visual_basic is required.')
        return ['next_visual_basic is required.']
    if next_visual_basic is not None:

        request_parameters['next'] = next_visual_basic

    if not_visual_basic is None or isinstance(not_visual_basic, list) and all(x is None for x in not_visual_basic):
        logger.error('not_visual_basic is required.')
        return ['not_visual_basic is required.']
    if not_visual_basic is not None:

        request_parameters['not'] = not_visual_basic

    if nothing_visual_basic is None or isinstance(nothing_visual_basic, list) and all(x is None for x in nothing_visual_basic):
        logger.error('nothing_visual_basic is required.')
        return ['nothing_visual_basic is required.']
    if nothing_visual_basic is not None:

        request_parameters['nothing'] = nothing_visual_basic

    if notinheritable_visual_basic is None or isinstance(notinheritable_visual_basic, list) and all(x is None for x in notinheritable_visual_basic):
        logger.error('notinheritable_visual_basic is required.')
        return ['notinheritable_visual_basic is required.']
    if notinheritable_visual_basic is not None:

        request_parameters['notinheritable'] = notinheritable_visual_basic

    if notoverridable_visual_basic is None or isinstance(notoverridable_visual_basic, list) and all(x is None for x in notoverridable_visual_basic):
        logger.error('notoverridable_visual_basic is required.')
        return ['notoverridable_visual_basic is required.']
    if notoverridable_visual_basic is not None:

        request_parameters['notoverridable'] = notoverridable_visual_basic

    if object_visual_basic is None or isinstance(object_visual_basic, list) and all(x is None for x in object_visual_basic):
        logger.error('object_visual_basic is required.')
        return ['object_visual_basic is required.']
    if object_visual_basic is not None:

        request_parameters['object'] = object_visual_basic

    if of_visual_basic is None or isinstance(of_visual_basic, list) and all(x is None for x in of_visual_basic):
        logger.error('of_visual_basic is required.')
        return ['of_visual_basic is required.']
    if of_visual_basic is not None:

        request_parameters['of'] = of_visual_basic

    if on_visual_basic is None or isinstance(on_visual_basic, list) and all(x is None for x in on_visual_basic):
        logger.error('on_visual_basic is required.')
        return ['on_visual_basic is required.']
    if on_visual_basic is not None:

        request_parameters['on'] = on_visual_basic

    if operator_visual_basic is None or isinstance(operator_visual_basic, list) and all(x is None for x in operator_visual_basic):
        logger.error('operator_visual_basic is required.')
        return ['operator_visual_basic is required.']
    if operator_visual_basic is not None:

        request_parameters['operator'] = operator_visual_basic

    if option_visual_basic is None or isinstance(option_visual_basic, list) and all(x is None for x in option_visual_basic):
        logger.error('option_visual_basic is required.')
        return ['option_visual_basic is required.']
    if option_visual_basic is not None:

        request_parameters['option'] = option_visual_basic

    if optional_visual_basic is None or isinstance(optional_visual_basic, list) and all(x is None for x in optional_visual_basic):
        logger.error('optional_visual_basic is required.')
        return ['optional_visual_basic is required.']
    if optional_visual_basic is not None:

        request_parameters['optional'] = optional_visual_basic

    if or_visual_basic is None or isinstance(or_visual_basic, list) and all(x is None for x in or_visual_basic):
        logger.error('or_visual_basic is required.')
        return ['or_visual_basic is required.']
    if or_visual_basic is not None:

        request_parameters['or'] = or_visual_basic

    if orelse_visual_basic is None or isinstance(orelse_visual_basic, list) and all(x is None for x in orelse_visual_basic):
        logger.error('orelse_visual_basic is required.')
        return ['orelse_visual_basic is required.']
    if orelse_visual_basic is not None:

        request_parameters['orelse'] = orelse_visual_basic

    if overloads_visual_basic is None or isinstance(overloads_visual_basic, list) and all(x is None for x in overloads_visual_basic):
        logger.error('overloads_visual_basic is required.')
        return ['overloads_visual_basic is required.']
    if overloads_visual_basic is not None:

        request_parameters['overloads'] = overloads_visual_basic

    if overridable_visual_basic is None or isinstance(overridable_visual_basic, list) and all(x is None for x in overridable_visual_basic):
        logger.error('overridable_visual_basic is required.')
        return ['overridable_visual_basic is required.']
    if overridable_visual_basic is not None:

        request_parameters['overridable'] = overridable_visual_basic

    if overrides_visual_basic is None or isinstance(overrides_visual_basic, list) and all(x is None for x in overrides_visual_basic):
        logger.error('overrides_visual_basic is required.')
        return ['overrides_visual_basic is required.']
    if overrides_visual_basic is not None:

        request_parameters['overrides'] = overrides_visual_basic

    if paramarray_visual_basic is None or isinstance(paramarray_visual_basic, list) and all(x is None for x in paramarray_visual_basic):
        logger.error('paramarray_visual_basic is required.')
        return ['paramarray_visual_basic is required.']
    if paramarray_visual_basic is not None:

        request_parameters['paramarray'] = paramarray_visual_basic

    if partial_visual_basic is None or isinstance(partial_visual_basic, list) and all(x is None for x in partial_visual_basic):
        logger.error('partial_visual_basic is required.')
        return ['partial_visual_basic is required.']
    if partial_visual_basic is not None:

        request_parameters['partial'] = partial_visual_basic

    if private_visual_basic is None or isinstance(private_visual_basic, list) and all(x is None for x in private_visual_basic):
        logger.error('private_visual_basic is required.')
        return ['private_visual_basic is required.']
    if private_visual_basic is not None:

        request_parameters['private'] = private_visual_basic

    if property_visual_basic is None or isinstance(property_visual_basic, list) and all(x is None for x in property_visual_basic):
        logger.error('property_visual_basic is required.')
        return ['property_visual_basic is required.']
    if property_visual_basic is not None:

        request_parameters['property'] = property_visual_basic

    if protected_visual_basic is None or isinstance(protected_visual_basic, list) and all(x is None for x in protected_visual_basic):
        logger.error('protected_visual_basic is required.')
        return ['protected_visual_basic is required.']
    if protected_visual_basic is not None:

        request_parameters['protected'] = protected_visual_basic

    if public_visual_basic is None or isinstance(public_visual_basic, list) and all(x is None for x in public_visual_basic):
        logger.error('public_visual_basic is required.')
        return ['public_visual_basic is required.']
    if public_visual_basic is not None:

        request_parameters['public'] = public_visual_basic

    if raiseevent_visual_basic is None or isinstance(raiseevent_visual_basic, list) and all(x is None for x in raiseevent_visual_basic):
        logger.error('raiseevent_visual_basic is required.')
        return ['raiseevent_visual_basic is required.']
    if raiseevent_visual_basic is not None:

        request_parameters['raiseevent'] = raiseevent_visual_basic

    if readonly_visual_basic is None or isinstance(readonly_visual_basic, list) and all(x is None for x in readonly_visual_basic):
        logger.error('readonly_visual_basic is required.')
        return ['readonly_visual_basic is required.']
    if readonly_visual_basic is not None:

        request_parameters['readonly'] = readonly_visual_basic

    if redim_visual_basic is None or isinstance(redim_visual_basic, list) and all(x is None for x in redim_visual_basic):
        logger.error('redim_visual_basic is required.')
        return ['redim_visual_basic is required.']
    if redim_visual_basic is not None:

        request_parameters['redim'] = redim_visual_basic

    if rem_visual_basic is None or isinstance(rem_visual_basic, list) and all(x is None for x in rem_visual_basic):
        logger.error('rem_visual_basic is required.')
        return ['rem_visual_basic is required.']
    if rem_visual_basic is not None:

        request_parameters['rem'] = rem_visual_basic

    if removehandler_visual_basic is None or isinstance(removehandler_visual_basic, list) and all(x is None for x in removehandler_visual_basic):
        logger.error('removehandler_visual_basic is required.')
        return ['removehandler_visual_basic is required.']
    if removehandler_visual_basic is not None:

        request_parameters['removehandler'] = removehandler_visual_basic

    if resume_visual_basic is None or isinstance(resume_visual_basic, list) and all(x is None for x in resume_visual_basic):
        logger.error('resume_visual_basic is required.')
        return ['resume_visual_basic is required.']
    if resume_visual_basic is not None:

        request_parameters['resume'] = resume_visual_basic

    if return_visual_basic is None or isinstance(return_visual_basic, list) and all(x is None for x in return_visual_basic):
        logger.error('return_visual_basic is required.')
        return ['return_visual_basic is required.']
    if return_visual_basic is not None:

        request_parameters['return'] = return_visual_basic

    if sbyte_visual_basic is None or isinstance(sbyte_visual_basic, list) and all(x is None for x in sbyte_visual_basic):
        logger.error('sbyte_visual_basic is required.')
        return ['sbyte_visual_basic is required.']
    if sbyte_visual_basic is not None:

        request_parameters['sbyte'] = sbyte_visual_basic

    if select_visual_basic is None or isinstance(select_visual_basic, list) and all(x is None for x in select_visual_basic):
        logger.error('select_visual_basic is required.')
        return ['select_visual_basic is required.']
    if select_visual_basic is not None:

        request_parameters['select'] = select_visual_basic

    if set_visual_basic is None or isinstance(set_visual_basic, list) and all(x is None for x in set_visual_basic):
        logger.error('set_visual_basic is required.')
        return ['set_visual_basic is required.']
    if set_visual_basic is not None:

        request_parameters['set'] = set_visual_basic

    if shadows_visual_basic is None or isinstance(shadows_visual_basic, list) and all(x is None for x in shadows_visual_basic):
        logger.error('shadows_visual_basic is required.')
        return ['shadows_visual_basic is required.']
    if shadows_visual_basic is not None:

        request_parameters['shadows'] = shadows_visual_basic

    if shared_visual_basic is None or isinstance(shared_visual_basic, list) and all(x is None for x in shared_visual_basic):
        logger.error('shared_visual_basic is required.')
        return ['shared_visual_basic is required.']
    if shared_visual_basic is not None:

        request_parameters['shared'] = shared_visual_basic

    if short_visual_basic is None or isinstance(short_visual_basic, list) and all(x is None for x in short_visual_basic):
        logger.error('short_visual_basic is required.')
        return ['short_visual_basic is required.']
    if short_visual_basic is not None:

        request_parameters['short'] = short_visual_basic

    if single_visual_basic is None or isinstance(single_visual_basic, list) and all(x is None for x in single_visual_basic):
        logger.error('single_visual_basic is required.')
        return ['single_visual_basic is required.']
    if single_visual_basic is not None:

        request_parameters['single'] = single_visual_basic

    if static_visual_basic is None or isinstance(static_visual_basic, list) and all(x is None for x in static_visual_basic):
        logger.error('static_visual_basic is required.')
        return ['static_visual_basic is required.']
    if static_visual_basic is not None:

        request_parameters['static'] = static_visual_basic

    if step_visual_basic is None or isinstance(step_visual_basic, list) and all(x is None for x in step_visual_basic):
        logger.error('step_visual_basic is required.')
        return ['step_visual_basic is required.']
    if step_visual_basic is not None:

        request_parameters['step'] = step_visual_basic

    if stop_visual_basic is None or isinstance(stop_visual_basic, list) and all(x is None for x in stop_visual_basic):
        logger.error('stop_visual_basic is required.')
        return ['stop_visual_basic is required.']
    if stop_visual_basic is not None:

        request_parameters['stop'] = stop_visual_basic

    if string_visual_basic is None or isinstance(string_visual_basic, list) and all(x is None for x in string_visual_basic):
        logger.error('string_visual_basic is required.')
        return ['string_visual_basic is required.']
    if string_visual_basic is not None:

        request_parameters['string'] = string_visual_basic

    if structure_visual_basic is None or isinstance(structure_visual_basic, list) and all(x is None for x in structure_visual_basic):
        logger.error('structure_visual_basic is required.')
        return ['structure_visual_basic is required.']
    if structure_visual_basic is not None:

        request_parameters['structure'] = structure_visual_basic

    if sub_visual_basic is None or isinstance(sub_visual_basic, list) and all(x is None for x in sub_visual_basic):
        logger.error('sub_visual_basic is required.')
        return ['sub_visual_basic is required.']
    if sub_visual_basic is not None:

        request_parameters['sub'] = sub_visual_basic

    if synclock_visual_basic is None or isinstance(synclock_visual_basic, list) and all(x is None for x in synclock_visual_basic):
        logger.error('synclock_visual_basic is required.')
        return ['synclock_visual_basic is required.']
    if synclock_visual_basic is not None:

        request_parameters['synclock'] = synclock_visual_basic

    if then_visual_basic is None or isinstance(then_visual_basic, list) and all(x is None for x in then_visual_basic):
        logger.error('then_visual_basic is required.')
        return ['then_visual_basic is required.']
    if then_visual_basic is not None:

        request_parameters['then'] = then_visual_basic

    if throw_visual_basic is None or isinstance(throw_visual_basic, list) and all(x is None for x in throw_visual_basic):
        logger.error('throw_visual_basic is required.')
        return ['throw_visual_basic is required.']
    if throw_visual_basic is not None:

        request_parameters['throw'] = throw_visual_basic

    if to_visual_basic is None or isinstance(to_visual_basic, list) and all(x is None for x in to_visual_basic):
        logger.error('to_visual_basic is required.')
        return ['to_visual_basic is required.']
    if to_visual_basic is not None:

        request_parameters['to'] = to_visual_basic

    if try_visual_basic is None or isinstance(try_visual_basic, list) and all(x is None for x in try_visual_basic):
        logger.error('try_visual_basic is required.')
        return ['try_visual_basic is required.']
    if try_visual_basic is not None:

        request_parameters['try'] = try_visual_basic

    if trycast_visual_basic is None or isinstance(trycast_visual_basic, list) and all(x is None for x in trycast_visual_basic):
        logger.error('trycast_visual_basic is required.')
        return ['trycast_visual_basic is required.']
    if trycast_visual_basic is not None:

        request_parameters['trycast'] = trycast_visual_basic

    if type_visual_basic is None or isinstance(type_visual_basic, list) and all(x is None for x in type_visual_basic):
        logger.error('type_visual_basic is required.')
        return ['type_visual_basic is required.']
    if type_visual_basic is not None:

        request_parameters['type'] = type_visual_basic

    if typeof_visual_basic is None or isinstance(typeof_visual_basic, list) and all(x is None for x in typeof_visual_basic):
        logger.error('typeof_visual_basic is required.')
        return ['typeof_visual_basic is required.']
    if typeof_visual_basic is not None:

        request_parameters['typeof'] = typeof_visual_basic

    if uinteger_visual_basic is None or isinstance(uinteger_visual_basic, list) and all(x is None for x in uinteger_visual_basic):
        logger.error('uinteger_visual_basic is required.')
        return ['uinteger_visual_basic is required.']
    if uinteger_visual_basic is not None:

        request_parameters['uinteger'] = uinteger_visual_basic

    if ulong_visual_basic is None or isinstance(ulong_visual_basic, list) and all(x is None for x in ulong_visual_basic):
        logger.error('ulong_visual_basic is required.')
        return ['ulong_visual_basic is required.']
    if ulong_visual_basic is not None:

        request_parameters['ulong'] = ulong_visual_basic

    if ushort_visual_basic is None or isinstance(ushort_visual_basic, list) and all(x is None for x in ushort_visual_basic):
        logger.error('ushort_visual_basic is required.')
        return ['ushort_visual_basic is required.']
    if ushort_visual_basic is not None:

        request_parameters['ushort'] = ushort_visual_basic

    if using_visual_basic is None or isinstance(using_visual_basic, list) and all(x is None for x in using_visual_basic):
        logger.error('using_visual_basic is required.')
        return ['using_visual_basic is required.']
    if using_visual_basic is not None:

        request_parameters['using'] = using_visual_basic

    if variant_visual_basic is None or isinstance(variant_visual_basic, list) and all(x is None for x in variant_visual_basic):
        logger.error('variant_visual_basic is required.')
        return ['variant_visual_basic is required.']
    if variant_visual_basic is not None:

        request_parameters['variant'] = variant_visual_basic

    if wend_visual_basic is None or isinstance(wend_visual_basic, list) and all(x is None for x in wend_visual_basic):
        logger.error('wend_visual_basic is required.')
        return ['wend_visual_basic is required.']
    if wend_visual_basic is not None:

        request_parameters['wend'] = wend_visual_basic

    if when_visual_basic is None or isinstance(when_visual_basic, list) and all(x is None for x in when_visual_basic):
        logger.error('when_visual_basic is required.')
        return ['when_visual_basic is required.']
    if when_visual_basic is not None:

        request_parameters['when'] = when_visual_basic

    if while_visual_basic is None or isinstance(while_visual_basic, list) and all(x is None for x in while_visual_basic):
        logger.error('while_visual_basic is required.')
        return ['while_visual_basic is required.']
    if while_visual_basic is not None:

        request_parameters['while'] = while_visual_basic

    if widening_visual_basic is None or isinstance(widening_visual_basic, list) and all(x is None for x in widening_visual_basic):
        logger.error('widening_visual_basic is required.')
        return ['widening_visual_basic is required.']
    if widening_visual_basic is not None:

        request_parameters['widening'] = widening_visual_basic

    if with_visual_basic is None or isinstance(with_visual_basic, list) and all(x is None for x in with_visual_basic):
        logger.error('with_visual_basic is required.')
        return ['with_visual_basic is required.']
    if with_visual_basic is not None:

        request_parameters['with'] = with_visual_basic

    if withevents_visual_basic is None or isinstance(withevents_visual_basic, list) and all(x is None for x in withevents_visual_basic):
        logger.error('withevents_visual_basic is required.')
        return ['withevents_visual_basic is required.']
    if withevents_visual_basic is not None:

        request_parameters['withevents'] = withevents_visual_basic

    if writeonly_visual_basic is None or isinstance(writeonly_visual_basic, list) and all(x is None for x in writeonly_visual_basic):
        logger.error('writeonly_visual_basic is required.')
        return ['writeonly_visual_basic is required.']
    if writeonly_visual_basic is not None:

        request_parameters['writeonly'] = writeonly_visual_basic

    if xor_visual_basic is None or isinstance(xor_visual_basic, list) and all(x is None for x in xor_visual_basic):
        logger.error('xor_visual_basic is required.')
        return ['xor_visual_basic is required.']
    if xor_visual_basic is not None:

        request_parameters['xor'] = xor_visual_basic


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8949/test/vba/restricted/keywords'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=vba_keywords_test_get_test_vba_restricted_keywords] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value'), (u'schema', OrderedDict([(u'$ref', u'#/definitions/VBAKeywords')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('vba_keywords_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=vba_keywords_test_get_test_vba_restricted_keywords] [url=http://localhost:8949/test/vba/restricted/keywords].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=vba_keywords_test_get_test_vba_restricted_keywords] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=vba_keywords_test_get_test_vba_restricted_keywords] [url=http://localhost:8949/test/vba/restricted/keywords].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='vba_keywords_test', call_in_wizard=False)
@xw.arg('addhandler_visual_basic', doc='')
@xw.arg('addressof_visual_basic', doc='')
@xw.arg('alias_visual_basic', doc='')
@xw.arg('and_visual_basic', doc='')
@xw.arg('andalso_visual_basic', doc='')
@xw.arg('as_visual_basic', doc='')
@xw.arg('boolean_visual_basic', doc='')
@xw.arg('byref_visual_basic', doc='')
@xw.arg('byte_visual_basic', doc='')
@xw.arg('byval_visual_basic', doc='')
@xw.arg('call_visual_basic', doc='')
@xw.arg('case_visual_basic', doc='')
@xw.arg('catch_visual_basic', doc='')
@xw.arg('cbool_visual_basic', doc='')
@xw.arg('cbyte_visual_basic', doc='')
@xw.arg('cchar_visual_basic', doc='')
@xw.arg('cdate_visual_basic', doc='')
@xw.arg('cdbl_visual_basic', doc='')
@xw.arg('cdec_visual_basic', doc='')
@xw.arg('char_visual_basic', doc='')
@xw.arg('cint_visual_basic', doc='')
@xw.arg('class_visual_basic', doc='')
@xw.arg('clng_visual_basic', doc='')
@xw.arg('cobj_visual_basic', doc='')
@xw.arg('const_visual_basic', doc='')
@xw.arg('continue_visual_basic', doc='')
@xw.arg('csbyte_visual_basic', doc='')
@xw.arg('cshort_visual_basic', doc='')
@xw.arg('csng_visual_basic', doc='')
@xw.arg('cstr_visual_basic', doc='')
@xw.arg('ctype_visual_basic', doc='')
@xw.arg('cuint_visual_basic', doc='')
@xw.arg('culng_visual_basic', doc='')
@xw.arg('currency_visual_basic', doc='')
@xw.arg('cushort_visual_basic', doc='')
@xw.arg('date_visual_basic', doc='')
@xw.arg('decimal_visual_basic', doc='')
@xw.arg('declare_visual_basic', doc='')
@xw.arg('default_visual_basic', doc='')
@xw.arg('delegate_visual_basic', doc='')
@xw.arg('dim_visual_basic', doc='')
@xw.arg('directcast_visual_basic', doc='')
@xw.arg('do_visual_basic', doc='')
@xw.arg('double_visual_basic', doc='')
@xw.arg('each_visual_basic', doc='')
@xw.arg('else_visual_basic', doc='')
@xw.arg('elseif_visual_basic', doc='')
@xw.arg('end_visual_basic', doc='')
@xw.arg('endif_visual_basic', doc='')
@xw.arg('enum_visual_basic', doc='')
@xw.arg('erase_visual_basic', doc='')
@xw.arg('error_visual_basic', doc='')
@xw.arg('event_visual_basic', doc='')
@xw.arg('exit_visual_basic', doc='')
@xw.arg('finally_visual_basic', doc='')
@xw.arg('for_visual_basic', doc='')
@xw.arg('friend_visual_basic', doc='')
@xw.arg('function_visual_basic', doc='')
@xw.arg('get_visual_basic', doc='')
@xw.arg('gettype_visual_basic', doc='')
@xw.arg('getxmlnamespace_visual_basic', doc='')
@xw.arg('global_visual_basic', doc='')
@xw.arg('gosub_visual_basic', doc='')
@xw.arg('goto_visual_basic', doc='')
@xw.arg('handles_visual_basic', doc='')
@xw.arg('if_visual_basic', doc='')
@xw.arg('implements_visual_basic', doc='')
@xw.arg('imports_visual_basic', doc='')
@xw.arg('in_visual_basic', doc='')
@xw.arg('inherits_visual_basic', doc='')
@xw.arg('integer_visual_basic', doc='')
@xw.arg('interface_visual_basic', doc='')
@xw.arg('is_visual_basic', doc='')
@xw.arg('isnot_visual_basic', doc='')
@xw.arg('let_visual_basic', doc='')
@xw.arg('lib_visual_basic', doc='')
@xw.arg('like_visual_basic', doc='')
@xw.arg('long_visual_basic', doc='')
@xw.arg('loop_visual_basic', doc='')
@xw.arg('me_visual_basic', doc='')
@xw.arg('mod_visual_basic', doc='')
@xw.arg('module_visual_basic', doc='')
@xw.arg('mustinherit_visual_basic', doc='')
@xw.arg('mustoverride_visual_basic', doc='')
@xw.arg('mybase_visual_basic', doc='')
@xw.arg('myclass_visual_basic', doc='')
@xw.arg('namespace_visual_basic', doc='')
@xw.arg('narrowing_visual_basic', doc='')
@xw.arg('new_visual_basic', doc='')
@xw.arg('next_visual_basic', doc='')
@xw.arg('not_visual_basic', doc='')
@xw.arg('nothing_visual_basic', doc='')
@xw.arg('notinheritable_visual_basic', doc='')
@xw.arg('notoverridable_visual_basic', doc='')
@xw.arg('object_visual_basic', doc='')
@xw.arg('of_visual_basic', doc='')
@xw.arg('on_visual_basic', doc='')
@xw.arg('operator_visual_basic', doc='')
@xw.arg('option_visual_basic', doc='')
@xw.arg('optional_visual_basic', doc='')
@xw.arg('or_visual_basic', doc='')
@xw.arg('orelse_visual_basic', doc='')
@xw.arg('overloads_visual_basic', doc='')
@xw.arg('overridable_visual_basic', doc='')
@xw.arg('overrides_visual_basic', doc='')
@xw.arg('paramarray_visual_basic', doc='')
@xw.arg('partial_visual_basic', doc='')
@xw.arg('private_visual_basic', doc='')
@xw.arg('property_visual_basic', doc='')
@xw.arg('protected_visual_basic', doc='')
@xw.arg('public_visual_basic', doc='')
@xw.arg('raiseevent_visual_basic', doc='')
@xw.arg('readonly_visual_basic', doc='')
@xw.arg('redim_visual_basic', doc='')
@xw.arg('rem_visual_basic', doc='')
@xw.arg('removehandler_visual_basic', doc='')
@xw.arg('resume_visual_basic', doc='')
@xw.arg('return_visual_basic', doc='')
@xw.arg('sbyte_visual_basic', doc='')
@xw.arg('select_visual_basic', doc='')
@xw.arg('set_visual_basic', doc='')
@xw.arg('shadows_visual_basic', doc='')
@xw.arg('shared_visual_basic', doc='')
@xw.arg('short_visual_basic', doc='')
@xw.arg('single_visual_basic', doc='')
@xw.arg('static_visual_basic', doc='')
@xw.arg('step_visual_basic', doc='')
@xw.arg('stop_visual_basic', doc='')
@xw.arg('string_visual_basic', doc='')
@xw.arg('structure_visual_basic', doc='')
@xw.arg('sub_visual_basic', doc='')
@xw.arg('synclock_visual_basic', doc='')
@xw.arg('then_visual_basic', doc='')
@xw.arg('throw_visual_basic', doc='')
@xw.arg('to_visual_basic', doc='')
@xw.arg('try_visual_basic', doc='')
@xw.arg('trycast_visual_basic', doc='')
@xw.arg('type_visual_basic', doc='')
@xw.arg('typeof_visual_basic', doc='')
@xw.arg('uinteger_visual_basic', doc='')
@xw.arg('ulong_visual_basic', doc='')
@xw.arg('ushort_visual_basic', doc='')
@xw.arg('using_visual_basic', doc='')
@xw.arg('variant_visual_basic', doc='')
@xw.arg('wend_visual_basic', doc='')
@xw.arg('when_visual_basic', doc='')
@xw.arg('while_visual_basic', doc='')
@xw.arg('widening_visual_basic', doc='')
@xw.arg('with_visual_basic', doc='')
@xw.arg('withevents_visual_basic', doc='')
@xw.arg('writeonly_visual_basic', doc='')
@xw.arg('xor_visual_basic', doc='')
@xw.ret(expand='table')
def vba_keywords_test_post_test_vba_restricted_keywords(addhandler_visual_basic, addressof_visual_basic, alias_visual_basic, and_visual_basic, andalso_visual_basic, as_visual_basic, boolean_visual_basic, byref_visual_basic, byte_visual_basic, byval_visual_basic, call_visual_basic, case_visual_basic, catch_visual_basic, cbool_visual_basic, cbyte_visual_basic, cchar_visual_basic, cdate_visual_basic, cdbl_visual_basic, cdec_visual_basic, char_visual_basic, cint_visual_basic, class_visual_basic, clng_visual_basic, cobj_visual_basic, const_visual_basic, continue_visual_basic, csbyte_visual_basic, cshort_visual_basic, csng_visual_basic, cstr_visual_basic, ctype_visual_basic, cuint_visual_basic, culng_visual_basic, currency_visual_basic, cushort_visual_basic, date_visual_basic, decimal_visual_basic, declare_visual_basic, default_visual_basic, delegate_visual_basic, dim_visual_basic, directcast_visual_basic, do_visual_basic, double_visual_basic, each_visual_basic, else_visual_basic, elseif_visual_basic, end_visual_basic, endif_visual_basic, enum_visual_basic, erase_visual_basic, error_visual_basic, event_visual_basic, exit_visual_basic, finally_visual_basic, for_visual_basic, friend_visual_basic, function_visual_basic, get_visual_basic, gettype_visual_basic, getxmlnamespace_visual_basic, global_visual_basic, gosub_visual_basic, goto_visual_basic, handles_visual_basic, if_visual_basic, implements_visual_basic, imports_visual_basic, in_visual_basic, inherits_visual_basic, integer_visual_basic, interface_visual_basic, is_visual_basic, isnot_visual_basic, let_visual_basic, lib_visual_basic, like_visual_basic, long_visual_basic, loop_visual_basic, me_visual_basic, mod_visual_basic, module_visual_basic, mustinherit_visual_basic, mustoverride_visual_basic, mybase_visual_basic, myclass_visual_basic, namespace_visual_basic, narrowing_visual_basic, new_visual_basic, next_visual_basic, not_visual_basic, nothing_visual_basic, notinheritable_visual_basic, notoverridable_visual_basic, object_visual_basic, of_visual_basic, on_visual_basic, operator_visual_basic, option_visual_basic, optional_visual_basic, or_visual_basic, orelse_visual_basic, overloads_visual_basic, overridable_visual_basic, overrides_visual_basic, paramarray_visual_basic, partial_visual_basic, private_visual_basic, property_visual_basic, protected_visual_basic, public_visual_basic, raiseevent_visual_basic, readonly_visual_basic, redim_visual_basic, rem_visual_basic, removehandler_visual_basic, resume_visual_basic, return_visual_basic, sbyte_visual_basic, select_visual_basic, set_visual_basic, shadows_visual_basic, shared_visual_basic, short_visual_basic, single_visual_basic, static_visual_basic, step_visual_basic, stop_visual_basic, string_visual_basic, structure_visual_basic, sub_visual_basic, synclock_visual_basic, then_visual_basic, throw_visual_basic, to_visual_basic, try_visual_basic, trycast_visual_basic, type_visual_basic, typeof_visual_basic, uinteger_visual_basic, ulong_visual_basic, ushort_visual_basic, using_visual_basic, variant_visual_basic, wend_visual_basic, when_visual_basic, while_visual_basic, widening_visual_basic, with_visual_basic, withevents_visual_basic, writeonly_visual_basic, xor_visual_basic):
    logger.info("[status=Calling] [function=vba_keywords_test_post_test_vba_restricted_keywords]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if addhandler_visual_basic is None or isinstance(addhandler_visual_basic, list) and all(x is None for x in addhandler_visual_basic):
        logger.error('addhandler_visual_basic is required.')
        return ['addhandler_visual_basic is required.']
    if addhandler_visual_basic is not None:

        request_parameters['addhandler'] = addhandler_visual_basic

    if addressof_visual_basic is None or isinstance(addressof_visual_basic, list) and all(x is None for x in addressof_visual_basic):
        logger.error('addressof_visual_basic is required.')
        return ['addressof_visual_basic is required.']
    if addressof_visual_basic is not None:

        request_parameters['addressof'] = addressof_visual_basic

    if alias_visual_basic is None or isinstance(alias_visual_basic, list) and all(x is None for x in alias_visual_basic):
        logger.error('alias_visual_basic is required.')
        return ['alias_visual_basic is required.']
    if alias_visual_basic is not None:

        request_parameters['alias'] = alias_visual_basic

    if and_visual_basic is None or isinstance(and_visual_basic, list) and all(x is None for x in and_visual_basic):
        logger.error('and_visual_basic is required.')
        return ['and_visual_basic is required.']
    if and_visual_basic is not None:

        request_parameters['and'] = and_visual_basic

    if andalso_visual_basic is None or isinstance(andalso_visual_basic, list) and all(x is None for x in andalso_visual_basic):
        logger.error('andalso_visual_basic is required.')
        return ['andalso_visual_basic is required.']
    if andalso_visual_basic is not None:

        request_parameters['andalso'] = andalso_visual_basic

    if as_visual_basic is None or isinstance(as_visual_basic, list) and all(x is None for x in as_visual_basic):
        logger.error('as_visual_basic is required.')
        return ['as_visual_basic is required.']
    if as_visual_basic is not None:

        request_parameters['as'] = as_visual_basic

    if boolean_visual_basic is None or isinstance(boolean_visual_basic, list) and all(x is None for x in boolean_visual_basic):
        logger.error('boolean_visual_basic is required.')
        return ['boolean_visual_basic is required.']
    if boolean_visual_basic is not None:

        request_parameters['boolean'] = boolean_visual_basic

    if byref_visual_basic is None or isinstance(byref_visual_basic, list) and all(x is None for x in byref_visual_basic):
        logger.error('byref_visual_basic is required.')
        return ['byref_visual_basic is required.']
    if byref_visual_basic is not None:

        request_parameters['byref'] = byref_visual_basic

    if byte_visual_basic is None or isinstance(byte_visual_basic, list) and all(x is None for x in byte_visual_basic):
        logger.error('byte_visual_basic is required.')
        return ['byte_visual_basic is required.']
    if byte_visual_basic is not None:

        request_parameters['byte'] = byte_visual_basic

    if byval_visual_basic is None or isinstance(byval_visual_basic, list) and all(x is None for x in byval_visual_basic):
        logger.error('byval_visual_basic is required.')
        return ['byval_visual_basic is required.']
    if byval_visual_basic is not None:

        request_parameters['byval'] = byval_visual_basic

    if call_visual_basic is None or isinstance(call_visual_basic, list) and all(x is None for x in call_visual_basic):
        logger.error('call_visual_basic is required.')
        return ['call_visual_basic is required.']
    if call_visual_basic is not None:

        request_parameters['call'] = call_visual_basic

    if case_visual_basic is None or isinstance(case_visual_basic, list) and all(x is None for x in case_visual_basic):
        logger.error('case_visual_basic is required.')
        return ['case_visual_basic is required.']
    if case_visual_basic is not None:

        request_parameters['case'] = case_visual_basic

    if catch_visual_basic is None or isinstance(catch_visual_basic, list) and all(x is None for x in catch_visual_basic):
        logger.error('catch_visual_basic is required.')
        return ['catch_visual_basic is required.']
    if catch_visual_basic is not None:

        request_parameters['catch'] = catch_visual_basic

    if cbool_visual_basic is None or isinstance(cbool_visual_basic, list) and all(x is None for x in cbool_visual_basic):
        logger.error('cbool_visual_basic is required.')
        return ['cbool_visual_basic is required.']
    if cbool_visual_basic is not None:

        request_parameters['cbool'] = cbool_visual_basic

    if cbyte_visual_basic is None or isinstance(cbyte_visual_basic, list) and all(x is None for x in cbyte_visual_basic):
        logger.error('cbyte_visual_basic is required.')
        return ['cbyte_visual_basic is required.']
    if cbyte_visual_basic is not None:

        request_parameters['cbyte'] = cbyte_visual_basic

    if cchar_visual_basic is None or isinstance(cchar_visual_basic, list) and all(x is None for x in cchar_visual_basic):
        logger.error('cchar_visual_basic is required.')
        return ['cchar_visual_basic is required.']
    if cchar_visual_basic is not None:

        request_parameters['cchar'] = cchar_visual_basic

    if cdate_visual_basic is None or isinstance(cdate_visual_basic, list) and all(x is None for x in cdate_visual_basic):
        logger.error('cdate_visual_basic is required.')
        return ['cdate_visual_basic is required.']
    if cdate_visual_basic is not None:

        request_parameters['cdate'] = cdate_visual_basic

    if cdbl_visual_basic is None or isinstance(cdbl_visual_basic, list) and all(x is None for x in cdbl_visual_basic):
        logger.error('cdbl_visual_basic is required.')
        return ['cdbl_visual_basic is required.']
    if cdbl_visual_basic is not None:

        request_parameters['cdbl'] = cdbl_visual_basic

    if cdec_visual_basic is None or isinstance(cdec_visual_basic, list) and all(x is None for x in cdec_visual_basic):
        logger.error('cdec_visual_basic is required.')
        return ['cdec_visual_basic is required.']
    if cdec_visual_basic is not None:

        request_parameters['cdec'] = cdec_visual_basic

    if char_visual_basic is None or isinstance(char_visual_basic, list) and all(x is None for x in char_visual_basic):
        logger.error('char_visual_basic is required.')
        return ['char_visual_basic is required.']
    if char_visual_basic is not None:

        request_parameters['char'] = char_visual_basic

    if cint_visual_basic is None or isinstance(cint_visual_basic, list) and all(x is None for x in cint_visual_basic):
        logger.error('cint_visual_basic is required.')
        return ['cint_visual_basic is required.']
    if cint_visual_basic is not None:

        request_parameters['cint'] = cint_visual_basic

    if class_visual_basic is None or isinstance(class_visual_basic, list) and all(x is None for x in class_visual_basic):
        logger.error('class_visual_basic is required.')
        return ['class_visual_basic is required.']
    if class_visual_basic is not None:

        request_parameters['class'] = class_visual_basic

    if clng_visual_basic is None or isinstance(clng_visual_basic, list) and all(x is None for x in clng_visual_basic):
        logger.error('clng_visual_basic is required.')
        return ['clng_visual_basic is required.']
    if clng_visual_basic is not None:

        request_parameters['clng'] = clng_visual_basic

    if cobj_visual_basic is None or isinstance(cobj_visual_basic, list) and all(x is None for x in cobj_visual_basic):
        logger.error('cobj_visual_basic is required.')
        return ['cobj_visual_basic is required.']
    if cobj_visual_basic is not None:

        request_parameters['cobj'] = cobj_visual_basic

    if const_visual_basic is None or isinstance(const_visual_basic, list) and all(x is None for x in const_visual_basic):
        logger.error('const_visual_basic is required.')
        return ['const_visual_basic is required.']
    if const_visual_basic is not None:

        request_parameters['const'] = const_visual_basic

    if continue_visual_basic is None or isinstance(continue_visual_basic, list) and all(x is None for x in continue_visual_basic):
        logger.error('continue_visual_basic is required.')
        return ['continue_visual_basic is required.']
    if continue_visual_basic is not None:

        request_parameters['continue'] = continue_visual_basic

    if csbyte_visual_basic is None or isinstance(csbyte_visual_basic, list) and all(x is None for x in csbyte_visual_basic):
        logger.error('csbyte_visual_basic is required.')
        return ['csbyte_visual_basic is required.']
    if csbyte_visual_basic is not None:

        request_parameters['csbyte'] = csbyte_visual_basic

    if cshort_visual_basic is None or isinstance(cshort_visual_basic, list) and all(x is None for x in cshort_visual_basic):
        logger.error('cshort_visual_basic is required.')
        return ['cshort_visual_basic is required.']
    if cshort_visual_basic is not None:

        request_parameters['cshort'] = cshort_visual_basic

    if csng_visual_basic is None or isinstance(csng_visual_basic, list) and all(x is None for x in csng_visual_basic):
        logger.error('csng_visual_basic is required.')
        return ['csng_visual_basic is required.']
    if csng_visual_basic is not None:

        request_parameters['csng'] = csng_visual_basic

    if cstr_visual_basic is None or isinstance(cstr_visual_basic, list) and all(x is None for x in cstr_visual_basic):
        logger.error('cstr_visual_basic is required.')
        return ['cstr_visual_basic is required.']
    if cstr_visual_basic is not None:

        request_parameters['cstr'] = cstr_visual_basic

    if ctype_visual_basic is None or isinstance(ctype_visual_basic, list) and all(x is None for x in ctype_visual_basic):
        logger.error('ctype_visual_basic is required.')
        return ['ctype_visual_basic is required.']
    if ctype_visual_basic is not None:

        request_parameters['ctype'] = ctype_visual_basic

    if cuint_visual_basic is None or isinstance(cuint_visual_basic, list) and all(x is None for x in cuint_visual_basic):
        logger.error('cuint_visual_basic is required.')
        return ['cuint_visual_basic is required.']
    if cuint_visual_basic is not None:

        request_parameters['cuint'] = cuint_visual_basic

    if culng_visual_basic is None or isinstance(culng_visual_basic, list) and all(x is None for x in culng_visual_basic):
        logger.error('culng_visual_basic is required.')
        return ['culng_visual_basic is required.']
    if culng_visual_basic is not None:

        request_parameters['culng'] = culng_visual_basic

    if currency_visual_basic is None or isinstance(currency_visual_basic, list) and all(x is None for x in currency_visual_basic):
        logger.error('currency_visual_basic is required.')
        return ['currency_visual_basic is required.']
    if currency_visual_basic is not None:

        request_parameters['currency'] = currency_visual_basic

    if cushort_visual_basic is None or isinstance(cushort_visual_basic, list) and all(x is None for x in cushort_visual_basic):
        logger.error('cushort_visual_basic is required.')
        return ['cushort_visual_basic is required.']
    if cushort_visual_basic is not None:

        request_parameters['cushort'] = cushort_visual_basic

    if date_visual_basic is None or isinstance(date_visual_basic, list) and all(x is None for x in date_visual_basic):
        logger.error('date_visual_basic is required.')
        return ['date_visual_basic is required.']
    if date_visual_basic is not None:

        request_parameters['date'] = date_visual_basic

    if decimal_visual_basic is None or isinstance(decimal_visual_basic, list) and all(x is None for x in decimal_visual_basic):
        logger.error('decimal_visual_basic is required.')
        return ['decimal_visual_basic is required.']
    if decimal_visual_basic is not None:

        request_parameters['decimal'] = decimal_visual_basic

    if declare_visual_basic is None or isinstance(declare_visual_basic, list) and all(x is None for x in declare_visual_basic):
        logger.error('declare_visual_basic is required.')
        return ['declare_visual_basic is required.']
    if declare_visual_basic is not None:

        request_parameters['declare'] = declare_visual_basic

    if default_visual_basic is None or isinstance(default_visual_basic, list) and all(x is None for x in default_visual_basic):
        logger.error('default_visual_basic is required.')
        return ['default_visual_basic is required.']
    if default_visual_basic is not None:

        request_parameters['default'] = default_visual_basic

    if delegate_visual_basic is None or isinstance(delegate_visual_basic, list) and all(x is None for x in delegate_visual_basic):
        logger.error('delegate_visual_basic is required.')
        return ['delegate_visual_basic is required.']
    if delegate_visual_basic is not None:

        request_parameters['delegate'] = delegate_visual_basic

    if dim_visual_basic is None or isinstance(dim_visual_basic, list) and all(x is None for x in dim_visual_basic):
        logger.error('dim_visual_basic is required.')
        return ['dim_visual_basic is required.']
    if dim_visual_basic is not None:

        request_parameters['dim'] = dim_visual_basic

    if directcast_visual_basic is None or isinstance(directcast_visual_basic, list) and all(x is None for x in directcast_visual_basic):
        logger.error('directcast_visual_basic is required.')
        return ['directcast_visual_basic is required.']
    if directcast_visual_basic is not None:

        request_parameters['directcast'] = directcast_visual_basic

    if do_visual_basic is None or isinstance(do_visual_basic, list) and all(x is None for x in do_visual_basic):
        logger.error('do_visual_basic is required.')
        return ['do_visual_basic is required.']
    if do_visual_basic is not None:

        request_parameters['do'] = do_visual_basic

    if double_visual_basic is None or isinstance(double_visual_basic, list) and all(x is None for x in double_visual_basic):
        logger.error('double_visual_basic is required.')
        return ['double_visual_basic is required.']
    if double_visual_basic is not None:

        request_parameters['double'] = double_visual_basic

    if each_visual_basic is None or isinstance(each_visual_basic, list) and all(x is None for x in each_visual_basic):
        logger.error('each_visual_basic is required.')
        return ['each_visual_basic is required.']
    if each_visual_basic is not None:

        request_parameters['each'] = each_visual_basic

    if else_visual_basic is None or isinstance(else_visual_basic, list) and all(x is None for x in else_visual_basic):
        logger.error('else_visual_basic is required.')
        return ['else_visual_basic is required.']
    if else_visual_basic is not None:

        request_parameters['else'] = else_visual_basic

    if elseif_visual_basic is None or isinstance(elseif_visual_basic, list) and all(x is None for x in elseif_visual_basic):
        logger.error('elseif_visual_basic is required.')
        return ['elseif_visual_basic is required.']
    if elseif_visual_basic is not None:

        request_parameters['elseif'] = elseif_visual_basic

    if end_visual_basic is None or isinstance(end_visual_basic, list) and all(x is None for x in end_visual_basic):
        logger.error('end_visual_basic is required.')
        return ['end_visual_basic is required.']
    if end_visual_basic is not None:

        request_parameters['end'] = end_visual_basic

    if endif_visual_basic is None or isinstance(endif_visual_basic, list) and all(x is None for x in endif_visual_basic):
        logger.error('endif_visual_basic is required.')
        return ['endif_visual_basic is required.']
    if endif_visual_basic is not None:

        request_parameters['endif'] = endif_visual_basic

    if enum_visual_basic is None or isinstance(enum_visual_basic, list) and all(x is None for x in enum_visual_basic):
        logger.error('enum_visual_basic is required.')
        return ['enum_visual_basic is required.']
    if enum_visual_basic is not None:

        request_parameters['enum'] = enum_visual_basic

    if erase_visual_basic is None or isinstance(erase_visual_basic, list) and all(x is None for x in erase_visual_basic):
        logger.error('erase_visual_basic is required.')
        return ['erase_visual_basic is required.']
    if erase_visual_basic is not None:

        request_parameters['erase'] = erase_visual_basic

    if error_visual_basic is None or isinstance(error_visual_basic, list) and all(x is None for x in error_visual_basic):
        logger.error('error_visual_basic is required.')
        return ['error_visual_basic is required.']
    if error_visual_basic is not None:

        request_parameters['error'] = error_visual_basic

    if event_visual_basic is None or isinstance(event_visual_basic, list) and all(x is None for x in event_visual_basic):
        logger.error('event_visual_basic is required.')
        return ['event_visual_basic is required.']
    if event_visual_basic is not None:

        request_parameters['event'] = event_visual_basic

    if exit_visual_basic is None or isinstance(exit_visual_basic, list) and all(x is None for x in exit_visual_basic):
        logger.error('exit_visual_basic is required.')
        return ['exit_visual_basic is required.']
    if exit_visual_basic is not None:

        request_parameters['exit'] = exit_visual_basic

    if finally_visual_basic is None or isinstance(finally_visual_basic, list) and all(x is None for x in finally_visual_basic):
        logger.error('finally_visual_basic is required.')
        return ['finally_visual_basic is required.']
    if finally_visual_basic is not None:

        request_parameters['finally'] = finally_visual_basic

    if for_visual_basic is None or isinstance(for_visual_basic, list) and all(x is None for x in for_visual_basic):
        logger.error('for_visual_basic is required.')
        return ['for_visual_basic is required.']
    if for_visual_basic is not None:

        request_parameters['for'] = for_visual_basic

    if friend_visual_basic is None or isinstance(friend_visual_basic, list) and all(x is None for x in friend_visual_basic):
        logger.error('friend_visual_basic is required.')
        return ['friend_visual_basic is required.']
    if friend_visual_basic is not None:

        request_parameters['friend'] = friend_visual_basic

    if function_visual_basic is None or isinstance(function_visual_basic, list) and all(x is None for x in function_visual_basic):
        logger.error('function_visual_basic is required.')
        return ['function_visual_basic is required.']
    if function_visual_basic is not None:

        request_parameters['function'] = function_visual_basic

    if get_visual_basic is None or isinstance(get_visual_basic, list) and all(x is None for x in get_visual_basic):
        logger.error('get_visual_basic is required.')
        return ['get_visual_basic is required.']
    if get_visual_basic is not None:

        request_parameters['get'] = get_visual_basic

    if gettype_visual_basic is None or isinstance(gettype_visual_basic, list) and all(x is None for x in gettype_visual_basic):
        logger.error('gettype_visual_basic is required.')
        return ['gettype_visual_basic is required.']
    if gettype_visual_basic is not None:

        request_parameters['gettype'] = gettype_visual_basic

    if getxmlnamespace_visual_basic is None or isinstance(getxmlnamespace_visual_basic, list) and all(x is None for x in getxmlnamespace_visual_basic):
        logger.error('getxmlnamespace_visual_basic is required.')
        return ['getxmlnamespace_visual_basic is required.']
    if getxmlnamespace_visual_basic is not None:

        request_parameters['getxmlnamespace'] = getxmlnamespace_visual_basic

    if global_visual_basic is None or isinstance(global_visual_basic, list) and all(x is None for x in global_visual_basic):
        logger.error('global_visual_basic is required.')
        return ['global_visual_basic is required.']
    if global_visual_basic is not None:

        request_parameters['global'] = global_visual_basic

    if gosub_visual_basic is None or isinstance(gosub_visual_basic, list) and all(x is None for x in gosub_visual_basic):
        logger.error('gosub_visual_basic is required.')
        return ['gosub_visual_basic is required.']
    if gosub_visual_basic is not None:

        request_parameters['gosub'] = gosub_visual_basic

    if goto_visual_basic is None or isinstance(goto_visual_basic, list) and all(x is None for x in goto_visual_basic):
        logger.error('goto_visual_basic is required.')
        return ['goto_visual_basic is required.']
    if goto_visual_basic is not None:

        request_parameters['goto'] = goto_visual_basic

    if handles_visual_basic is None or isinstance(handles_visual_basic, list) and all(x is None for x in handles_visual_basic):
        logger.error('handles_visual_basic is required.')
        return ['handles_visual_basic is required.']
    if handles_visual_basic is not None:

        request_parameters['handles'] = handles_visual_basic

    if if_visual_basic is None or isinstance(if_visual_basic, list) and all(x is None for x in if_visual_basic):
        logger.error('if_visual_basic is required.')
        return ['if_visual_basic is required.']
    if if_visual_basic is not None:

        request_parameters['if'] = if_visual_basic

    if implements_visual_basic is None or isinstance(implements_visual_basic, list) and all(x is None for x in implements_visual_basic):
        logger.error('implements_visual_basic is required.')
        return ['implements_visual_basic is required.']
    if implements_visual_basic is not None:

        request_parameters['implements'] = implements_visual_basic

    if imports_visual_basic is None or isinstance(imports_visual_basic, list) and all(x is None for x in imports_visual_basic):
        logger.error('imports_visual_basic is required.')
        return ['imports_visual_basic is required.']
    if imports_visual_basic is not None:

        request_parameters['imports'] = imports_visual_basic

    if in_visual_basic is None or isinstance(in_visual_basic, list) and all(x is None for x in in_visual_basic):
        logger.error('in_visual_basic is required.')
        return ['in_visual_basic is required.']
    if in_visual_basic is not None:

        request_parameters['in'] = in_visual_basic

    if inherits_visual_basic is None or isinstance(inherits_visual_basic, list) and all(x is None for x in inherits_visual_basic):
        logger.error('inherits_visual_basic is required.')
        return ['inherits_visual_basic is required.']
    if inherits_visual_basic is not None:

        request_parameters['inherits'] = inherits_visual_basic

    if integer_visual_basic is None or isinstance(integer_visual_basic, list) and all(x is None for x in integer_visual_basic):
        logger.error('integer_visual_basic is required.')
        return ['integer_visual_basic is required.']
    if integer_visual_basic is not None:

        request_parameters['integer'] = integer_visual_basic

    if interface_visual_basic is None or isinstance(interface_visual_basic, list) and all(x is None for x in interface_visual_basic):
        logger.error('interface_visual_basic is required.')
        return ['interface_visual_basic is required.']
    if interface_visual_basic is not None:

        request_parameters['interface'] = interface_visual_basic

    if is_visual_basic is None or isinstance(is_visual_basic, list) and all(x is None for x in is_visual_basic):
        logger.error('is_visual_basic is required.')
        return ['is_visual_basic is required.']
    if is_visual_basic is not None:

        request_parameters['is'] = is_visual_basic

    if isnot_visual_basic is None or isinstance(isnot_visual_basic, list) and all(x is None for x in isnot_visual_basic):
        logger.error('isnot_visual_basic is required.')
        return ['isnot_visual_basic is required.']
    if isnot_visual_basic is not None:

        request_parameters['isnot'] = isnot_visual_basic

    if let_visual_basic is None or isinstance(let_visual_basic, list) and all(x is None for x in let_visual_basic):
        logger.error('let_visual_basic is required.')
        return ['let_visual_basic is required.']
    if let_visual_basic is not None:

        request_parameters['let'] = let_visual_basic

    if lib_visual_basic is None or isinstance(lib_visual_basic, list) and all(x is None for x in lib_visual_basic):
        logger.error('lib_visual_basic is required.')
        return ['lib_visual_basic is required.']
    if lib_visual_basic is not None:

        request_parameters['lib'] = lib_visual_basic

    if like_visual_basic is None or isinstance(like_visual_basic, list) and all(x is None for x in like_visual_basic):
        logger.error('like_visual_basic is required.')
        return ['like_visual_basic is required.']
    if like_visual_basic is not None:

        request_parameters['like'] = like_visual_basic

    if long_visual_basic is None or isinstance(long_visual_basic, list) and all(x is None for x in long_visual_basic):
        logger.error('long_visual_basic is required.')
        return ['long_visual_basic is required.']
    if long_visual_basic is not None:

        request_parameters['long'] = long_visual_basic

    if loop_visual_basic is None or isinstance(loop_visual_basic, list) and all(x is None for x in loop_visual_basic):
        logger.error('loop_visual_basic is required.')
        return ['loop_visual_basic is required.']
    if loop_visual_basic is not None:

        request_parameters['loop'] = loop_visual_basic

    if me_visual_basic is None or isinstance(me_visual_basic, list) and all(x is None for x in me_visual_basic):
        logger.error('me_visual_basic is required.')
        return ['me_visual_basic is required.']
    if me_visual_basic is not None:

        request_parameters['me'] = me_visual_basic

    if mod_visual_basic is None or isinstance(mod_visual_basic, list) and all(x is None for x in mod_visual_basic):
        logger.error('mod_visual_basic is required.')
        return ['mod_visual_basic is required.']
    if mod_visual_basic is not None:

        request_parameters['mod'] = mod_visual_basic

    if module_visual_basic is None or isinstance(module_visual_basic, list) and all(x is None for x in module_visual_basic):
        logger.error('module_visual_basic is required.')
        return ['module_visual_basic is required.']
    if module_visual_basic is not None:

        request_parameters['module'] = module_visual_basic

    if mustinherit_visual_basic is None or isinstance(mustinherit_visual_basic, list) and all(x is None for x in mustinherit_visual_basic):
        logger.error('mustinherit_visual_basic is required.')
        return ['mustinherit_visual_basic is required.']
    if mustinherit_visual_basic is not None:

        request_parameters['mustinherit'] = mustinherit_visual_basic

    if mustoverride_visual_basic is None or isinstance(mustoverride_visual_basic, list) and all(x is None for x in mustoverride_visual_basic):
        logger.error('mustoverride_visual_basic is required.')
        return ['mustoverride_visual_basic is required.']
    if mustoverride_visual_basic is not None:

        request_parameters['mustoverride'] = mustoverride_visual_basic

    if mybase_visual_basic is None or isinstance(mybase_visual_basic, list) and all(x is None for x in mybase_visual_basic):
        logger.error('mybase_visual_basic is required.')
        return ['mybase_visual_basic is required.']
    if mybase_visual_basic is not None:

        request_parameters['mybase'] = mybase_visual_basic

    if myclass_visual_basic is None or isinstance(myclass_visual_basic, list) and all(x is None for x in myclass_visual_basic):
        logger.error('myclass_visual_basic is required.')
        return ['myclass_visual_basic is required.']
    if myclass_visual_basic is not None:

        request_parameters['myclass'] = myclass_visual_basic

    if namespace_visual_basic is None or isinstance(namespace_visual_basic, list) and all(x is None for x in namespace_visual_basic):
        logger.error('namespace_visual_basic is required.')
        return ['namespace_visual_basic is required.']
    if namespace_visual_basic is not None:

        request_parameters['namespace'] = namespace_visual_basic

    if narrowing_visual_basic is None or isinstance(narrowing_visual_basic, list) and all(x is None for x in narrowing_visual_basic):
        logger.error('narrowing_visual_basic is required.')
        return ['narrowing_visual_basic is required.']
    if narrowing_visual_basic is not None:

        request_parameters['narrowing'] = narrowing_visual_basic

    if new_visual_basic is None or isinstance(new_visual_basic, list) and all(x is None for x in new_visual_basic):
        logger.error('new_visual_basic is required.')
        return ['new_visual_basic is required.']
    if new_visual_basic is not None:

        request_parameters['new'] = new_visual_basic

    if next_visual_basic is None or isinstance(next_visual_basic, list) and all(x is None for x in next_visual_basic):
        logger.error('next_visual_basic is required.')
        return ['next_visual_basic is required.']
    if next_visual_basic is not None:

        request_parameters['next'] = next_visual_basic

    if not_visual_basic is None or isinstance(not_visual_basic, list) and all(x is None for x in not_visual_basic):
        logger.error('not_visual_basic is required.')
        return ['not_visual_basic is required.']
    if not_visual_basic is not None:

        request_parameters['not'] = not_visual_basic

    if nothing_visual_basic is None or isinstance(nothing_visual_basic, list) and all(x is None for x in nothing_visual_basic):
        logger.error('nothing_visual_basic is required.')
        return ['nothing_visual_basic is required.']
    if nothing_visual_basic is not None:

        request_parameters['nothing'] = nothing_visual_basic

    if notinheritable_visual_basic is None or isinstance(notinheritable_visual_basic, list) and all(x is None for x in notinheritable_visual_basic):
        logger.error('notinheritable_visual_basic is required.')
        return ['notinheritable_visual_basic is required.']
    if notinheritable_visual_basic is not None:

        request_parameters['notinheritable'] = notinheritable_visual_basic

    if notoverridable_visual_basic is None or isinstance(notoverridable_visual_basic, list) and all(x is None for x in notoverridable_visual_basic):
        logger.error('notoverridable_visual_basic is required.')
        return ['notoverridable_visual_basic is required.']
    if notoverridable_visual_basic is not None:

        request_parameters['notoverridable'] = notoverridable_visual_basic

    if object_visual_basic is None or isinstance(object_visual_basic, list) and all(x is None for x in object_visual_basic):
        logger.error('object_visual_basic is required.')
        return ['object_visual_basic is required.']
    if object_visual_basic is not None:

        request_parameters['object'] = object_visual_basic

    if of_visual_basic is None or isinstance(of_visual_basic, list) and all(x is None for x in of_visual_basic):
        logger.error('of_visual_basic is required.')
        return ['of_visual_basic is required.']
    if of_visual_basic is not None:

        request_parameters['of'] = of_visual_basic

    if on_visual_basic is None or isinstance(on_visual_basic, list) and all(x is None for x in on_visual_basic):
        logger.error('on_visual_basic is required.')
        return ['on_visual_basic is required.']
    if on_visual_basic is not None:

        request_parameters['on'] = on_visual_basic

    if operator_visual_basic is None or isinstance(operator_visual_basic, list) and all(x is None for x in operator_visual_basic):
        logger.error('operator_visual_basic is required.')
        return ['operator_visual_basic is required.']
    if operator_visual_basic is not None:

        request_parameters['operator'] = operator_visual_basic

    if option_visual_basic is None or isinstance(option_visual_basic, list) and all(x is None for x in option_visual_basic):
        logger.error('option_visual_basic is required.')
        return ['option_visual_basic is required.']
    if option_visual_basic is not None:

        request_parameters['option'] = option_visual_basic

    if optional_visual_basic is None or isinstance(optional_visual_basic, list) and all(x is None for x in optional_visual_basic):
        logger.error('optional_visual_basic is required.')
        return ['optional_visual_basic is required.']
    if optional_visual_basic is not None:

        request_parameters['optional'] = optional_visual_basic

    if or_visual_basic is None or isinstance(or_visual_basic, list) and all(x is None for x in or_visual_basic):
        logger.error('or_visual_basic is required.')
        return ['or_visual_basic is required.']
    if or_visual_basic is not None:

        request_parameters['or'] = or_visual_basic

    if orelse_visual_basic is None or isinstance(orelse_visual_basic, list) and all(x is None for x in orelse_visual_basic):
        logger.error('orelse_visual_basic is required.')
        return ['orelse_visual_basic is required.']
    if orelse_visual_basic is not None:

        request_parameters['orelse'] = orelse_visual_basic

    if overloads_visual_basic is None or isinstance(overloads_visual_basic, list) and all(x is None for x in overloads_visual_basic):
        logger.error('overloads_visual_basic is required.')
        return ['overloads_visual_basic is required.']
    if overloads_visual_basic is not None:

        request_parameters['overloads'] = overloads_visual_basic

    if overridable_visual_basic is None or isinstance(overridable_visual_basic, list) and all(x is None for x in overridable_visual_basic):
        logger.error('overridable_visual_basic is required.')
        return ['overridable_visual_basic is required.']
    if overridable_visual_basic is not None:

        request_parameters['overridable'] = overridable_visual_basic

    if overrides_visual_basic is None or isinstance(overrides_visual_basic, list) and all(x is None for x in overrides_visual_basic):
        logger.error('overrides_visual_basic is required.')
        return ['overrides_visual_basic is required.']
    if overrides_visual_basic is not None:

        request_parameters['overrides'] = overrides_visual_basic

    if paramarray_visual_basic is None or isinstance(paramarray_visual_basic, list) and all(x is None for x in paramarray_visual_basic):
        logger.error('paramarray_visual_basic is required.')
        return ['paramarray_visual_basic is required.']
    if paramarray_visual_basic is not None:

        request_parameters['paramarray'] = paramarray_visual_basic

    if partial_visual_basic is None or isinstance(partial_visual_basic, list) and all(x is None for x in partial_visual_basic):
        logger.error('partial_visual_basic is required.')
        return ['partial_visual_basic is required.']
    if partial_visual_basic is not None:

        request_parameters['partial'] = partial_visual_basic

    if private_visual_basic is None or isinstance(private_visual_basic, list) and all(x is None for x in private_visual_basic):
        logger.error('private_visual_basic is required.')
        return ['private_visual_basic is required.']
    if private_visual_basic is not None:

        request_parameters['private'] = private_visual_basic

    if property_visual_basic is None or isinstance(property_visual_basic, list) and all(x is None for x in property_visual_basic):
        logger.error('property_visual_basic is required.')
        return ['property_visual_basic is required.']
    if property_visual_basic is not None:

        request_parameters['property'] = property_visual_basic

    if protected_visual_basic is None or isinstance(protected_visual_basic, list) and all(x is None for x in protected_visual_basic):
        logger.error('protected_visual_basic is required.')
        return ['protected_visual_basic is required.']
    if protected_visual_basic is not None:

        request_parameters['protected'] = protected_visual_basic

    if public_visual_basic is None or isinstance(public_visual_basic, list) and all(x is None for x in public_visual_basic):
        logger.error('public_visual_basic is required.')
        return ['public_visual_basic is required.']
    if public_visual_basic is not None:

        request_parameters['public'] = public_visual_basic

    if raiseevent_visual_basic is None or isinstance(raiseevent_visual_basic, list) and all(x is None for x in raiseevent_visual_basic):
        logger.error('raiseevent_visual_basic is required.')
        return ['raiseevent_visual_basic is required.']
    if raiseevent_visual_basic is not None:

        request_parameters['raiseevent'] = raiseevent_visual_basic

    if readonly_visual_basic is None or isinstance(readonly_visual_basic, list) and all(x is None for x in readonly_visual_basic):
        logger.error('readonly_visual_basic is required.')
        return ['readonly_visual_basic is required.']
    if readonly_visual_basic is not None:

        request_parameters['readonly'] = readonly_visual_basic

    if redim_visual_basic is None or isinstance(redim_visual_basic, list) and all(x is None for x in redim_visual_basic):
        logger.error('redim_visual_basic is required.')
        return ['redim_visual_basic is required.']
    if redim_visual_basic is not None:

        request_parameters['redim'] = redim_visual_basic

    if rem_visual_basic is None or isinstance(rem_visual_basic, list) and all(x is None for x in rem_visual_basic):
        logger.error('rem_visual_basic is required.')
        return ['rem_visual_basic is required.']
    if rem_visual_basic is not None:

        request_parameters['rem'] = rem_visual_basic

    if removehandler_visual_basic is None or isinstance(removehandler_visual_basic, list) and all(x is None for x in removehandler_visual_basic):
        logger.error('removehandler_visual_basic is required.')
        return ['removehandler_visual_basic is required.']
    if removehandler_visual_basic is not None:

        request_parameters['removehandler'] = removehandler_visual_basic

    if resume_visual_basic is None or isinstance(resume_visual_basic, list) and all(x is None for x in resume_visual_basic):
        logger.error('resume_visual_basic is required.')
        return ['resume_visual_basic is required.']
    if resume_visual_basic is not None:

        request_parameters['resume'] = resume_visual_basic

    if return_visual_basic is None or isinstance(return_visual_basic, list) and all(x is None for x in return_visual_basic):
        logger.error('return_visual_basic is required.')
        return ['return_visual_basic is required.']
    if return_visual_basic is not None:

        request_parameters['return'] = return_visual_basic

    if sbyte_visual_basic is None or isinstance(sbyte_visual_basic, list) and all(x is None for x in sbyte_visual_basic):
        logger.error('sbyte_visual_basic is required.')
        return ['sbyte_visual_basic is required.']
    if sbyte_visual_basic is not None:

        request_parameters['sbyte'] = sbyte_visual_basic

    if select_visual_basic is None or isinstance(select_visual_basic, list) and all(x is None for x in select_visual_basic):
        logger.error('select_visual_basic is required.')
        return ['select_visual_basic is required.']
    if select_visual_basic is not None:

        request_parameters['select'] = select_visual_basic

    if set_visual_basic is None or isinstance(set_visual_basic, list) and all(x is None for x in set_visual_basic):
        logger.error('set_visual_basic is required.')
        return ['set_visual_basic is required.']
    if set_visual_basic is not None:

        request_parameters['set'] = set_visual_basic

    if shadows_visual_basic is None or isinstance(shadows_visual_basic, list) and all(x is None for x in shadows_visual_basic):
        logger.error('shadows_visual_basic is required.')
        return ['shadows_visual_basic is required.']
    if shadows_visual_basic is not None:

        request_parameters['shadows'] = shadows_visual_basic

    if shared_visual_basic is None or isinstance(shared_visual_basic, list) and all(x is None for x in shared_visual_basic):
        logger.error('shared_visual_basic is required.')
        return ['shared_visual_basic is required.']
    if shared_visual_basic is not None:

        request_parameters['shared'] = shared_visual_basic

    if short_visual_basic is None or isinstance(short_visual_basic, list) and all(x is None for x in short_visual_basic):
        logger.error('short_visual_basic is required.')
        return ['short_visual_basic is required.']
    if short_visual_basic is not None:

        request_parameters['short'] = short_visual_basic

    if single_visual_basic is None or isinstance(single_visual_basic, list) and all(x is None for x in single_visual_basic):
        logger.error('single_visual_basic is required.')
        return ['single_visual_basic is required.']
    if single_visual_basic is not None:

        request_parameters['single'] = single_visual_basic

    if static_visual_basic is None or isinstance(static_visual_basic, list) and all(x is None for x in static_visual_basic):
        logger.error('static_visual_basic is required.')
        return ['static_visual_basic is required.']
    if static_visual_basic is not None:

        request_parameters['static'] = static_visual_basic

    if step_visual_basic is None or isinstance(step_visual_basic, list) and all(x is None for x in step_visual_basic):
        logger.error('step_visual_basic is required.')
        return ['step_visual_basic is required.']
    if step_visual_basic is not None:

        request_parameters['step'] = step_visual_basic

    if stop_visual_basic is None or isinstance(stop_visual_basic, list) and all(x is None for x in stop_visual_basic):
        logger.error('stop_visual_basic is required.')
        return ['stop_visual_basic is required.']
    if stop_visual_basic is not None:

        request_parameters['stop'] = stop_visual_basic

    if string_visual_basic is None or isinstance(string_visual_basic, list) and all(x is None for x in string_visual_basic):
        logger.error('string_visual_basic is required.')
        return ['string_visual_basic is required.']
    if string_visual_basic is not None:

        request_parameters['string'] = string_visual_basic

    if structure_visual_basic is None or isinstance(structure_visual_basic, list) and all(x is None for x in structure_visual_basic):
        logger.error('structure_visual_basic is required.')
        return ['structure_visual_basic is required.']
    if structure_visual_basic is not None:

        request_parameters['structure'] = structure_visual_basic

    if sub_visual_basic is None or isinstance(sub_visual_basic, list) and all(x is None for x in sub_visual_basic):
        logger.error('sub_visual_basic is required.')
        return ['sub_visual_basic is required.']
    if sub_visual_basic is not None:

        request_parameters['sub'] = sub_visual_basic

    if synclock_visual_basic is None or isinstance(synclock_visual_basic, list) and all(x is None for x in synclock_visual_basic):
        logger.error('synclock_visual_basic is required.')
        return ['synclock_visual_basic is required.']
    if synclock_visual_basic is not None:

        request_parameters['synclock'] = synclock_visual_basic

    if then_visual_basic is None or isinstance(then_visual_basic, list) and all(x is None for x in then_visual_basic):
        logger.error('then_visual_basic is required.')
        return ['then_visual_basic is required.']
    if then_visual_basic is not None:

        request_parameters['then'] = then_visual_basic

    if throw_visual_basic is None or isinstance(throw_visual_basic, list) and all(x is None for x in throw_visual_basic):
        logger.error('throw_visual_basic is required.')
        return ['throw_visual_basic is required.']
    if throw_visual_basic is not None:

        request_parameters['throw'] = throw_visual_basic

    if to_visual_basic is None or isinstance(to_visual_basic, list) and all(x is None for x in to_visual_basic):
        logger.error('to_visual_basic is required.')
        return ['to_visual_basic is required.']
    if to_visual_basic is not None:

        request_parameters['to'] = to_visual_basic

    if try_visual_basic is None or isinstance(try_visual_basic, list) and all(x is None for x in try_visual_basic):
        logger.error('try_visual_basic is required.')
        return ['try_visual_basic is required.']
    if try_visual_basic is not None:

        request_parameters['try'] = try_visual_basic

    if trycast_visual_basic is None or isinstance(trycast_visual_basic, list) and all(x is None for x in trycast_visual_basic):
        logger.error('trycast_visual_basic is required.')
        return ['trycast_visual_basic is required.']
    if trycast_visual_basic is not None:

        request_parameters['trycast'] = trycast_visual_basic

    if type_visual_basic is None or isinstance(type_visual_basic, list) and all(x is None for x in type_visual_basic):
        logger.error('type_visual_basic is required.')
        return ['type_visual_basic is required.']
    if type_visual_basic is not None:

        request_parameters['type'] = type_visual_basic

    if typeof_visual_basic is None or isinstance(typeof_visual_basic, list) and all(x is None for x in typeof_visual_basic):
        logger.error('typeof_visual_basic is required.')
        return ['typeof_visual_basic is required.']
    if typeof_visual_basic is not None:

        request_parameters['typeof'] = typeof_visual_basic

    if uinteger_visual_basic is None or isinstance(uinteger_visual_basic, list) and all(x is None for x in uinteger_visual_basic):
        logger.error('uinteger_visual_basic is required.')
        return ['uinteger_visual_basic is required.']
    if uinteger_visual_basic is not None:

        request_parameters['uinteger'] = uinteger_visual_basic

    if ulong_visual_basic is None or isinstance(ulong_visual_basic, list) and all(x is None for x in ulong_visual_basic):
        logger.error('ulong_visual_basic is required.')
        return ['ulong_visual_basic is required.']
    if ulong_visual_basic is not None:

        request_parameters['ulong'] = ulong_visual_basic

    if ushort_visual_basic is None or isinstance(ushort_visual_basic, list) and all(x is None for x in ushort_visual_basic):
        logger.error('ushort_visual_basic is required.')
        return ['ushort_visual_basic is required.']
    if ushort_visual_basic is not None:

        request_parameters['ushort'] = ushort_visual_basic

    if using_visual_basic is None or isinstance(using_visual_basic, list) and all(x is None for x in using_visual_basic):
        logger.error('using_visual_basic is required.')
        return ['using_visual_basic is required.']
    if using_visual_basic is not None:

        request_parameters['using'] = using_visual_basic

    if variant_visual_basic is None or isinstance(variant_visual_basic, list) and all(x is None for x in variant_visual_basic):
        logger.error('variant_visual_basic is required.')
        return ['variant_visual_basic is required.']
    if variant_visual_basic is not None:

        request_parameters['variant'] = variant_visual_basic

    if wend_visual_basic is None or isinstance(wend_visual_basic, list) and all(x is None for x in wend_visual_basic):
        logger.error('wend_visual_basic is required.')
        return ['wend_visual_basic is required.']
    if wend_visual_basic is not None:

        request_parameters['wend'] = wend_visual_basic

    if when_visual_basic is None or isinstance(when_visual_basic, list) and all(x is None for x in when_visual_basic):
        logger.error('when_visual_basic is required.')
        return ['when_visual_basic is required.']
    if when_visual_basic is not None:

        request_parameters['when'] = when_visual_basic

    if while_visual_basic is None or isinstance(while_visual_basic, list) and all(x is None for x in while_visual_basic):
        logger.error('while_visual_basic is required.')
        return ['while_visual_basic is required.']
    if while_visual_basic is not None:

        request_parameters['while'] = while_visual_basic

    if widening_visual_basic is None or isinstance(widening_visual_basic, list) and all(x is None for x in widening_visual_basic):
        logger.error('widening_visual_basic is required.')
        return ['widening_visual_basic is required.']
    if widening_visual_basic is not None:

        request_parameters['widening'] = widening_visual_basic

    if with_visual_basic is None or isinstance(with_visual_basic, list) and all(x is None for x in with_visual_basic):
        logger.error('with_visual_basic is required.')
        return ['with_visual_basic is required.']
    if with_visual_basic is not None:

        request_parameters['with'] = with_visual_basic

    if withevents_visual_basic is None or isinstance(withevents_visual_basic, list) and all(x is None for x in withevents_visual_basic):
        logger.error('withevents_visual_basic is required.')
        return ['withevents_visual_basic is required.']
    if withevents_visual_basic is not None:

        request_parameters['withevents'] = withevents_visual_basic

    if writeonly_visual_basic is None or isinstance(writeonly_visual_basic, list) and all(x is None for x in writeonly_visual_basic):
        logger.error('writeonly_visual_basic is required.')
        return ['writeonly_visual_basic is required.']
    if writeonly_visual_basic is not None:

        request_parameters['writeonly'] = writeonly_visual_basic

    if xor_visual_basic is None or isinstance(xor_visual_basic, list) and all(x is None for x in xor_visual_basic):
        logger.error('xor_visual_basic is required.')
        return ['xor_visual_basic is required.']
    if xor_visual_basic is not None:

        request_parameters['xor'] = xor_visual_basic


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8949/test/vba/restricted/keywords'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=vba_keywords_test_post_test_vba_restricted_keywords] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'$ref', u'#/definitions/VBAKeywords'), (u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('vba_keywords_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=vba_keywords_test_post_test_vba_restricted_keywords] [url=http://localhost:8949/test/vba/restricted/keywords].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=vba_keywords_test_post_test_vba_restricted_keywords] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=vba_keywords_test_post_test_vba_restricted_keywords] [url=http://localhost:8949/test/vba/restricted/keywords].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='vba_keywords_test', call_in_wizard=False)
@xw.arg('addhandler_visual_basic', doc='')
@xw.arg('addressof_visual_basic', doc='')
@xw.arg('alias_visual_basic', doc='')
@xw.arg('and_visual_basic', doc='')
@xw.arg('andalso_visual_basic', doc='')
@xw.arg('as_visual_basic', doc='')
@xw.arg('boolean_visual_basic', doc='')
@xw.arg('byref_visual_basic', doc='')
@xw.arg('byte_visual_basic', doc='')
@xw.arg('byval_visual_basic', doc='')
@xw.arg('call_visual_basic', doc='')
@xw.arg('case_visual_basic', doc='')
@xw.arg('catch_visual_basic', doc='')
@xw.arg('cbool_visual_basic', doc='')
@xw.arg('cbyte_visual_basic', doc='')
@xw.arg('cchar_visual_basic', doc='')
@xw.arg('cdate_visual_basic', doc='')
@xw.arg('cdbl_visual_basic', doc='')
@xw.arg('cdec_visual_basic', doc='')
@xw.arg('char_visual_basic', doc='')
@xw.arg('cint_visual_basic', doc='')
@xw.arg('class_visual_basic', doc='')
@xw.arg('clng_visual_basic', doc='')
@xw.arg('cobj_visual_basic', doc='')
@xw.arg('const_visual_basic', doc='')
@xw.arg('continue_visual_basic', doc='')
@xw.arg('csbyte_visual_basic', doc='')
@xw.arg('cshort_visual_basic', doc='')
@xw.arg('csng_visual_basic', doc='')
@xw.arg('cstr_visual_basic', doc='')
@xw.arg('ctype_visual_basic', doc='')
@xw.arg('cuint_visual_basic', doc='')
@xw.arg('culng_visual_basic', doc='')
@xw.arg('currency_visual_basic', doc='')
@xw.arg('cushort_visual_basic', doc='')
@xw.arg('date_visual_basic', doc='')
@xw.arg('decimal_visual_basic', doc='')
@xw.arg('declare_visual_basic', doc='')
@xw.arg('default_visual_basic', doc='')
@xw.arg('delegate_visual_basic', doc='')
@xw.arg('dim_visual_basic', doc='')
@xw.arg('directcast_visual_basic', doc='')
@xw.arg('do_visual_basic', doc='')
@xw.arg('double_visual_basic', doc='')
@xw.arg('each_visual_basic', doc='')
@xw.arg('else_visual_basic', doc='')
@xw.arg('elseif_visual_basic', doc='')
@xw.arg('end_visual_basic', doc='')
@xw.arg('endif_visual_basic', doc='')
@xw.arg('enum_visual_basic', doc='')
@xw.arg('erase_visual_basic', doc='')
@xw.arg('error_visual_basic', doc='')
@xw.arg('event_visual_basic', doc='')
@xw.arg('exit_visual_basic', doc='')
@xw.arg('finally_visual_basic', doc='')
@xw.arg('for_visual_basic', doc='')
@xw.arg('friend_visual_basic', doc='')
@xw.arg('function_visual_basic', doc='')
@xw.arg('get_visual_basic', doc='')
@xw.arg('gettype_visual_basic', doc='')
@xw.arg('getxmlnamespace_visual_basic', doc='')
@xw.arg('global_visual_basic', doc='')
@xw.arg('gosub_visual_basic', doc='')
@xw.arg('goto_visual_basic', doc='')
@xw.arg('handles_visual_basic', doc='')
@xw.arg('if_visual_basic', doc='')
@xw.arg('implements_visual_basic', doc='')
@xw.arg('imports_visual_basic', doc='')
@xw.arg('in_visual_basic', doc='')
@xw.arg('inherits_visual_basic', doc='')
@xw.arg('integer_visual_basic', doc='')
@xw.arg('interface_visual_basic', doc='')
@xw.arg('is_visual_basic', doc='')
@xw.arg('isnot_visual_basic', doc='')
@xw.arg('let_visual_basic', doc='')
@xw.arg('lib_visual_basic', doc='')
@xw.arg('like_visual_basic', doc='')
@xw.arg('long_visual_basic', doc='')
@xw.arg('loop_visual_basic', doc='')
@xw.arg('me_visual_basic', doc='')
@xw.arg('mod_visual_basic', doc='')
@xw.arg('module_visual_basic', doc='')
@xw.arg('mustinherit_visual_basic', doc='')
@xw.arg('mustoverride_visual_basic', doc='')
@xw.arg('mybase_visual_basic', doc='')
@xw.arg('myclass_visual_basic', doc='')
@xw.arg('namespace_visual_basic', doc='')
@xw.arg('narrowing_visual_basic', doc='')
@xw.arg('new_visual_basic', doc='')
@xw.arg('next_visual_basic', doc='')
@xw.arg('not_visual_basic', doc='')
@xw.arg('nothing_visual_basic', doc='')
@xw.arg('notinheritable_visual_basic', doc='')
@xw.arg('notoverridable_visual_basic', doc='')
@xw.arg('object_visual_basic', doc='')
@xw.arg('of_visual_basic', doc='')
@xw.arg('on_visual_basic', doc='')
@xw.arg('operator_visual_basic', doc='')
@xw.arg('option_visual_basic', doc='')
@xw.arg('optional_visual_basic', doc='')
@xw.arg('or_visual_basic', doc='')
@xw.arg('orelse_visual_basic', doc='')
@xw.arg('overloads_visual_basic', doc='')
@xw.arg('overridable_visual_basic', doc='')
@xw.arg('overrides_visual_basic', doc='')
@xw.arg('paramarray_visual_basic', doc='')
@xw.arg('partial_visual_basic', doc='')
@xw.arg('private_visual_basic', doc='')
@xw.arg('property_visual_basic', doc='')
@xw.arg('protected_visual_basic', doc='')
@xw.arg('public_visual_basic', doc='')
@xw.arg('raiseevent_visual_basic', doc='')
@xw.arg('readonly_visual_basic', doc='')
@xw.arg('redim_visual_basic', doc='')
@xw.arg('rem_visual_basic', doc='')
@xw.arg('removehandler_visual_basic', doc='')
@xw.arg('resume_visual_basic', doc='')
@xw.arg('return_visual_basic', doc='')
@xw.arg('sbyte_visual_basic', doc='')
@xw.arg('select_visual_basic', doc='')
@xw.arg('set_visual_basic', doc='')
@xw.arg('shadows_visual_basic', doc='')
@xw.arg('shared_visual_basic', doc='')
@xw.arg('short_visual_basic', doc='')
@xw.arg('single_visual_basic', doc='')
@xw.arg('static_visual_basic', doc='')
@xw.arg('step_visual_basic', doc='')
@xw.arg('stop_visual_basic', doc='')
@xw.arg('string_visual_basic', doc='')
@xw.arg('structure_visual_basic', doc='')
@xw.arg('sub_visual_basic', doc='')
@xw.arg('synclock_visual_basic', doc='')
@xw.arg('then_visual_basic', doc='')
@xw.arg('throw_visual_basic', doc='')
@xw.arg('to_visual_basic', doc='')
@xw.arg('try_visual_basic', doc='')
@xw.arg('trycast_visual_basic', doc='')
@xw.arg('type_visual_basic', doc='')
@xw.arg('typeof_visual_basic', doc='')
@xw.arg('uinteger_visual_basic', doc='')
@xw.arg('ulong_visual_basic', doc='')
@xw.arg('ushort_visual_basic', doc='')
@xw.arg('using_visual_basic', doc='')
@xw.arg('variant_visual_basic', doc='')
@xw.arg('wend_visual_basic', doc='')
@xw.arg('when_visual_basic', doc='')
@xw.arg('while_visual_basic', doc='')
@xw.arg('widening_visual_basic', doc='')
@xw.arg('with_visual_basic', doc='')
@xw.arg('withevents_visual_basic', doc='')
@xw.arg('writeonly_visual_basic', doc='')
@xw.arg('xor_visual_basic', doc='')
@xw.ret(expand='table')
def vba_keywords_test_put_test_vba_restricted_keywords(addhandler_visual_basic, addressof_visual_basic, alias_visual_basic, and_visual_basic, andalso_visual_basic, as_visual_basic, boolean_visual_basic, byref_visual_basic, byte_visual_basic, byval_visual_basic, call_visual_basic, case_visual_basic, catch_visual_basic, cbool_visual_basic, cbyte_visual_basic, cchar_visual_basic, cdate_visual_basic, cdbl_visual_basic, cdec_visual_basic, char_visual_basic, cint_visual_basic, class_visual_basic, clng_visual_basic, cobj_visual_basic, const_visual_basic, continue_visual_basic, csbyte_visual_basic, cshort_visual_basic, csng_visual_basic, cstr_visual_basic, ctype_visual_basic, cuint_visual_basic, culng_visual_basic, currency_visual_basic, cushort_visual_basic, date_visual_basic, decimal_visual_basic, declare_visual_basic, default_visual_basic, delegate_visual_basic, dim_visual_basic, directcast_visual_basic, do_visual_basic, double_visual_basic, each_visual_basic, else_visual_basic, elseif_visual_basic, end_visual_basic, endif_visual_basic, enum_visual_basic, erase_visual_basic, error_visual_basic, event_visual_basic, exit_visual_basic, finally_visual_basic, for_visual_basic, friend_visual_basic, function_visual_basic, get_visual_basic, gettype_visual_basic, getxmlnamespace_visual_basic, global_visual_basic, gosub_visual_basic, goto_visual_basic, handles_visual_basic, if_visual_basic, implements_visual_basic, imports_visual_basic, in_visual_basic, inherits_visual_basic, integer_visual_basic, interface_visual_basic, is_visual_basic, isnot_visual_basic, let_visual_basic, lib_visual_basic, like_visual_basic, long_visual_basic, loop_visual_basic, me_visual_basic, mod_visual_basic, module_visual_basic, mustinherit_visual_basic, mustoverride_visual_basic, mybase_visual_basic, myclass_visual_basic, namespace_visual_basic, narrowing_visual_basic, new_visual_basic, next_visual_basic, not_visual_basic, nothing_visual_basic, notinheritable_visual_basic, notoverridable_visual_basic, object_visual_basic, of_visual_basic, on_visual_basic, operator_visual_basic, option_visual_basic, optional_visual_basic, or_visual_basic, orelse_visual_basic, overloads_visual_basic, overridable_visual_basic, overrides_visual_basic, paramarray_visual_basic, partial_visual_basic, private_visual_basic, property_visual_basic, protected_visual_basic, public_visual_basic, raiseevent_visual_basic, readonly_visual_basic, redim_visual_basic, rem_visual_basic, removehandler_visual_basic, resume_visual_basic, return_visual_basic, sbyte_visual_basic, select_visual_basic, set_visual_basic, shadows_visual_basic, shared_visual_basic, short_visual_basic, single_visual_basic, static_visual_basic, step_visual_basic, stop_visual_basic, string_visual_basic, structure_visual_basic, sub_visual_basic, synclock_visual_basic, then_visual_basic, throw_visual_basic, to_visual_basic, try_visual_basic, trycast_visual_basic, type_visual_basic, typeof_visual_basic, uinteger_visual_basic, ulong_visual_basic, ushort_visual_basic, using_visual_basic, variant_visual_basic, wend_visual_basic, when_visual_basic, while_visual_basic, widening_visual_basic, with_visual_basic, withevents_visual_basic, writeonly_visual_basic, xor_visual_basic):
    logger.info("[status=Calling] [function=vba_keywords_test_put_test_vba_restricted_keywords]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if addhandler_visual_basic is None or isinstance(addhandler_visual_basic, list) and all(x is None for x in addhandler_visual_basic):
        logger.error('addhandler_visual_basic is required.')
        return ['addhandler_visual_basic is required.']
    if addhandler_visual_basic is not None:

        request_parameters['addhandler'] = addhandler_visual_basic

    if addressof_visual_basic is None or isinstance(addressof_visual_basic, list) and all(x is None for x in addressof_visual_basic):
        logger.error('addressof_visual_basic is required.')
        return ['addressof_visual_basic is required.']
    if addressof_visual_basic is not None:

        request_parameters['addressof'] = addressof_visual_basic

    if alias_visual_basic is None or isinstance(alias_visual_basic, list) and all(x is None for x in alias_visual_basic):
        logger.error('alias_visual_basic is required.')
        return ['alias_visual_basic is required.']
    if alias_visual_basic is not None:

        request_parameters['alias'] = alias_visual_basic

    if and_visual_basic is None or isinstance(and_visual_basic, list) and all(x is None for x in and_visual_basic):
        logger.error('and_visual_basic is required.')
        return ['and_visual_basic is required.']
    if and_visual_basic is not None:

        request_parameters['and'] = and_visual_basic

    if andalso_visual_basic is None or isinstance(andalso_visual_basic, list) and all(x is None for x in andalso_visual_basic):
        logger.error('andalso_visual_basic is required.')
        return ['andalso_visual_basic is required.']
    if andalso_visual_basic is not None:

        request_parameters['andalso'] = andalso_visual_basic

    if as_visual_basic is None or isinstance(as_visual_basic, list) and all(x is None for x in as_visual_basic):
        logger.error('as_visual_basic is required.')
        return ['as_visual_basic is required.']
    if as_visual_basic is not None:

        request_parameters['as'] = as_visual_basic

    if boolean_visual_basic is None or isinstance(boolean_visual_basic, list) and all(x is None for x in boolean_visual_basic):
        logger.error('boolean_visual_basic is required.')
        return ['boolean_visual_basic is required.']
    if boolean_visual_basic is not None:

        request_parameters['boolean'] = boolean_visual_basic

    if byref_visual_basic is None or isinstance(byref_visual_basic, list) and all(x is None for x in byref_visual_basic):
        logger.error('byref_visual_basic is required.')
        return ['byref_visual_basic is required.']
    if byref_visual_basic is not None:

        request_parameters['byref'] = byref_visual_basic

    if byte_visual_basic is None or isinstance(byte_visual_basic, list) and all(x is None for x in byte_visual_basic):
        logger.error('byte_visual_basic is required.')
        return ['byte_visual_basic is required.']
    if byte_visual_basic is not None:

        request_parameters['byte'] = byte_visual_basic

    if byval_visual_basic is None or isinstance(byval_visual_basic, list) and all(x is None for x in byval_visual_basic):
        logger.error('byval_visual_basic is required.')
        return ['byval_visual_basic is required.']
    if byval_visual_basic is not None:

        request_parameters['byval'] = byval_visual_basic

    if call_visual_basic is None or isinstance(call_visual_basic, list) and all(x is None for x in call_visual_basic):
        logger.error('call_visual_basic is required.')
        return ['call_visual_basic is required.']
    if call_visual_basic is not None:

        request_parameters['call'] = call_visual_basic

    if case_visual_basic is None or isinstance(case_visual_basic, list) and all(x is None for x in case_visual_basic):
        logger.error('case_visual_basic is required.')
        return ['case_visual_basic is required.']
    if case_visual_basic is not None:

        request_parameters['case'] = case_visual_basic

    if catch_visual_basic is None or isinstance(catch_visual_basic, list) and all(x is None for x in catch_visual_basic):
        logger.error('catch_visual_basic is required.')
        return ['catch_visual_basic is required.']
    if catch_visual_basic is not None:

        request_parameters['catch'] = catch_visual_basic

    if cbool_visual_basic is None or isinstance(cbool_visual_basic, list) and all(x is None for x in cbool_visual_basic):
        logger.error('cbool_visual_basic is required.')
        return ['cbool_visual_basic is required.']
    if cbool_visual_basic is not None:

        request_parameters['cbool'] = cbool_visual_basic

    if cbyte_visual_basic is None or isinstance(cbyte_visual_basic, list) and all(x is None for x in cbyte_visual_basic):
        logger.error('cbyte_visual_basic is required.')
        return ['cbyte_visual_basic is required.']
    if cbyte_visual_basic is not None:

        request_parameters['cbyte'] = cbyte_visual_basic

    if cchar_visual_basic is None or isinstance(cchar_visual_basic, list) and all(x is None for x in cchar_visual_basic):
        logger.error('cchar_visual_basic is required.')
        return ['cchar_visual_basic is required.']
    if cchar_visual_basic is not None:

        request_parameters['cchar'] = cchar_visual_basic

    if cdate_visual_basic is None or isinstance(cdate_visual_basic, list) and all(x is None for x in cdate_visual_basic):
        logger.error('cdate_visual_basic is required.')
        return ['cdate_visual_basic is required.']
    if cdate_visual_basic is not None:

        request_parameters['cdate'] = cdate_visual_basic

    if cdbl_visual_basic is None or isinstance(cdbl_visual_basic, list) and all(x is None for x in cdbl_visual_basic):
        logger.error('cdbl_visual_basic is required.')
        return ['cdbl_visual_basic is required.']
    if cdbl_visual_basic is not None:

        request_parameters['cdbl'] = cdbl_visual_basic

    if cdec_visual_basic is None or isinstance(cdec_visual_basic, list) and all(x is None for x in cdec_visual_basic):
        logger.error('cdec_visual_basic is required.')
        return ['cdec_visual_basic is required.']
    if cdec_visual_basic is not None:

        request_parameters['cdec'] = cdec_visual_basic

    if char_visual_basic is None or isinstance(char_visual_basic, list) and all(x is None for x in char_visual_basic):
        logger.error('char_visual_basic is required.')
        return ['char_visual_basic is required.']
    if char_visual_basic is not None:

        request_parameters['char'] = char_visual_basic

    if cint_visual_basic is None or isinstance(cint_visual_basic, list) and all(x is None for x in cint_visual_basic):
        logger.error('cint_visual_basic is required.')
        return ['cint_visual_basic is required.']
    if cint_visual_basic is not None:

        request_parameters['cint'] = cint_visual_basic

    if class_visual_basic is None or isinstance(class_visual_basic, list) and all(x is None for x in class_visual_basic):
        logger.error('class_visual_basic is required.')
        return ['class_visual_basic is required.']
    if class_visual_basic is not None:

        request_parameters['class'] = class_visual_basic

    if clng_visual_basic is None or isinstance(clng_visual_basic, list) and all(x is None for x in clng_visual_basic):
        logger.error('clng_visual_basic is required.')
        return ['clng_visual_basic is required.']
    if clng_visual_basic is not None:

        request_parameters['clng'] = clng_visual_basic

    if cobj_visual_basic is None or isinstance(cobj_visual_basic, list) and all(x is None for x in cobj_visual_basic):
        logger.error('cobj_visual_basic is required.')
        return ['cobj_visual_basic is required.']
    if cobj_visual_basic is not None:

        request_parameters['cobj'] = cobj_visual_basic

    if const_visual_basic is None or isinstance(const_visual_basic, list) and all(x is None for x in const_visual_basic):
        logger.error('const_visual_basic is required.')
        return ['const_visual_basic is required.']
    if const_visual_basic is not None:

        request_parameters['const'] = const_visual_basic

    if continue_visual_basic is None or isinstance(continue_visual_basic, list) and all(x is None for x in continue_visual_basic):
        logger.error('continue_visual_basic is required.')
        return ['continue_visual_basic is required.']
    if continue_visual_basic is not None:

        request_parameters['continue'] = continue_visual_basic

    if csbyte_visual_basic is None or isinstance(csbyte_visual_basic, list) and all(x is None for x in csbyte_visual_basic):
        logger.error('csbyte_visual_basic is required.')
        return ['csbyte_visual_basic is required.']
    if csbyte_visual_basic is not None:

        request_parameters['csbyte'] = csbyte_visual_basic

    if cshort_visual_basic is None or isinstance(cshort_visual_basic, list) and all(x is None for x in cshort_visual_basic):
        logger.error('cshort_visual_basic is required.')
        return ['cshort_visual_basic is required.']
    if cshort_visual_basic is not None:

        request_parameters['cshort'] = cshort_visual_basic

    if csng_visual_basic is None or isinstance(csng_visual_basic, list) and all(x is None for x in csng_visual_basic):
        logger.error('csng_visual_basic is required.')
        return ['csng_visual_basic is required.']
    if csng_visual_basic is not None:

        request_parameters['csng'] = csng_visual_basic

    if cstr_visual_basic is None or isinstance(cstr_visual_basic, list) and all(x is None for x in cstr_visual_basic):
        logger.error('cstr_visual_basic is required.')
        return ['cstr_visual_basic is required.']
    if cstr_visual_basic is not None:

        request_parameters['cstr'] = cstr_visual_basic

    if ctype_visual_basic is None or isinstance(ctype_visual_basic, list) and all(x is None for x in ctype_visual_basic):
        logger.error('ctype_visual_basic is required.')
        return ['ctype_visual_basic is required.']
    if ctype_visual_basic is not None:

        request_parameters['ctype'] = ctype_visual_basic

    if cuint_visual_basic is None or isinstance(cuint_visual_basic, list) and all(x is None for x in cuint_visual_basic):
        logger.error('cuint_visual_basic is required.')
        return ['cuint_visual_basic is required.']
    if cuint_visual_basic is not None:

        request_parameters['cuint'] = cuint_visual_basic

    if culng_visual_basic is None or isinstance(culng_visual_basic, list) and all(x is None for x in culng_visual_basic):
        logger.error('culng_visual_basic is required.')
        return ['culng_visual_basic is required.']
    if culng_visual_basic is not None:

        request_parameters['culng'] = culng_visual_basic

    if currency_visual_basic is None or isinstance(currency_visual_basic, list) and all(x is None for x in currency_visual_basic):
        logger.error('currency_visual_basic is required.')
        return ['currency_visual_basic is required.']
    if currency_visual_basic is not None:

        request_parameters['currency'] = currency_visual_basic

    if cushort_visual_basic is None or isinstance(cushort_visual_basic, list) and all(x is None for x in cushort_visual_basic):
        logger.error('cushort_visual_basic is required.')
        return ['cushort_visual_basic is required.']
    if cushort_visual_basic is not None:

        request_parameters['cushort'] = cushort_visual_basic

    if date_visual_basic is None or isinstance(date_visual_basic, list) and all(x is None for x in date_visual_basic):
        logger.error('date_visual_basic is required.')
        return ['date_visual_basic is required.']
    if date_visual_basic is not None:

        request_parameters['date'] = date_visual_basic

    if decimal_visual_basic is None or isinstance(decimal_visual_basic, list) and all(x is None for x in decimal_visual_basic):
        logger.error('decimal_visual_basic is required.')
        return ['decimal_visual_basic is required.']
    if decimal_visual_basic is not None:

        request_parameters['decimal'] = decimal_visual_basic

    if declare_visual_basic is None or isinstance(declare_visual_basic, list) and all(x is None for x in declare_visual_basic):
        logger.error('declare_visual_basic is required.')
        return ['declare_visual_basic is required.']
    if declare_visual_basic is not None:

        request_parameters['declare'] = declare_visual_basic

    if default_visual_basic is None or isinstance(default_visual_basic, list) and all(x is None for x in default_visual_basic):
        logger.error('default_visual_basic is required.')
        return ['default_visual_basic is required.']
    if default_visual_basic is not None:

        request_parameters['default'] = default_visual_basic

    if delegate_visual_basic is None or isinstance(delegate_visual_basic, list) and all(x is None for x in delegate_visual_basic):
        logger.error('delegate_visual_basic is required.')
        return ['delegate_visual_basic is required.']
    if delegate_visual_basic is not None:

        request_parameters['delegate'] = delegate_visual_basic

    if dim_visual_basic is None or isinstance(dim_visual_basic, list) and all(x is None for x in dim_visual_basic):
        logger.error('dim_visual_basic is required.')
        return ['dim_visual_basic is required.']
    if dim_visual_basic is not None:

        request_parameters['dim'] = dim_visual_basic

    if directcast_visual_basic is None or isinstance(directcast_visual_basic, list) and all(x is None for x in directcast_visual_basic):
        logger.error('directcast_visual_basic is required.')
        return ['directcast_visual_basic is required.']
    if directcast_visual_basic is not None:

        request_parameters['directcast'] = directcast_visual_basic

    if do_visual_basic is None or isinstance(do_visual_basic, list) and all(x is None for x in do_visual_basic):
        logger.error('do_visual_basic is required.')
        return ['do_visual_basic is required.']
    if do_visual_basic is not None:

        request_parameters['do'] = do_visual_basic

    if double_visual_basic is None or isinstance(double_visual_basic, list) and all(x is None for x in double_visual_basic):
        logger.error('double_visual_basic is required.')
        return ['double_visual_basic is required.']
    if double_visual_basic is not None:

        request_parameters['double'] = double_visual_basic

    if each_visual_basic is None or isinstance(each_visual_basic, list) and all(x is None for x in each_visual_basic):
        logger.error('each_visual_basic is required.')
        return ['each_visual_basic is required.']
    if each_visual_basic is not None:

        request_parameters['each'] = each_visual_basic

    if else_visual_basic is None or isinstance(else_visual_basic, list) and all(x is None for x in else_visual_basic):
        logger.error('else_visual_basic is required.')
        return ['else_visual_basic is required.']
    if else_visual_basic is not None:

        request_parameters['else'] = else_visual_basic

    if elseif_visual_basic is None or isinstance(elseif_visual_basic, list) and all(x is None for x in elseif_visual_basic):
        logger.error('elseif_visual_basic is required.')
        return ['elseif_visual_basic is required.']
    if elseif_visual_basic is not None:

        request_parameters['elseif'] = elseif_visual_basic

    if end_visual_basic is None or isinstance(end_visual_basic, list) and all(x is None for x in end_visual_basic):
        logger.error('end_visual_basic is required.')
        return ['end_visual_basic is required.']
    if end_visual_basic is not None:

        request_parameters['end'] = end_visual_basic

    if endif_visual_basic is None or isinstance(endif_visual_basic, list) and all(x is None for x in endif_visual_basic):
        logger.error('endif_visual_basic is required.')
        return ['endif_visual_basic is required.']
    if endif_visual_basic is not None:

        request_parameters['endif'] = endif_visual_basic

    if enum_visual_basic is None or isinstance(enum_visual_basic, list) and all(x is None for x in enum_visual_basic):
        logger.error('enum_visual_basic is required.')
        return ['enum_visual_basic is required.']
    if enum_visual_basic is not None:

        request_parameters['enum'] = enum_visual_basic

    if erase_visual_basic is None or isinstance(erase_visual_basic, list) and all(x is None for x in erase_visual_basic):
        logger.error('erase_visual_basic is required.')
        return ['erase_visual_basic is required.']
    if erase_visual_basic is not None:

        request_parameters['erase'] = erase_visual_basic

    if error_visual_basic is None or isinstance(error_visual_basic, list) and all(x is None for x in error_visual_basic):
        logger.error('error_visual_basic is required.')
        return ['error_visual_basic is required.']
    if error_visual_basic is not None:

        request_parameters['error'] = error_visual_basic

    if event_visual_basic is None or isinstance(event_visual_basic, list) and all(x is None for x in event_visual_basic):
        logger.error('event_visual_basic is required.')
        return ['event_visual_basic is required.']
    if event_visual_basic is not None:

        request_parameters['event'] = event_visual_basic

    if exit_visual_basic is None or isinstance(exit_visual_basic, list) and all(x is None for x in exit_visual_basic):
        logger.error('exit_visual_basic is required.')
        return ['exit_visual_basic is required.']
    if exit_visual_basic is not None:

        request_parameters['exit'] = exit_visual_basic

    if finally_visual_basic is None or isinstance(finally_visual_basic, list) and all(x is None for x in finally_visual_basic):
        logger.error('finally_visual_basic is required.')
        return ['finally_visual_basic is required.']
    if finally_visual_basic is not None:

        request_parameters['finally'] = finally_visual_basic

    if for_visual_basic is None or isinstance(for_visual_basic, list) and all(x is None for x in for_visual_basic):
        logger.error('for_visual_basic is required.')
        return ['for_visual_basic is required.']
    if for_visual_basic is not None:

        request_parameters['for'] = for_visual_basic

    if friend_visual_basic is None or isinstance(friend_visual_basic, list) and all(x is None for x in friend_visual_basic):
        logger.error('friend_visual_basic is required.')
        return ['friend_visual_basic is required.']
    if friend_visual_basic is not None:

        request_parameters['friend'] = friend_visual_basic

    if function_visual_basic is None or isinstance(function_visual_basic, list) and all(x is None for x in function_visual_basic):
        logger.error('function_visual_basic is required.')
        return ['function_visual_basic is required.']
    if function_visual_basic is not None:

        request_parameters['function'] = function_visual_basic

    if get_visual_basic is None or isinstance(get_visual_basic, list) and all(x is None for x in get_visual_basic):
        logger.error('get_visual_basic is required.')
        return ['get_visual_basic is required.']
    if get_visual_basic is not None:

        request_parameters['get'] = get_visual_basic

    if gettype_visual_basic is None or isinstance(gettype_visual_basic, list) and all(x is None for x in gettype_visual_basic):
        logger.error('gettype_visual_basic is required.')
        return ['gettype_visual_basic is required.']
    if gettype_visual_basic is not None:

        request_parameters['gettype'] = gettype_visual_basic

    if getxmlnamespace_visual_basic is None or isinstance(getxmlnamespace_visual_basic, list) and all(x is None for x in getxmlnamespace_visual_basic):
        logger.error('getxmlnamespace_visual_basic is required.')
        return ['getxmlnamespace_visual_basic is required.']
    if getxmlnamespace_visual_basic is not None:

        request_parameters['getxmlnamespace'] = getxmlnamespace_visual_basic

    if global_visual_basic is None or isinstance(global_visual_basic, list) and all(x is None for x in global_visual_basic):
        logger.error('global_visual_basic is required.')
        return ['global_visual_basic is required.']
    if global_visual_basic is not None:

        request_parameters['global'] = global_visual_basic

    if gosub_visual_basic is None or isinstance(gosub_visual_basic, list) and all(x is None for x in gosub_visual_basic):
        logger.error('gosub_visual_basic is required.')
        return ['gosub_visual_basic is required.']
    if gosub_visual_basic is not None:

        request_parameters['gosub'] = gosub_visual_basic

    if goto_visual_basic is None or isinstance(goto_visual_basic, list) and all(x is None for x in goto_visual_basic):
        logger.error('goto_visual_basic is required.')
        return ['goto_visual_basic is required.']
    if goto_visual_basic is not None:

        request_parameters['goto'] = goto_visual_basic

    if handles_visual_basic is None or isinstance(handles_visual_basic, list) and all(x is None for x in handles_visual_basic):
        logger.error('handles_visual_basic is required.')
        return ['handles_visual_basic is required.']
    if handles_visual_basic is not None:

        request_parameters['handles'] = handles_visual_basic

    if if_visual_basic is None or isinstance(if_visual_basic, list) and all(x is None for x in if_visual_basic):
        logger.error('if_visual_basic is required.')
        return ['if_visual_basic is required.']
    if if_visual_basic is not None:

        request_parameters['if'] = if_visual_basic

    if implements_visual_basic is None or isinstance(implements_visual_basic, list) and all(x is None for x in implements_visual_basic):
        logger.error('implements_visual_basic is required.')
        return ['implements_visual_basic is required.']
    if implements_visual_basic is not None:

        request_parameters['implements'] = implements_visual_basic

    if imports_visual_basic is None or isinstance(imports_visual_basic, list) and all(x is None for x in imports_visual_basic):
        logger.error('imports_visual_basic is required.')
        return ['imports_visual_basic is required.']
    if imports_visual_basic is not None:

        request_parameters['imports'] = imports_visual_basic

    if in_visual_basic is None or isinstance(in_visual_basic, list) and all(x is None for x in in_visual_basic):
        logger.error('in_visual_basic is required.')
        return ['in_visual_basic is required.']
    if in_visual_basic is not None:

        request_parameters['in'] = in_visual_basic

    if inherits_visual_basic is None or isinstance(inherits_visual_basic, list) and all(x is None for x in inherits_visual_basic):
        logger.error('inherits_visual_basic is required.')
        return ['inherits_visual_basic is required.']
    if inherits_visual_basic is not None:

        request_parameters['inherits'] = inherits_visual_basic

    if integer_visual_basic is None or isinstance(integer_visual_basic, list) and all(x is None for x in integer_visual_basic):
        logger.error('integer_visual_basic is required.')
        return ['integer_visual_basic is required.']
    if integer_visual_basic is not None:

        request_parameters['integer'] = integer_visual_basic

    if interface_visual_basic is None or isinstance(interface_visual_basic, list) and all(x is None for x in interface_visual_basic):
        logger.error('interface_visual_basic is required.')
        return ['interface_visual_basic is required.']
    if interface_visual_basic is not None:

        request_parameters['interface'] = interface_visual_basic

    if is_visual_basic is None or isinstance(is_visual_basic, list) and all(x is None for x in is_visual_basic):
        logger.error('is_visual_basic is required.')
        return ['is_visual_basic is required.']
    if is_visual_basic is not None:

        request_parameters['is'] = is_visual_basic

    if isnot_visual_basic is None or isinstance(isnot_visual_basic, list) and all(x is None for x in isnot_visual_basic):
        logger.error('isnot_visual_basic is required.')
        return ['isnot_visual_basic is required.']
    if isnot_visual_basic is not None:

        request_parameters['isnot'] = isnot_visual_basic

    if let_visual_basic is None or isinstance(let_visual_basic, list) and all(x is None for x in let_visual_basic):
        logger.error('let_visual_basic is required.')
        return ['let_visual_basic is required.']
    if let_visual_basic is not None:

        request_parameters['let'] = let_visual_basic

    if lib_visual_basic is None or isinstance(lib_visual_basic, list) and all(x is None for x in lib_visual_basic):
        logger.error('lib_visual_basic is required.')
        return ['lib_visual_basic is required.']
    if lib_visual_basic is not None:

        request_parameters['lib'] = lib_visual_basic

    if like_visual_basic is None or isinstance(like_visual_basic, list) and all(x is None for x in like_visual_basic):
        logger.error('like_visual_basic is required.')
        return ['like_visual_basic is required.']
    if like_visual_basic is not None:

        request_parameters['like'] = like_visual_basic

    if long_visual_basic is None or isinstance(long_visual_basic, list) and all(x is None for x in long_visual_basic):
        logger.error('long_visual_basic is required.')
        return ['long_visual_basic is required.']
    if long_visual_basic is not None:

        request_parameters['long'] = long_visual_basic

    if loop_visual_basic is None or isinstance(loop_visual_basic, list) and all(x is None for x in loop_visual_basic):
        logger.error('loop_visual_basic is required.')
        return ['loop_visual_basic is required.']
    if loop_visual_basic is not None:

        request_parameters['loop'] = loop_visual_basic

    if me_visual_basic is None or isinstance(me_visual_basic, list) and all(x is None for x in me_visual_basic):
        logger.error('me_visual_basic is required.')
        return ['me_visual_basic is required.']
    if me_visual_basic is not None:

        request_parameters['me'] = me_visual_basic

    if mod_visual_basic is None or isinstance(mod_visual_basic, list) and all(x is None for x in mod_visual_basic):
        logger.error('mod_visual_basic is required.')
        return ['mod_visual_basic is required.']
    if mod_visual_basic is not None:

        request_parameters['mod'] = mod_visual_basic

    if module_visual_basic is None or isinstance(module_visual_basic, list) and all(x is None for x in module_visual_basic):
        logger.error('module_visual_basic is required.')
        return ['module_visual_basic is required.']
    if module_visual_basic is not None:

        request_parameters['module'] = module_visual_basic

    if mustinherit_visual_basic is None or isinstance(mustinherit_visual_basic, list) and all(x is None for x in mustinherit_visual_basic):
        logger.error('mustinherit_visual_basic is required.')
        return ['mustinherit_visual_basic is required.']
    if mustinherit_visual_basic is not None:

        request_parameters['mustinherit'] = mustinherit_visual_basic

    if mustoverride_visual_basic is None or isinstance(mustoverride_visual_basic, list) and all(x is None for x in mustoverride_visual_basic):
        logger.error('mustoverride_visual_basic is required.')
        return ['mustoverride_visual_basic is required.']
    if mustoverride_visual_basic is not None:

        request_parameters['mustoverride'] = mustoverride_visual_basic

    if mybase_visual_basic is None or isinstance(mybase_visual_basic, list) and all(x is None for x in mybase_visual_basic):
        logger.error('mybase_visual_basic is required.')
        return ['mybase_visual_basic is required.']
    if mybase_visual_basic is not None:

        request_parameters['mybase'] = mybase_visual_basic

    if myclass_visual_basic is None or isinstance(myclass_visual_basic, list) and all(x is None for x in myclass_visual_basic):
        logger.error('myclass_visual_basic is required.')
        return ['myclass_visual_basic is required.']
    if myclass_visual_basic is not None:

        request_parameters['myclass'] = myclass_visual_basic

    if namespace_visual_basic is None or isinstance(namespace_visual_basic, list) and all(x is None for x in namespace_visual_basic):
        logger.error('namespace_visual_basic is required.')
        return ['namespace_visual_basic is required.']
    if namespace_visual_basic is not None:

        request_parameters['namespace'] = namespace_visual_basic

    if narrowing_visual_basic is None or isinstance(narrowing_visual_basic, list) and all(x is None for x in narrowing_visual_basic):
        logger.error('narrowing_visual_basic is required.')
        return ['narrowing_visual_basic is required.']
    if narrowing_visual_basic is not None:

        request_parameters['narrowing'] = narrowing_visual_basic

    if new_visual_basic is None or isinstance(new_visual_basic, list) and all(x is None for x in new_visual_basic):
        logger.error('new_visual_basic is required.')
        return ['new_visual_basic is required.']
    if new_visual_basic is not None:

        request_parameters['new'] = new_visual_basic

    if next_visual_basic is None or isinstance(next_visual_basic, list) and all(x is None for x in next_visual_basic):
        logger.error('next_visual_basic is required.')
        return ['next_visual_basic is required.']
    if next_visual_basic is not None:

        request_parameters['next'] = next_visual_basic

    if not_visual_basic is None or isinstance(not_visual_basic, list) and all(x is None for x in not_visual_basic):
        logger.error('not_visual_basic is required.')
        return ['not_visual_basic is required.']
    if not_visual_basic is not None:

        request_parameters['not'] = not_visual_basic

    if nothing_visual_basic is None or isinstance(nothing_visual_basic, list) and all(x is None for x in nothing_visual_basic):
        logger.error('nothing_visual_basic is required.')
        return ['nothing_visual_basic is required.']
    if nothing_visual_basic is not None:

        request_parameters['nothing'] = nothing_visual_basic

    if notinheritable_visual_basic is None or isinstance(notinheritable_visual_basic, list) and all(x is None for x in notinheritable_visual_basic):
        logger.error('notinheritable_visual_basic is required.')
        return ['notinheritable_visual_basic is required.']
    if notinheritable_visual_basic is not None:

        request_parameters['notinheritable'] = notinheritable_visual_basic

    if notoverridable_visual_basic is None or isinstance(notoverridable_visual_basic, list) and all(x is None for x in notoverridable_visual_basic):
        logger.error('notoverridable_visual_basic is required.')
        return ['notoverridable_visual_basic is required.']
    if notoverridable_visual_basic is not None:

        request_parameters['notoverridable'] = notoverridable_visual_basic

    if object_visual_basic is None or isinstance(object_visual_basic, list) and all(x is None for x in object_visual_basic):
        logger.error('object_visual_basic is required.')
        return ['object_visual_basic is required.']
    if object_visual_basic is not None:

        request_parameters['object'] = object_visual_basic

    if of_visual_basic is None or isinstance(of_visual_basic, list) and all(x is None for x in of_visual_basic):
        logger.error('of_visual_basic is required.')
        return ['of_visual_basic is required.']
    if of_visual_basic is not None:

        request_parameters['of'] = of_visual_basic

    if on_visual_basic is None or isinstance(on_visual_basic, list) and all(x is None for x in on_visual_basic):
        logger.error('on_visual_basic is required.')
        return ['on_visual_basic is required.']
    if on_visual_basic is not None:

        request_parameters['on'] = on_visual_basic

    if operator_visual_basic is None or isinstance(operator_visual_basic, list) and all(x is None for x in operator_visual_basic):
        logger.error('operator_visual_basic is required.')
        return ['operator_visual_basic is required.']
    if operator_visual_basic is not None:

        request_parameters['operator'] = operator_visual_basic

    if option_visual_basic is None or isinstance(option_visual_basic, list) and all(x is None for x in option_visual_basic):
        logger.error('option_visual_basic is required.')
        return ['option_visual_basic is required.']
    if option_visual_basic is not None:

        request_parameters['option'] = option_visual_basic

    if optional_visual_basic is None or isinstance(optional_visual_basic, list) and all(x is None for x in optional_visual_basic):
        logger.error('optional_visual_basic is required.')
        return ['optional_visual_basic is required.']
    if optional_visual_basic is not None:

        request_parameters['optional'] = optional_visual_basic

    if or_visual_basic is None or isinstance(or_visual_basic, list) and all(x is None for x in or_visual_basic):
        logger.error('or_visual_basic is required.')
        return ['or_visual_basic is required.']
    if or_visual_basic is not None:

        request_parameters['or'] = or_visual_basic

    if orelse_visual_basic is None or isinstance(orelse_visual_basic, list) and all(x is None for x in orelse_visual_basic):
        logger.error('orelse_visual_basic is required.')
        return ['orelse_visual_basic is required.']
    if orelse_visual_basic is not None:

        request_parameters['orelse'] = orelse_visual_basic

    if overloads_visual_basic is None or isinstance(overloads_visual_basic, list) and all(x is None for x in overloads_visual_basic):
        logger.error('overloads_visual_basic is required.')
        return ['overloads_visual_basic is required.']
    if overloads_visual_basic is not None:

        request_parameters['overloads'] = overloads_visual_basic

    if overridable_visual_basic is None or isinstance(overridable_visual_basic, list) and all(x is None for x in overridable_visual_basic):
        logger.error('overridable_visual_basic is required.')
        return ['overridable_visual_basic is required.']
    if overridable_visual_basic is not None:

        request_parameters['overridable'] = overridable_visual_basic

    if overrides_visual_basic is None or isinstance(overrides_visual_basic, list) and all(x is None for x in overrides_visual_basic):
        logger.error('overrides_visual_basic is required.')
        return ['overrides_visual_basic is required.']
    if overrides_visual_basic is not None:

        request_parameters['overrides'] = overrides_visual_basic

    if paramarray_visual_basic is None or isinstance(paramarray_visual_basic, list) and all(x is None for x in paramarray_visual_basic):
        logger.error('paramarray_visual_basic is required.')
        return ['paramarray_visual_basic is required.']
    if paramarray_visual_basic is not None:

        request_parameters['paramarray'] = paramarray_visual_basic

    if partial_visual_basic is None or isinstance(partial_visual_basic, list) and all(x is None for x in partial_visual_basic):
        logger.error('partial_visual_basic is required.')
        return ['partial_visual_basic is required.']
    if partial_visual_basic is not None:

        request_parameters['partial'] = partial_visual_basic

    if private_visual_basic is None or isinstance(private_visual_basic, list) and all(x is None for x in private_visual_basic):
        logger.error('private_visual_basic is required.')
        return ['private_visual_basic is required.']
    if private_visual_basic is not None:

        request_parameters['private'] = private_visual_basic

    if property_visual_basic is None or isinstance(property_visual_basic, list) and all(x is None for x in property_visual_basic):
        logger.error('property_visual_basic is required.')
        return ['property_visual_basic is required.']
    if property_visual_basic is not None:

        request_parameters['property'] = property_visual_basic

    if protected_visual_basic is None or isinstance(protected_visual_basic, list) and all(x is None for x in protected_visual_basic):
        logger.error('protected_visual_basic is required.')
        return ['protected_visual_basic is required.']
    if protected_visual_basic is not None:

        request_parameters['protected'] = protected_visual_basic

    if public_visual_basic is None or isinstance(public_visual_basic, list) and all(x is None for x in public_visual_basic):
        logger.error('public_visual_basic is required.')
        return ['public_visual_basic is required.']
    if public_visual_basic is not None:

        request_parameters['public'] = public_visual_basic

    if raiseevent_visual_basic is None or isinstance(raiseevent_visual_basic, list) and all(x is None for x in raiseevent_visual_basic):
        logger.error('raiseevent_visual_basic is required.')
        return ['raiseevent_visual_basic is required.']
    if raiseevent_visual_basic is not None:

        request_parameters['raiseevent'] = raiseevent_visual_basic

    if readonly_visual_basic is None or isinstance(readonly_visual_basic, list) and all(x is None for x in readonly_visual_basic):
        logger.error('readonly_visual_basic is required.')
        return ['readonly_visual_basic is required.']
    if readonly_visual_basic is not None:

        request_parameters['readonly'] = readonly_visual_basic

    if redim_visual_basic is None or isinstance(redim_visual_basic, list) and all(x is None for x in redim_visual_basic):
        logger.error('redim_visual_basic is required.')
        return ['redim_visual_basic is required.']
    if redim_visual_basic is not None:

        request_parameters['redim'] = redim_visual_basic

    if rem_visual_basic is None or isinstance(rem_visual_basic, list) and all(x is None for x in rem_visual_basic):
        logger.error('rem_visual_basic is required.')
        return ['rem_visual_basic is required.']
    if rem_visual_basic is not None:

        request_parameters['rem'] = rem_visual_basic

    if removehandler_visual_basic is None or isinstance(removehandler_visual_basic, list) and all(x is None for x in removehandler_visual_basic):
        logger.error('removehandler_visual_basic is required.')
        return ['removehandler_visual_basic is required.']
    if removehandler_visual_basic is not None:

        request_parameters['removehandler'] = removehandler_visual_basic

    if resume_visual_basic is None or isinstance(resume_visual_basic, list) and all(x is None for x in resume_visual_basic):
        logger.error('resume_visual_basic is required.')
        return ['resume_visual_basic is required.']
    if resume_visual_basic is not None:

        request_parameters['resume'] = resume_visual_basic

    if return_visual_basic is None or isinstance(return_visual_basic, list) and all(x is None for x in return_visual_basic):
        logger.error('return_visual_basic is required.')
        return ['return_visual_basic is required.']
    if return_visual_basic is not None:

        request_parameters['return'] = return_visual_basic

    if sbyte_visual_basic is None or isinstance(sbyte_visual_basic, list) and all(x is None for x in sbyte_visual_basic):
        logger.error('sbyte_visual_basic is required.')
        return ['sbyte_visual_basic is required.']
    if sbyte_visual_basic is not None:

        request_parameters['sbyte'] = sbyte_visual_basic

    if select_visual_basic is None or isinstance(select_visual_basic, list) and all(x is None for x in select_visual_basic):
        logger.error('select_visual_basic is required.')
        return ['select_visual_basic is required.']
    if select_visual_basic is not None:

        request_parameters['select'] = select_visual_basic

    if set_visual_basic is None or isinstance(set_visual_basic, list) and all(x is None for x in set_visual_basic):
        logger.error('set_visual_basic is required.')
        return ['set_visual_basic is required.']
    if set_visual_basic is not None:

        request_parameters['set'] = set_visual_basic

    if shadows_visual_basic is None or isinstance(shadows_visual_basic, list) and all(x is None for x in shadows_visual_basic):
        logger.error('shadows_visual_basic is required.')
        return ['shadows_visual_basic is required.']
    if shadows_visual_basic is not None:

        request_parameters['shadows'] = shadows_visual_basic

    if shared_visual_basic is None or isinstance(shared_visual_basic, list) and all(x is None for x in shared_visual_basic):
        logger.error('shared_visual_basic is required.')
        return ['shared_visual_basic is required.']
    if shared_visual_basic is not None:

        request_parameters['shared'] = shared_visual_basic

    if short_visual_basic is None or isinstance(short_visual_basic, list) and all(x is None for x in short_visual_basic):
        logger.error('short_visual_basic is required.')
        return ['short_visual_basic is required.']
    if short_visual_basic is not None:

        request_parameters['short'] = short_visual_basic

    if single_visual_basic is None or isinstance(single_visual_basic, list) and all(x is None for x in single_visual_basic):
        logger.error('single_visual_basic is required.')
        return ['single_visual_basic is required.']
    if single_visual_basic is not None:

        request_parameters['single'] = single_visual_basic

    if static_visual_basic is None or isinstance(static_visual_basic, list) and all(x is None for x in static_visual_basic):
        logger.error('static_visual_basic is required.')
        return ['static_visual_basic is required.']
    if static_visual_basic is not None:

        request_parameters['static'] = static_visual_basic

    if step_visual_basic is None or isinstance(step_visual_basic, list) and all(x is None for x in step_visual_basic):
        logger.error('step_visual_basic is required.')
        return ['step_visual_basic is required.']
    if step_visual_basic is not None:

        request_parameters['step'] = step_visual_basic

    if stop_visual_basic is None or isinstance(stop_visual_basic, list) and all(x is None for x in stop_visual_basic):
        logger.error('stop_visual_basic is required.')
        return ['stop_visual_basic is required.']
    if stop_visual_basic is not None:

        request_parameters['stop'] = stop_visual_basic

    if string_visual_basic is None or isinstance(string_visual_basic, list) and all(x is None for x in string_visual_basic):
        logger.error('string_visual_basic is required.')
        return ['string_visual_basic is required.']
    if string_visual_basic is not None:

        request_parameters['string'] = string_visual_basic

    if structure_visual_basic is None or isinstance(structure_visual_basic, list) and all(x is None for x in structure_visual_basic):
        logger.error('structure_visual_basic is required.')
        return ['structure_visual_basic is required.']
    if structure_visual_basic is not None:

        request_parameters['structure'] = structure_visual_basic

    if sub_visual_basic is None or isinstance(sub_visual_basic, list) and all(x is None for x in sub_visual_basic):
        logger.error('sub_visual_basic is required.')
        return ['sub_visual_basic is required.']
    if sub_visual_basic is not None:

        request_parameters['sub'] = sub_visual_basic

    if synclock_visual_basic is None or isinstance(synclock_visual_basic, list) and all(x is None for x in synclock_visual_basic):
        logger.error('synclock_visual_basic is required.')
        return ['synclock_visual_basic is required.']
    if synclock_visual_basic is not None:

        request_parameters['synclock'] = synclock_visual_basic

    if then_visual_basic is None or isinstance(then_visual_basic, list) and all(x is None for x in then_visual_basic):
        logger.error('then_visual_basic is required.')
        return ['then_visual_basic is required.']
    if then_visual_basic is not None:

        request_parameters['then'] = then_visual_basic

    if throw_visual_basic is None or isinstance(throw_visual_basic, list) and all(x is None for x in throw_visual_basic):
        logger.error('throw_visual_basic is required.')
        return ['throw_visual_basic is required.']
    if throw_visual_basic is not None:

        request_parameters['throw'] = throw_visual_basic

    if to_visual_basic is None or isinstance(to_visual_basic, list) and all(x is None for x in to_visual_basic):
        logger.error('to_visual_basic is required.')
        return ['to_visual_basic is required.']
    if to_visual_basic is not None:

        request_parameters['to'] = to_visual_basic

    if try_visual_basic is None or isinstance(try_visual_basic, list) and all(x is None for x in try_visual_basic):
        logger.error('try_visual_basic is required.')
        return ['try_visual_basic is required.']
    if try_visual_basic is not None:

        request_parameters['try'] = try_visual_basic

    if trycast_visual_basic is None or isinstance(trycast_visual_basic, list) and all(x is None for x in trycast_visual_basic):
        logger.error('trycast_visual_basic is required.')
        return ['trycast_visual_basic is required.']
    if trycast_visual_basic is not None:

        request_parameters['trycast'] = trycast_visual_basic

    if type_visual_basic is None or isinstance(type_visual_basic, list) and all(x is None for x in type_visual_basic):
        logger.error('type_visual_basic is required.')
        return ['type_visual_basic is required.']
    if type_visual_basic is not None:

        request_parameters['type'] = type_visual_basic

    if typeof_visual_basic is None or isinstance(typeof_visual_basic, list) and all(x is None for x in typeof_visual_basic):
        logger.error('typeof_visual_basic is required.')
        return ['typeof_visual_basic is required.']
    if typeof_visual_basic is not None:

        request_parameters['typeof'] = typeof_visual_basic

    if uinteger_visual_basic is None or isinstance(uinteger_visual_basic, list) and all(x is None for x in uinteger_visual_basic):
        logger.error('uinteger_visual_basic is required.')
        return ['uinteger_visual_basic is required.']
    if uinteger_visual_basic is not None:

        request_parameters['uinteger'] = uinteger_visual_basic

    if ulong_visual_basic is None or isinstance(ulong_visual_basic, list) and all(x is None for x in ulong_visual_basic):
        logger.error('ulong_visual_basic is required.')
        return ['ulong_visual_basic is required.']
    if ulong_visual_basic is not None:

        request_parameters['ulong'] = ulong_visual_basic

    if ushort_visual_basic is None or isinstance(ushort_visual_basic, list) and all(x is None for x in ushort_visual_basic):
        logger.error('ushort_visual_basic is required.')
        return ['ushort_visual_basic is required.']
    if ushort_visual_basic is not None:

        request_parameters['ushort'] = ushort_visual_basic

    if using_visual_basic is None or isinstance(using_visual_basic, list) and all(x is None for x in using_visual_basic):
        logger.error('using_visual_basic is required.')
        return ['using_visual_basic is required.']
    if using_visual_basic is not None:

        request_parameters['using'] = using_visual_basic

    if variant_visual_basic is None or isinstance(variant_visual_basic, list) and all(x is None for x in variant_visual_basic):
        logger.error('variant_visual_basic is required.')
        return ['variant_visual_basic is required.']
    if variant_visual_basic is not None:

        request_parameters['variant'] = variant_visual_basic

    if wend_visual_basic is None or isinstance(wend_visual_basic, list) and all(x is None for x in wend_visual_basic):
        logger.error('wend_visual_basic is required.')
        return ['wend_visual_basic is required.']
    if wend_visual_basic is not None:

        request_parameters['wend'] = wend_visual_basic

    if when_visual_basic is None or isinstance(when_visual_basic, list) and all(x is None for x in when_visual_basic):
        logger.error('when_visual_basic is required.')
        return ['when_visual_basic is required.']
    if when_visual_basic is not None:

        request_parameters['when'] = when_visual_basic

    if while_visual_basic is None or isinstance(while_visual_basic, list) and all(x is None for x in while_visual_basic):
        logger.error('while_visual_basic is required.')
        return ['while_visual_basic is required.']
    if while_visual_basic is not None:

        request_parameters['while'] = while_visual_basic

    if widening_visual_basic is None or isinstance(widening_visual_basic, list) and all(x is None for x in widening_visual_basic):
        logger.error('widening_visual_basic is required.')
        return ['widening_visual_basic is required.']
    if widening_visual_basic is not None:

        request_parameters['widening'] = widening_visual_basic

    if with_visual_basic is None or isinstance(with_visual_basic, list) and all(x is None for x in with_visual_basic):
        logger.error('with_visual_basic is required.')
        return ['with_visual_basic is required.']
    if with_visual_basic is not None:

        request_parameters['with'] = with_visual_basic

    if withevents_visual_basic is None or isinstance(withevents_visual_basic, list) and all(x is None for x in withevents_visual_basic):
        logger.error('withevents_visual_basic is required.')
        return ['withevents_visual_basic is required.']
    if withevents_visual_basic is not None:

        request_parameters['withevents'] = withevents_visual_basic

    if writeonly_visual_basic is None or isinstance(writeonly_visual_basic, list) and all(x is None for x in writeonly_visual_basic):
        logger.error('writeonly_visual_basic is required.')
        return ['writeonly_visual_basic is required.']
    if writeonly_visual_basic is not None:

        request_parameters['writeonly'] = writeonly_visual_basic

    if xor_visual_basic is None or isinstance(xor_visual_basic, list) and all(x is None for x in xor_visual_basic):
        logger.error('xor_visual_basic is required.')
        return ['xor_visual_basic is required.']
    if xor_visual_basic is not None:

        request_parameters['xor'] = xor_visual_basic


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8949/test/vba/restricted/keywords'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=vba_keywords_test_put_test_vba_restricted_keywords] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'$ref', u'#/definitions/VBAKeywords'), (u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('vba_keywords_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=vba_keywords_test_put_test_vba_restricted_keywords] [url=http://localhost:8949/test/vba/restricted/keywords].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=vba_keywords_test_put_test_vba_restricted_keywords] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=vba_keywords_test_put_test_vba_restricted_keywords] [url=http://localhost:8949/test/vba/restricted/keywords].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

all_definitions['without_parameter_test'] = OrderedDict([(u'Test', OrderedDict([(u'properties', OrderedDict())]))])


@caching
@xw.func(category='without_parameter_test', call_in_wizard=False)
@xw.ret(expand='table')
def without_parameter_test_delete_test_json_without_parameter():
    logger.info("[status=Calling] [function=without_parameter_test_delete_test_json_without_parameter]...")
    request_header = {'Accept': 'application/json'}


    response = None
    try:
        response = session.get(5).request('delete', 'http://localhost:8950/test/json/without/parameter'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=without_parameter_test_delete_test_json_without_parameter] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'$ref', u'#/definitions/Test'), (u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('without_parameter_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=without_parameter_test_delete_test_json_without_parameter] [url=http://localhost:8950/test/json/without/parameter].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=without_parameter_test_delete_test_json_without_parameter] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=without_parameter_test_delete_test_json_without_parameter] [url=http://localhost:8950/test/json/without/parameter].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='without_parameter_test', call_in_wizard=False)
@xw.ret(expand='table')
def without_parameter_test_get_test_json_without_parameter():
    logger.info("[status=Calling] [function=without_parameter_test_get_test_json_without_parameter]...")
    request_header = {'Accept': 'application/json'}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8950/test/json/without/parameter'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=without_parameter_test_get_test_json_without_parameter] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'$ref', u'#/definitions/Test'), (u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('without_parameter_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=without_parameter_test_get_test_json_without_parameter] [url=http://localhost:8950/test/json/without/parameter].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=without_parameter_test_get_test_json_without_parameter] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=without_parameter_test_get_test_json_without_parameter] [url=http://localhost:8950/test/json/without/parameter].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='without_parameter_test', call_in_wizard=False)
@xw.ret(expand='table')
def without_parameter_test_post_test_json_without_parameter():
    logger.info("[status=Calling] [function=without_parameter_test_post_test_json_without_parameter]...")
    request_header = {'Accept': 'application/json'}


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8950/test/json/without/parameter'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=without_parameter_test_post_test_json_without_parameter] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'$ref', u'#/definitions/Test'), (u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('without_parameter_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=without_parameter_test_post_test_json_without_parameter] [url=http://localhost:8950/test/json/without/parameter].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=without_parameter_test_post_test_json_without_parameter] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=without_parameter_test_post_test_json_without_parameter] [url=http://localhost:8950/test/json/without/parameter].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='without_parameter_test', call_in_wizard=False)
@xw.ret(expand='table')
def without_parameter_test_put_test_json_without_parameter():
    logger.info("[status=Calling] [function=without_parameter_test_put_test_json_without_parameter]...")
    request_header = {'Accept': 'application/json'}


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8950/test/json/without/parameter'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=without_parameter_test_put_test_json_without_parameter] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'$ref', u'#/definitions/Test'), (u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('without_parameter_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=without_parameter_test_put_test_json_without_parameter] [url=http://localhost:8950/test/json/without/parameter].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=without_parameter_test_put_test_json_without_parameter] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=without_parameter_test_put_test_json_without_parameter] [url=http://localhost:8950/test/json/without/parameter].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='without_parameter_test', call_in_wizard=False)
def without_parameter_test_delete_test_plain_text_without_parameter():
    logger.info("[status=Calling] [function=without_parameter_test_delete_test_plain_text_without_parameter]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('delete', 'http://localhost:8950/test/plain/text/without/parameter'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=without_parameter_test_delete_test_plain_text_without_parameter] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('without_parameter_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=without_parameter_test_delete_test_plain_text_without_parameter] [url=http://localhost:8950/test/plain/text/without/parameter].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=without_parameter_test_delete_test_plain_text_without_parameter] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=without_parameter_test_delete_test_plain_text_without_parameter] [url=http://localhost:8950/test/plain/text/without/parameter].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='without_parameter_test', call_in_wizard=False)
def without_parameter_test_get_test_plain_text_without_parameter():
    logger.info("[status=Calling] [function=without_parameter_test_get_test_plain_text_without_parameter]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8950/test/plain/text/without/parameter'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=without_parameter_test_get_test_plain_text_without_parameter] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value'), (u'schema', OrderedDict([(u'type', u'string')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('without_parameter_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=without_parameter_test_get_test_plain_text_without_parameter] [url=http://localhost:8950/test/plain/text/without/parameter].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=without_parameter_test_get_test_plain_text_without_parameter] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=without_parameter_test_get_test_plain_text_without_parameter] [url=http://localhost:8950/test/plain/text/without/parameter].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='without_parameter_test', call_in_wizard=False)
def without_parameter_test_post_test_plain_text_without_parameter():
    logger.info("[status=Calling] [function=without_parameter_test_post_test_plain_text_without_parameter]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8950/test/plain/text/without/parameter'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=without_parameter_test_post_test_plain_text_without_parameter] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('without_parameter_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=without_parameter_test_post_test_plain_text_without_parameter] [url=http://localhost:8950/test/plain/text/without/parameter].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=without_parameter_test_post_test_plain_text_without_parameter] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=without_parameter_test_post_test_plain_text_without_parameter] [url=http://localhost:8950/test/plain/text/without/parameter].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='without_parameter_test', call_in_wizard=False)
def without_parameter_test_put_test_plain_text_without_parameter():
    logger.info("[status=Calling] [function=without_parameter_test_put_test_plain_text_without_parameter]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8950/test/plain/text/without/parameter'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=without_parameter_test_put_test_plain_text_without_parameter] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('without_parameter_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=without_parameter_test_put_test_plain_text_without_parameter] [url=http://localhost:8950/test/plain/text/without/parameter].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=without_parameter_test_put_test_plain_text_without_parameter] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=without_parameter_test_put_test_plain_text_without_parameter] [url=http://localhost:8950/test/plain/text/without/parameter].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='without_parameter_test', call_in_wizard=False)
def without_parameter_test_delete_test_without_parameter():
    logger.info("[status=Calling] [function=without_parameter_test_delete_test_without_parameter]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('delete', 'http://localhost:8950/test/without/parameter'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=without_parameter_test_delete_test_without_parameter] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'DELETE performed properly')]))])
            return json_as_list(response, all_responses, all_definitions.get('without_parameter_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=without_parameter_test_delete_test_without_parameter] [url=http://localhost:8950/test/without/parameter].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=without_parameter_test_delete_test_without_parameter] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=without_parameter_test_delete_test_without_parameter] [url=http://localhost:8950/test/without/parameter].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='without_parameter_test', call_in_wizard=False)
def without_parameter_test_get_test_without_parameter():
    logger.info("[status=Calling] [function=without_parameter_test_get_test_without_parameter]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8950/test/without/parameter'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=without_parameter_test_get_test_without_parameter] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value'), (u'schema', OrderedDict([(u'type', u'string')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('without_parameter_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=without_parameter_test_get_test_without_parameter] [url=http://localhost:8950/test/without/parameter].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=without_parameter_test_get_test_without_parameter] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=without_parameter_test_get_test_without_parameter] [url=http://localhost:8950/test/without/parameter].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='without_parameter_test', call_in_wizard=False)
def without_parameter_test_post_test_without_parameter():
    logger.info("[status=Calling] [function=without_parameter_test_post_test_without_parameter]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8950/test/without/parameter'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=without_parameter_test_post_test_without_parameter] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'POST performed properly')]))])
            return json_as_list(response, all_responses, all_definitions.get('without_parameter_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=without_parameter_test_post_test_without_parameter] [url=http://localhost:8950/test/without/parameter].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=without_parameter_test_post_test_without_parameter] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=without_parameter_test_post_test_without_parameter] [url=http://localhost:8950/test/without/parameter].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='without_parameter_test', call_in_wizard=False)
def without_parameter_test_put_test_without_parameter():
    logger.info("[status=Calling] [function=without_parameter_test_put_test_without_parameter]...")
    request_header = {}


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8950/test/without/parameter'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=without_parameter_test_put_test_without_parameter] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'PUT performed properly')]))])
            return json_as_list(response, all_responses, all_definitions.get('without_parameter_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=without_parameter_test_put_test_without_parameter] [url=http://localhost:8950/test/without/parameter].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=without_parameter_test_put_test_without_parameter] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=without_parameter_test_put_test_without_parameter] [url=http://localhost:8950/test/without/parameter].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

all_definitions['header_parameter_test'] = OrderedDict([(u'Header', OrderedDict([(u'properties', OrderedDict([(u'Accept', OrderedDict([(u'type', u'string')])), (u'Accept-Encoding', OrderedDict([(u'type', u'string')])), (u'Connection', OrderedDict([(u'type', u'string')])), (u'Content-Length', OrderedDict([(u'type', u'string')])), (u'Content-Type', OrderedDict([(u'type', u'string')])), (u'Header-String', OrderedDict([(u'type', u'string')])), (u'Host', OrderedDict([(u'type', u'string')])), (u'User-Agent', OrderedDict([(u'type', u'string')]))])), (u'title', u'Test'), (u'type', u'object')]))])


@caching
@xw.func(category='header_parameter_test', call_in_wizard=False)
@xw.arg('header_string', doc='header parameter')
def header_parameter_test_get_test_header_parameter(header_string):
    logger.info("[status=Calling] [function=header_parameter_test_get_test_header_parameter]...")
    request_header = {}

    if header_string is None or isinstance(header_string, list) and all(x is None for x in header_string):
        logger.error('header_string is required.')
        return 'header_string is required.'
    if header_string is not None:

        request_header['header_string'] = header_string


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8951/test/header/parameter'.format(), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=header_parameter_test_get_test_header_parameter] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'$ref', u'#/definitions/Header')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('header_parameter_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=header_parameter_test_get_test_header_parameter] [url=http://localhost:8951/test/header/parameter].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=header_parameter_test_get_test_header_parameter] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=header_parameter_test_get_test_header_parameter] [url=http://localhost:8951/test/header/parameter].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

all_definitions['form_parameter_test'] = OrderedDict([(u'Form', OrderedDict([(u'properties', OrderedDict([(u'form_string', OrderedDict([(u'type', u'string')]))])), (u'title', u'Test'), (u'type', u'object')]))])


@caching
@xw.func(category='form_parameter_test', call_in_wizard=False)
@xw.arg('form_string', doc='form parameter')
def form_parameter_test_post_test_form_parameter(form_string):
    logger.info("[status=Calling] [function=form_parameter_test_post_test_form_parameter]...")
    request_header = {'Content-Type': 'application/json'}
    request_payload = {}

    if form_string is None or isinstance(form_string, list) and all(x is None for x in form_string):
        logger.error('form_string is required.')
        return 'form_string is required.'
    if form_string is not None:

        request_payload['form_string'] = form_string


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8952/test/form/parameter'.format(), json=request_payload, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=form_parameter_test_post_test_form_parameter] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'$ref', u'#/definitions/Form')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('form_parameter_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=form_parameter_test_post_test_form_parameter] [url=http://localhost:8952/test/form/parameter].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=form_parameter_test_post_test_form_parameter] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=form_parameter_test_post_test_form_parameter] [url=http://localhost:8952/test/form/parameter].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

all_definitions['array_parameter_test'] = OrderedDict([(u'TestObject', OrderedDict([(u'properties', OrderedDict([(u'test', OrderedDict([(u'description', u'test'), (u'type', u'string')]))])), (u'title', u'Test'), (u'type', u'object')]))])


@caching
@xw.func(category='array_parameter_test', call_in_wizard=False)
@xw.arg('query_array_string', doc='string array parameter')
def array_parameter_test_get_test_string_array_parameter(query_array_string):
    logger.info("[status=Calling] [function=array_parameter_test_get_test_string_array_parameter]...")
    request_header = {}
    request_parameters = {}

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return 'query_array_string is required.'
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8953/test/string/array/parameter'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=array_parameter_test_get_test_string_array_parameter] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('array_parameter_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=array_parameter_test_get_test_string_array_parameter] [url=http://localhost:8953/test/string/array/parameter].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=array_parameter_test_get_test_string_array_parameter] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=array_parameter_test_get_test_string_array_parameter] [url=http://localhost:8953/test/string/array/parameter].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

all_definitions['json_test'] = OrderedDict([(u'AllMandatoryParameters', OrderedDict([(u'properties', OrderedDict([(u'query_array_boolean', OrderedDict()), (u'query_array_date', OrderedDict([(u'items', OrderedDict([(u'format', u'date'), (u'type', u'string')])), (u'type', u'array')])), (u'query_array_date_time', OrderedDict([(u'items', OrderedDict([(u'format', u'date-time'), (u'type', u'string')])), (u'type', u'array')])), (u'query_array_double', OrderedDict()), (u'query_array_float', OrderedDict()), (u'query_array_integer', OrderedDict()), (u'query_array_integer32', OrderedDict()), (u'query_array_integer64', OrderedDict()), (u'query_array_number', OrderedDict()), (u'query_array_password', OrderedDict()), (u'query_array_string', OrderedDict()), (u'query_array_string_binary', OrderedDict()), (u'query_array_string_byte', OrderedDict()), (u'query_boolean', OrderedDict()), (u'query_date', OrderedDict([(u'format', u'date'), (u'type', u'string')])), (u'query_date_time', OrderedDict([(u'format', u'date-time'), (u'type', u'string')])), (u'query_double', OrderedDict()), (u'query_float', OrderedDict()), (u'query_integer', OrderedDict()), (u'query_integer32', OrderedDict()), (u'query_integer64', OrderedDict()), (u'query_number', OrderedDict()), (u'query_password', OrderedDict()), (u'query_string', OrderedDict()), (u'query_string_binary', OrderedDict()), (u'query_string_byte', OrderedDict())]))])), (u'TestObject', OrderedDict([(u'properties', OrderedDict([(u'test', OrderedDict([(u'description', u'test'), (u'type', u'string')]))])), (u'title', u'Test'), (u'type', u'object')]))])


@caching
@xw.func(category='json_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
@xw.ret(expand='table')
def json_test_delete_test_json_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=json_test_delete_test_json_with_all_optional_parameters_types]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return ['query_integer must be an integer.']

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return ['query_integer32 must be an integer.']

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return ['query_integer64 must be an integer.']

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return ['query_number must be a number.']

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return ['query_float must be a number.']

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return ['query_double must be a number.']

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return ['query_boolean must be either "true" or "false".']
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return ['query_date must be a date.']

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return ['query_date_time must be a date time.']

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return ['query_array_integer must contain integers.']
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return ['query_array_integer must be an integer.']

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return ['query_array_integer32 must contain integers.']
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return ['query_array_integer32 must be an integer.']

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return ['query_array_integer64 must contain integers.']
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return ['query_array_integer64 must be an integer.']

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return ['query_array_number must contain numbers.']
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return ['query_array_number must be a number.']

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return ['query_array_float must contain numbers.']
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return ['query_array_float must be a number.']

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return ['query_array_double must contain numbers.']
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return ['query_array_double must be a number.']

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return ['query_array_boolean must be either "true" or "false".']
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return ['query_array_boolean must contain "true" or "false".']
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return ['query_array_date must contain dates.']
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return ['query_array_date must be a date.']

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return ['query_array_date_time must contain date times.']
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return ['query_array_date_time must be a date time.']

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('delete', 'http://localhost:8954/test/json/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_test_delete_test_json_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_test_delete_test_json_with_all_optional_parameters_types] [url=http://localhost:8954/test/json/with/all/optional/parameters/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_test_delete_test_json_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_test_delete_test_json_with_all_optional_parameters_types] [url=http://localhost:8954/test/json/with/all/optional/parameters/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
@xw.ret(expand='table')
def json_test_get_test_json_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=json_test_get_test_json_with_all_optional_parameters_types]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return ['query_integer must be an integer.']

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return ['query_integer32 must be an integer.']

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return ['query_integer64 must be an integer.']

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return ['query_number must be a number.']

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return ['query_float must be a number.']

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return ['query_double must be a number.']

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return ['query_boolean must be either "true" or "false".']
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return ['query_date must be a date.']

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return ['query_date_time must be a date time.']

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return ['query_array_integer must contain integers.']
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return ['query_array_integer must be an integer.']

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return ['query_array_integer32 must contain integers.']
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return ['query_array_integer32 must be an integer.']

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return ['query_array_integer64 must contain integers.']
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return ['query_array_integer64 must be an integer.']

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return ['query_array_number must contain numbers.']
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return ['query_array_number must be a number.']

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return ['query_array_float must contain numbers.']
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return ['query_array_float must be a number.']

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return ['query_array_double must contain numbers.']
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return ['query_array_double must be a number.']

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return ['query_array_boolean must be either "true" or "false".']
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return ['query_array_boolean must contain "true" or "false".']
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return ['query_array_date must contain dates.']
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return ['query_array_date must be a date.']

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return ['query_array_date_time must contain date times.']
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return ['query_array_date_time must be a date time.']

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8954/test/json/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_test_get_test_json_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_test_get_test_json_with_all_optional_parameters_types] [url=http://localhost:8954/test/json/with/all/optional/parameters/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_test_get_test_json_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_test_get_test_json_with_all_optional_parameters_types] [url=http://localhost:8954/test/json/with/all/optional/parameters/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
@xw.ret(expand='table')
def json_test_post_test_json_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=json_test_post_test_json_with_all_optional_parameters_types]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return ['query_integer must be an integer.']

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return ['query_integer32 must be an integer.']

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return ['query_integer64 must be an integer.']

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return ['query_number must be a number.']

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return ['query_float must be a number.']

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return ['query_double must be a number.']

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return ['query_boolean must be either "true" or "false".']
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return ['query_date must be a date.']

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return ['query_date_time must be a date time.']

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return ['query_array_integer must contain integers.']
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return ['query_array_integer must be an integer.']

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return ['query_array_integer32 must contain integers.']
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return ['query_array_integer32 must be an integer.']

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return ['query_array_integer64 must contain integers.']
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return ['query_array_integer64 must be an integer.']

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return ['query_array_number must contain numbers.']
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return ['query_array_number must be a number.']

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return ['query_array_float must contain numbers.']
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return ['query_array_float must be a number.']

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return ['query_array_double must contain numbers.']
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return ['query_array_double must be a number.']

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return ['query_array_boolean must be either "true" or "false".']
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return ['query_array_boolean must contain "true" or "false".']
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return ['query_array_date must contain dates.']
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return ['query_array_date must be a date.']

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return ['query_array_date_time must contain date times.']
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return ['query_array_date_time must be a date time.']

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8954/test/json/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_test_post_test_json_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_test_post_test_json_with_all_optional_parameters_types] [url=http://localhost:8954/test/json/with/all/optional/parameters/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_test_post_test_json_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_test_post_test_json_with_all_optional_parameters_types] [url=http://localhost:8954/test/json/with/all/optional/parameters/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
@xw.ret(expand='table')
def json_test_put_test_json_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=json_test_put_test_json_with_all_optional_parameters_types]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return ['query_integer must be an integer.']

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return ['query_integer32 must be an integer.']

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return ['query_integer64 must be an integer.']

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return ['query_number must be a number.']

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return ['query_float must be a number.']

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return ['query_double must be a number.']

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return ['query_boolean must be either "true" or "false".']
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return ['query_date must be a date.']

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return ['query_date_time must be a date time.']

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return ['query_array_integer must contain integers.']
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return ['query_array_integer must be an integer.']

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return ['query_array_integer32 must contain integers.']
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return ['query_array_integer32 must be an integer.']

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return ['query_array_integer64 must contain integers.']
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return ['query_array_integer64 must be an integer.']

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return ['query_array_number must contain numbers.']
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return ['query_array_number must be a number.']

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return ['query_array_float must contain numbers.']
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return ['query_array_float must be a number.']

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return ['query_array_double must contain numbers.']
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return ['query_array_double must be a number.']

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return ['query_array_boolean must be either "true" or "false".']
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return ['query_array_boolean must contain "true" or "false".']
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return ['query_array_date must contain dates.']
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return ['query_array_date must be a date.']

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return ['query_array_date_time must contain date times.']
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return ['query_array_date_time must be a date time.']

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8954/test/json/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_test_put_test_json_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_test_put_test_json_with_all_optional_parameters_types] [url=http://localhost:8954/test/json/with/all/optional/parameters/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_test_put_test_json_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_test_put_test_json_with_all_optional_parameters_types] [url=http://localhost:8954/test/json/with/all/optional/parameters/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
@xw.ret(expand='table')
def json_test_delete_test_json_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=json_test_delete_test_json_with_all_parameters_types]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return ['query_integer is required.']
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return ['query_integer must be an integer.']

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return ['query_integer32 is required.']
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return ['query_integer32 must be an integer.']

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return ['query_integer64 is required.']
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return ['query_integer64 must be an integer.']

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return ['query_number is required.']
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return ['query_number must be a number.']

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return ['query_float is required.']
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return ['query_float must be a number.']

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return ['query_double is required.']
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return ['query_double must be a number.']

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return ['query_string is required.']
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return ['query_string_byte is required.']
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return ['query_string_binary is required.']
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return ['query_boolean is required.']
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return ['query_boolean must be either "true" or "false".']
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return ['query_date is required.']
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return ['query_date must be a date.']

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return ['query_date_time is required.']
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return ['query_date_time must be a date time.']

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return ['query_password is required.']
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return ['query_array_integer is required.']
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return ['query_array_integer must contain integers.']
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return ['query_array_integer must be an integer.']

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return ['query_array_integer32 is required.']
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return ['query_array_integer32 must contain integers.']
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return ['query_array_integer32 must be an integer.']

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return ['query_array_integer64 is required.']
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return ['query_array_integer64 must contain integers.']
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return ['query_array_integer64 must be an integer.']

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return ['query_array_number is required.']
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return ['query_array_number must contain numbers.']
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return ['query_array_number must be a number.']

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return ['query_array_float is required.']
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return ['query_array_float must contain numbers.']
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return ['query_array_float must be a number.']

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return ['query_array_double is required.']
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return ['query_array_double must contain numbers.']
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return ['query_array_double must be a number.']

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return ['query_array_string is required.']
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return ['query_array_string_byte is required.']
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return ['query_array_string_binary is required.']
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return ['query_array_boolean is required.']
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return ['query_array_boolean must be either "true" or "false".']
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return ['query_array_boolean must contain "true" or "false".']
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return ['query_array_date is required.']
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return ['query_array_date must contain dates.']
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return ['query_array_date must be a date.']

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return ['query_array_date_time is required.']
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return ['query_array_date_time must contain date times.']
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return ['query_array_date_time must be a date time.']

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return ['query_array_password is required.']
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('delete', 'http://localhost:8954/test/json/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_test_delete_test_json_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_test_delete_test_json_with_all_parameters_types] [url=http://localhost:8954/test/json/with/all/parameters/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_test_delete_test_json_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_test_delete_test_json_with_all_parameters_types] [url=http://localhost:8954/test/json/with/all/parameters/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
@xw.ret(expand='table')
def json_test_get_test_json_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=json_test_get_test_json_with_all_parameters_types]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return ['query_integer is required.']
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return ['query_integer must be an integer.']

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return ['query_integer32 is required.']
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return ['query_integer32 must be an integer.']

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return ['query_integer64 is required.']
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return ['query_integer64 must be an integer.']

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return ['query_number is required.']
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return ['query_number must be a number.']

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return ['query_float is required.']
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return ['query_float must be a number.']

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return ['query_double is required.']
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return ['query_double must be a number.']

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return ['query_string is required.']
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return ['query_string_byte is required.']
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return ['query_string_binary is required.']
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return ['query_boolean is required.']
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return ['query_boolean must be either "true" or "false".']
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return ['query_date is required.']
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return ['query_date must be a date.']

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return ['query_date_time is required.']
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return ['query_date_time must be a date time.']

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return ['query_password is required.']
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return ['query_array_integer is required.']
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return ['query_array_integer must contain integers.']
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return ['query_array_integer must be an integer.']

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return ['query_array_integer32 is required.']
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return ['query_array_integer32 must contain integers.']
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return ['query_array_integer32 must be an integer.']

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return ['query_array_integer64 is required.']
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return ['query_array_integer64 must contain integers.']
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return ['query_array_integer64 must be an integer.']

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return ['query_array_number is required.']
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return ['query_array_number must contain numbers.']
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return ['query_array_number must be a number.']

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return ['query_array_float is required.']
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return ['query_array_float must contain numbers.']
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return ['query_array_float must be a number.']

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return ['query_array_double is required.']
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return ['query_array_double must contain numbers.']
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return ['query_array_double must be a number.']

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return ['query_array_string is required.']
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return ['query_array_string_byte is required.']
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return ['query_array_string_binary is required.']
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return ['query_array_boolean is required.']
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return ['query_array_boolean must be either "true" or "false".']
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return ['query_array_boolean must contain "true" or "false".']
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return ['query_array_date is required.']
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return ['query_array_date must contain dates.']
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return ['query_array_date must be a date.']

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return ['query_array_date_time is required.']
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return ['query_array_date_time must contain date times.']
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return ['query_array_date_time must be a date time.']

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return ['query_array_password is required.']
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8954/test/json/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_test_get_test_json_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'$ref', u'#/definitions/AllMandatoryParameters')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_test_get_test_json_with_all_parameters_types] [url=http://localhost:8954/test/json/with/all/parameters/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_test_get_test_json_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_test_get_test_json_with_all_parameters_types] [url=http://localhost:8954/test/json/with/all/parameters/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
@xw.ret(expand='table')
def json_test_post_test_json_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=json_test_post_test_json_with_all_parameters_types]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return ['query_integer is required.']
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return ['query_integer must be an integer.']

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return ['query_integer32 is required.']
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return ['query_integer32 must be an integer.']

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return ['query_integer64 is required.']
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return ['query_integer64 must be an integer.']

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return ['query_number is required.']
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return ['query_number must be a number.']

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return ['query_float is required.']
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return ['query_float must be a number.']

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return ['query_double is required.']
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return ['query_double must be a number.']

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return ['query_string is required.']
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return ['query_string_byte is required.']
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return ['query_string_binary is required.']
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return ['query_boolean is required.']
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return ['query_boolean must be either "true" or "false".']
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return ['query_date is required.']
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return ['query_date must be a date.']

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return ['query_date_time is required.']
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return ['query_date_time must be a date time.']

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return ['query_password is required.']
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return ['query_array_integer is required.']
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return ['query_array_integer must contain integers.']
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return ['query_array_integer must be an integer.']

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return ['query_array_integer32 is required.']
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return ['query_array_integer32 must contain integers.']
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return ['query_array_integer32 must be an integer.']

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return ['query_array_integer64 is required.']
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return ['query_array_integer64 must contain integers.']
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return ['query_array_integer64 must be an integer.']

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return ['query_array_number is required.']
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return ['query_array_number must contain numbers.']
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return ['query_array_number must be a number.']

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return ['query_array_float is required.']
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return ['query_array_float must contain numbers.']
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return ['query_array_float must be a number.']

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return ['query_array_double is required.']
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return ['query_array_double must contain numbers.']
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return ['query_array_double must be a number.']

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return ['query_array_string is required.']
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return ['query_array_string_byte is required.']
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return ['query_array_string_binary is required.']
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return ['query_array_boolean is required.']
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return ['query_array_boolean must be either "true" or "false".']
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return ['query_array_boolean must contain "true" or "false".']
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return ['query_array_date is required.']
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return ['query_array_date must contain dates.']
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return ['query_array_date must be a date.']

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return ['query_array_date_time is required.']
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return ['query_array_date_time must contain date times.']
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return ['query_array_date_time must be a date time.']

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return ['query_array_password is required.']
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8954/test/json/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_test_post_test_json_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_test_post_test_json_with_all_parameters_types] [url=http://localhost:8954/test/json/with/all/parameters/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_test_post_test_json_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_test_post_test_json_with_all_parameters_types] [url=http://localhost:8954/test/json/with/all/parameters/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
@xw.ret(expand='table')
def json_test_put_test_json_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=json_test_put_test_json_with_all_parameters_types]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return ['query_integer is required.']
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return ['query_integer must be an integer.']

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return ['query_integer32 is required.']
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return ['query_integer32 must be an integer.']

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return ['query_integer64 is required.']
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return ['query_integer64 must be an integer.']

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return ['query_number is required.']
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return ['query_number must be a number.']

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return ['query_float is required.']
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return ['query_float must be a number.']

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return ['query_double is required.']
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return ['query_double must be a number.']

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return ['query_string is required.']
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return ['query_string_byte is required.']
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return ['query_string_binary is required.']
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return ['query_boolean is required.']
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return ['query_boolean must be either "true" or "false".']
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return ['query_date is required.']
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return ['query_date must be a date.']

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return ['query_date_time is required.']
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return ['query_date_time must be a date time.']

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return ['query_password is required.']
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return ['query_array_integer is required.']
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return ['query_array_integer must contain integers.']
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return ['query_array_integer must be an integer.']

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return ['query_array_integer32 is required.']
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return ['query_array_integer32 must contain integers.']
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return ['query_array_integer32 must be an integer.']

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return ['query_array_integer64 is required.']
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return ['query_array_integer64 must contain integers.']
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return ['query_array_integer64 must be an integer.']

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return ['query_array_number is required.']
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return ['query_array_number must contain numbers.']
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return ['query_array_number must be a number.']

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return ['query_array_float is required.']
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return ['query_array_float must contain numbers.']
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return ['query_array_float must be a number.']

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return ['query_array_double is required.']
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return ['query_array_double must contain numbers.']
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return ['query_array_double must be a number.']

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return ['query_array_string is required.']
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return ['query_array_string_byte is required.']
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return ['query_array_string_binary is required.']
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return ['query_array_boolean is required.']
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return ['query_array_boolean must be either "true" or "false".']
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return ['query_array_boolean must contain "true" or "false".']
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return ['query_array_date is required.']
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return ['query_array_date must contain dates.']
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return ['query_array_date must be a date.']

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return ['query_array_date_time is required.']
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return ['query_array_date_time must contain date times.']
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return ['query_array_date_time must be a date time.']

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return ['query_array_password is required.']
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8954/test/json/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_test_put_test_json_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_test_put_test_json_with_all_parameters_types] [url=http://localhost:8954/test/json/with/all/parameters/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_test_put_test_json_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_test_put_test_json_with_all_parameters_types] [url=http://localhost:8954/test/json/with/all/parameters/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
@xw.ret(expand='table')
def json_test_delete_test_json_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=json_test_delete_test_json_with_all_paths_types]...")
    request_header = {'Accept': 'application/json'}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return ['path_integer is required.']

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return ['path_integer32 is required.']

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return ['path_integer64 is required.']

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return ['path_number is required.']

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return ['path_float is required.']

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return ['path_double is required.']

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return ['path_string is required.']

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return ['path_string_byte is required.']

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return ['path_string_binary is required.']

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return ['path_boolean is required.']

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return ['path_date is required.']

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return ['path_date_time is required.']

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return ['path_password is required.']

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return ['path_array_integer is required.']

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return ['path_array_integer32 is required.']

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return ['path_array_integer64 is required.']

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return ['path_array_number is required.']

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return ['path_array_float is required.']

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return ['path_array_double is required.']

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return ['path_array_string is required.']

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return ['path_array_string_byte is required.']

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return ['path_array_string_binary is required.']

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return ['path_array_boolean is required.']

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return ['path_array_date is required.']

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return ['path_array_date_time is required.']

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return ['path_array_password is required.']


    response = None
    try:
        response = session.get(5).request('delete', 'http://localhost:8954/test/json/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_test_delete_test_json_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_test_delete_test_json_with_all_paths_types] [url=http://localhost:8954/test/json/with/all/paths/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_test_delete_test_json_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_test_delete_test_json_with_all_paths_types] [url=http://localhost:8954/test/json/with/all/paths/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
@xw.ret(expand='table')
def json_test_get_test_json_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=json_test_get_test_json_with_all_paths_types]...")
    request_header = {'Accept': 'application/json'}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return ['path_integer is required.']

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return ['path_integer32 is required.']

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return ['path_integer64 is required.']

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return ['path_number is required.']

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return ['path_float is required.']

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return ['path_double is required.']

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return ['path_string is required.']

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return ['path_string_byte is required.']

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return ['path_string_binary is required.']

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return ['path_boolean is required.']

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return ['path_date is required.']

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return ['path_date_time is required.']

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return ['path_password is required.']

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return ['path_array_integer is required.']

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return ['path_array_integer32 is required.']

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return ['path_array_integer64 is required.']

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return ['path_array_number is required.']

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return ['path_array_float is required.']

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return ['path_array_double is required.']

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return ['path_array_string is required.']

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return ['path_array_string_byte is required.']

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return ['path_array_string_binary is required.']

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return ['path_array_boolean is required.']

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return ['path_array_date is required.']

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return ['path_array_date_time is required.']

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return ['path_array_password is required.']


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8954/test/json/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_test_get_test_json_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_test_get_test_json_with_all_paths_types] [url=http://localhost:8954/test/json/with/all/paths/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_test_get_test_json_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_test_get_test_json_with_all_paths_types] [url=http://localhost:8954/test/json/with/all/paths/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
@xw.ret(expand='table')
def json_test_post_test_json_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=json_test_post_test_json_with_all_paths_types]...")
    request_header = {'Accept': 'application/json'}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return ['path_integer is required.']

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return ['path_integer32 is required.']

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return ['path_integer64 is required.']

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return ['path_number is required.']

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return ['path_float is required.']

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return ['path_double is required.']

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return ['path_string is required.']

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return ['path_string_byte is required.']

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return ['path_string_binary is required.']

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return ['path_boolean is required.']

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return ['path_date is required.']

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return ['path_date_time is required.']

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return ['path_password is required.']

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return ['path_array_integer is required.']

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return ['path_array_integer32 is required.']

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return ['path_array_integer64 is required.']

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return ['path_array_number is required.']

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return ['path_array_float is required.']

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return ['path_array_double is required.']

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return ['path_array_string is required.']

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return ['path_array_string_byte is required.']

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return ['path_array_string_binary is required.']

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return ['path_array_boolean is required.']

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return ['path_array_date is required.']

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return ['path_array_date_time is required.']

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return ['path_array_password is required.']


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8954/test/json/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_test_post_test_json_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_test_post_test_json_with_all_paths_types] [url=http://localhost:8954/test/json/with/all/paths/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_test_post_test_json_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_test_post_test_json_with_all_paths_types] [url=http://localhost:8954/test/json/with/all/paths/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
@xw.ret(expand='table')
def json_test_put_test_json_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=json_test_put_test_json_with_all_paths_types]...")
    request_header = {'Accept': 'application/json'}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return ['path_integer is required.']

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return ['path_integer32 is required.']

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return ['path_integer64 is required.']

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return ['path_number is required.']

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return ['path_float is required.']

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return ['path_double is required.']

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return ['path_string is required.']

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return ['path_string_byte is required.']

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return ['path_string_binary is required.']

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return ['path_boolean is required.']

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return ['path_date is required.']

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return ['path_date_time is required.']

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return ['path_password is required.']

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return ['path_array_integer is required.']

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return ['path_array_integer32 is required.']

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return ['path_array_integer64 is required.']

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return ['path_array_number is required.']

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return ['path_array_float is required.']

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return ['path_array_double is required.']

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return ['path_array_string is required.']

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return ['path_array_string_byte is required.']

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return ['path_array_string_binary is required.']

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return ['path_array_boolean is required.']

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return ['path_array_date is required.']

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return ['path_array_date_time is required.']

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return ['path_array_password is required.']


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8954/test/json/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_test_put_test_json_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_test_put_test_json_with_all_paths_types] [url=http://localhost:8954/test/json/with/all/paths/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_test_put_test_json_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_test_put_test_json_with_all_paths_types] [url=http://localhost:8954/test/json/with/all/paths/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

all_definitions['json_synchronous_test'] = OrderedDict([(u'AllMandatoryParameters', OrderedDict([(u'properties', OrderedDict([(u'query_array_boolean', OrderedDict()), (u'query_array_date', OrderedDict([(u'items', OrderedDict([(u'format', u'date'), (u'type', u'string')])), (u'type', u'array')])), (u'query_array_date_time', OrderedDict([(u'items', OrderedDict([(u'format', u'date-time'), (u'type', u'string')])), (u'type', u'array')])), (u'query_array_double', OrderedDict()), (u'query_array_float', OrderedDict()), (u'query_array_integer', OrderedDict()), (u'query_array_integer32', OrderedDict()), (u'query_array_integer64', OrderedDict()), (u'query_array_number', OrderedDict()), (u'query_array_password', OrderedDict()), (u'query_array_string', OrderedDict()), (u'query_array_string_binary', OrderedDict()), (u'query_array_string_byte', OrderedDict()), (u'query_boolean', OrderedDict()), (u'query_date', OrderedDict([(u'format', u'date'), (u'type', u'string')])), (u'query_date_time', OrderedDict([(u'format', u'date-time'), (u'type', u'string')])), (u'query_double', OrderedDict()), (u'query_float', OrderedDict()), (u'query_integer', OrderedDict()), (u'query_integer32', OrderedDict()), (u'query_integer64', OrderedDict()), (u'query_number', OrderedDict()), (u'query_password', OrderedDict()), (u'query_string', OrderedDict()), (u'query_string_binary', OrderedDict()), (u'query_string_byte', OrderedDict())]))])), (u'TestObject', OrderedDict([(u'properties', OrderedDict([(u'test', OrderedDict([(u'description', u'test'), (u'type', u'string')]))])), (u'title', u'Test'), (u'type', u'object')]))])


@caching
@xw.func(category='json_synchronous_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def json_synchronous_test_delete_test_json_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=json_synchronous_test_delete_test_json_with_all_optional_parameters_types]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return ['query_integer must be an integer.']

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return ['query_integer32 must be an integer.']

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return ['query_integer64 must be an integer.']

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return ['query_number must be a number.']

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return ['query_float must be a number.']

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return ['query_double must be a number.']

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return ['query_boolean must be either "true" or "false".']
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return ['query_date must be a date.']

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return ['query_date_time must be a date time.']

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return ['query_array_integer must contain integers.']
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return ['query_array_integer must be an integer.']

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return ['query_array_integer32 must contain integers.']
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return ['query_array_integer32 must be an integer.']

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return ['query_array_integer64 must contain integers.']
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return ['query_array_integer64 must be an integer.']

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return ['query_array_number must contain numbers.']
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return ['query_array_number must be a number.']

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return ['query_array_float must contain numbers.']
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return ['query_array_float must be a number.']

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return ['query_array_double must contain numbers.']
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return ['query_array_double must be a number.']

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return ['query_array_boolean must be either "true" or "false".']
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return ['query_array_boolean must contain "true" or "false".']
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return ['query_array_date must contain dates.']
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return ['query_array_date must be a date.']

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return ['query_array_date_time must contain date times.']
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return ['query_array_date_time must be a date time.']

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('delete', 'http://localhost:8954/test/json/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_synchronous_test_delete_test_json_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_synchronous_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_synchronous_test_delete_test_json_with_all_optional_parameters_types] [url=http://localhost:8954/test/json/with/all/optional/parameters/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_synchronous_test_delete_test_json_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_synchronous_test_delete_test_json_with_all_optional_parameters_types] [url=http://localhost:8954/test/json/with/all/optional/parameters/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_synchronous_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def json_synchronous_test_get_test_json_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=json_synchronous_test_get_test_json_with_all_optional_parameters_types]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return ['query_integer must be an integer.']

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return ['query_integer32 must be an integer.']

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return ['query_integer64 must be an integer.']

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return ['query_number must be a number.']

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return ['query_float must be a number.']

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return ['query_double must be a number.']

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return ['query_boolean must be either "true" or "false".']
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return ['query_date must be a date.']

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return ['query_date_time must be a date time.']

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return ['query_array_integer must contain integers.']
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return ['query_array_integer must be an integer.']

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return ['query_array_integer32 must contain integers.']
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return ['query_array_integer32 must be an integer.']

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return ['query_array_integer64 must contain integers.']
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return ['query_array_integer64 must be an integer.']

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return ['query_array_number must contain numbers.']
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return ['query_array_number must be a number.']

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return ['query_array_float must contain numbers.']
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return ['query_array_float must be a number.']

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return ['query_array_double must contain numbers.']
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return ['query_array_double must be a number.']

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return ['query_array_boolean must be either "true" or "false".']
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return ['query_array_boolean must contain "true" or "false".']
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return ['query_array_date must contain dates.']
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return ['query_array_date must be a date.']

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return ['query_array_date_time must contain date times.']
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return ['query_array_date_time must be a date time.']

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8954/test/json/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_synchronous_test_get_test_json_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_synchronous_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_synchronous_test_get_test_json_with_all_optional_parameters_types] [url=http://localhost:8954/test/json/with/all/optional/parameters/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_synchronous_test_get_test_json_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_synchronous_test_get_test_json_with_all_optional_parameters_types] [url=http://localhost:8954/test/json/with/all/optional/parameters/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_synchronous_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def json_synchronous_test_post_test_json_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=json_synchronous_test_post_test_json_with_all_optional_parameters_types]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return ['query_integer must be an integer.']

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return ['query_integer32 must be an integer.']

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return ['query_integer64 must be an integer.']

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return ['query_number must be a number.']

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return ['query_float must be a number.']

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return ['query_double must be a number.']

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return ['query_boolean must be either "true" or "false".']
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return ['query_date must be a date.']

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return ['query_date_time must be a date time.']

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return ['query_array_integer must contain integers.']
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return ['query_array_integer must be an integer.']

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return ['query_array_integer32 must contain integers.']
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return ['query_array_integer32 must be an integer.']

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return ['query_array_integer64 must contain integers.']
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return ['query_array_integer64 must be an integer.']

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return ['query_array_number must contain numbers.']
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return ['query_array_number must be a number.']

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return ['query_array_float must contain numbers.']
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return ['query_array_float must be a number.']

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return ['query_array_double must contain numbers.']
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return ['query_array_double must be a number.']

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return ['query_array_boolean must be either "true" or "false".']
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return ['query_array_boolean must contain "true" or "false".']
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return ['query_array_date must contain dates.']
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return ['query_array_date must be a date.']

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return ['query_array_date_time must contain date times.']
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return ['query_array_date_time must be a date time.']

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8954/test/json/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_synchronous_test_post_test_json_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_synchronous_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_synchronous_test_post_test_json_with_all_optional_parameters_types] [url=http://localhost:8954/test/json/with/all/optional/parameters/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_synchronous_test_post_test_json_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_synchronous_test_post_test_json_with_all_optional_parameters_types] [url=http://localhost:8954/test/json/with/all/optional/parameters/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_synchronous_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def json_synchronous_test_put_test_json_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=json_synchronous_test_put_test_json_with_all_optional_parameters_types]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return ['query_integer must be an integer.']

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return ['query_integer32 must be an integer.']

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return ['query_integer64 must be an integer.']

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return ['query_number must be a number.']

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return ['query_float must be a number.']

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return ['query_double must be a number.']

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return ['query_boolean must be either "true" or "false".']
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return ['query_date must be a date.']

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return ['query_date_time must be a date time.']

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return ['query_array_integer must contain integers.']
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return ['query_array_integer must be an integer.']

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return ['query_array_integer32 must contain integers.']
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return ['query_array_integer32 must be an integer.']

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return ['query_array_integer64 must contain integers.']
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return ['query_array_integer64 must be an integer.']

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return ['query_array_number must contain numbers.']
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return ['query_array_number must be a number.']

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return ['query_array_float must contain numbers.']
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return ['query_array_float must be a number.']

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return ['query_array_double must contain numbers.']
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return ['query_array_double must be a number.']

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return ['query_array_boolean must be either "true" or "false".']
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return ['query_array_boolean must contain "true" or "false".']
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return ['query_array_date must contain dates.']
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return ['query_array_date must be a date.']

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return ['query_array_date_time must contain date times.']
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return ['query_array_date_time must be a date time.']

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8954/test/json/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_synchronous_test_put_test_json_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_synchronous_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_synchronous_test_put_test_json_with_all_optional_parameters_types] [url=http://localhost:8954/test/json/with/all/optional/parameters/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_synchronous_test_put_test_json_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_synchronous_test_put_test_json_with_all_optional_parameters_types] [url=http://localhost:8954/test/json/with/all/optional/parameters/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_synchronous_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def json_synchronous_test_delete_test_json_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=json_synchronous_test_delete_test_json_with_all_parameters_types]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return ['query_integer is required.']
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return ['query_integer must be an integer.']

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return ['query_integer32 is required.']
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return ['query_integer32 must be an integer.']

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return ['query_integer64 is required.']
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return ['query_integer64 must be an integer.']

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return ['query_number is required.']
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return ['query_number must be a number.']

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return ['query_float is required.']
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return ['query_float must be a number.']

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return ['query_double is required.']
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return ['query_double must be a number.']

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return ['query_string is required.']
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return ['query_string_byte is required.']
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return ['query_string_binary is required.']
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return ['query_boolean is required.']
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return ['query_boolean must be either "true" or "false".']
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return ['query_date is required.']
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return ['query_date must be a date.']

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return ['query_date_time is required.']
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return ['query_date_time must be a date time.']

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return ['query_password is required.']
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return ['query_array_integer is required.']
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return ['query_array_integer must contain integers.']
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return ['query_array_integer must be an integer.']

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return ['query_array_integer32 is required.']
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return ['query_array_integer32 must contain integers.']
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return ['query_array_integer32 must be an integer.']

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return ['query_array_integer64 is required.']
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return ['query_array_integer64 must contain integers.']
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return ['query_array_integer64 must be an integer.']

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return ['query_array_number is required.']
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return ['query_array_number must contain numbers.']
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return ['query_array_number must be a number.']

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return ['query_array_float is required.']
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return ['query_array_float must contain numbers.']
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return ['query_array_float must be a number.']

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return ['query_array_double is required.']
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return ['query_array_double must contain numbers.']
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return ['query_array_double must be a number.']

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return ['query_array_string is required.']
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return ['query_array_string_byte is required.']
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return ['query_array_string_binary is required.']
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return ['query_array_boolean is required.']
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return ['query_array_boolean must be either "true" or "false".']
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return ['query_array_boolean must contain "true" or "false".']
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return ['query_array_date is required.']
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return ['query_array_date must contain dates.']
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return ['query_array_date must be a date.']

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return ['query_array_date_time is required.']
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return ['query_array_date_time must contain date times.']
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return ['query_array_date_time must be a date time.']

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return ['query_array_password is required.']
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('delete', 'http://localhost:8954/test/json/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_synchronous_test_delete_test_json_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_synchronous_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_synchronous_test_delete_test_json_with_all_parameters_types] [url=http://localhost:8954/test/json/with/all/parameters/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_synchronous_test_delete_test_json_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_synchronous_test_delete_test_json_with_all_parameters_types] [url=http://localhost:8954/test/json/with/all/parameters/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_synchronous_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def json_synchronous_test_get_test_json_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=json_synchronous_test_get_test_json_with_all_parameters_types]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return ['query_integer is required.']
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return ['query_integer must be an integer.']

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return ['query_integer32 is required.']
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return ['query_integer32 must be an integer.']

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return ['query_integer64 is required.']
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return ['query_integer64 must be an integer.']

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return ['query_number is required.']
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return ['query_number must be a number.']

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return ['query_float is required.']
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return ['query_float must be a number.']

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return ['query_double is required.']
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return ['query_double must be a number.']

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return ['query_string is required.']
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return ['query_string_byte is required.']
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return ['query_string_binary is required.']
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return ['query_boolean is required.']
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return ['query_boolean must be either "true" or "false".']
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return ['query_date is required.']
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return ['query_date must be a date.']

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return ['query_date_time is required.']
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return ['query_date_time must be a date time.']

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return ['query_password is required.']
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return ['query_array_integer is required.']
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return ['query_array_integer must contain integers.']
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return ['query_array_integer must be an integer.']

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return ['query_array_integer32 is required.']
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return ['query_array_integer32 must contain integers.']
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return ['query_array_integer32 must be an integer.']

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return ['query_array_integer64 is required.']
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return ['query_array_integer64 must contain integers.']
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return ['query_array_integer64 must be an integer.']

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return ['query_array_number is required.']
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return ['query_array_number must contain numbers.']
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return ['query_array_number must be a number.']

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return ['query_array_float is required.']
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return ['query_array_float must contain numbers.']
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return ['query_array_float must be a number.']

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return ['query_array_double is required.']
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return ['query_array_double must contain numbers.']
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return ['query_array_double must be a number.']

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return ['query_array_string is required.']
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return ['query_array_string_byte is required.']
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return ['query_array_string_binary is required.']
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return ['query_array_boolean is required.']
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return ['query_array_boolean must be either "true" or "false".']
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return ['query_array_boolean must contain "true" or "false".']
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return ['query_array_date is required.']
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return ['query_array_date must contain dates.']
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return ['query_array_date must be a date.']

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return ['query_array_date_time is required.']
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return ['query_array_date_time must contain date times.']
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return ['query_array_date_time must be a date time.']

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return ['query_array_password is required.']
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8954/test/json/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_synchronous_test_get_test_json_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'$ref', u'#/definitions/AllMandatoryParameters')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_synchronous_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_synchronous_test_get_test_json_with_all_parameters_types] [url=http://localhost:8954/test/json/with/all/parameters/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_synchronous_test_get_test_json_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_synchronous_test_get_test_json_with_all_parameters_types] [url=http://localhost:8954/test/json/with/all/parameters/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_synchronous_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def json_synchronous_test_post_test_json_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=json_synchronous_test_post_test_json_with_all_parameters_types]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return ['query_integer is required.']
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return ['query_integer must be an integer.']

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return ['query_integer32 is required.']
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return ['query_integer32 must be an integer.']

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return ['query_integer64 is required.']
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return ['query_integer64 must be an integer.']

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return ['query_number is required.']
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return ['query_number must be a number.']

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return ['query_float is required.']
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return ['query_float must be a number.']

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return ['query_double is required.']
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return ['query_double must be a number.']

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return ['query_string is required.']
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return ['query_string_byte is required.']
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return ['query_string_binary is required.']
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return ['query_boolean is required.']
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return ['query_boolean must be either "true" or "false".']
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return ['query_date is required.']
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return ['query_date must be a date.']

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return ['query_date_time is required.']
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return ['query_date_time must be a date time.']

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return ['query_password is required.']
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return ['query_array_integer is required.']
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return ['query_array_integer must contain integers.']
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return ['query_array_integer must be an integer.']

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return ['query_array_integer32 is required.']
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return ['query_array_integer32 must contain integers.']
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return ['query_array_integer32 must be an integer.']

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return ['query_array_integer64 is required.']
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return ['query_array_integer64 must contain integers.']
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return ['query_array_integer64 must be an integer.']

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return ['query_array_number is required.']
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return ['query_array_number must contain numbers.']
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return ['query_array_number must be a number.']

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return ['query_array_float is required.']
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return ['query_array_float must contain numbers.']
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return ['query_array_float must be a number.']

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return ['query_array_double is required.']
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return ['query_array_double must contain numbers.']
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return ['query_array_double must be a number.']

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return ['query_array_string is required.']
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return ['query_array_string_byte is required.']
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return ['query_array_string_binary is required.']
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return ['query_array_boolean is required.']
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return ['query_array_boolean must be either "true" or "false".']
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return ['query_array_boolean must contain "true" or "false".']
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return ['query_array_date is required.']
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return ['query_array_date must contain dates.']
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return ['query_array_date must be a date.']

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return ['query_array_date_time is required.']
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return ['query_array_date_time must contain date times.']
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return ['query_array_date_time must be a date time.']

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return ['query_array_password is required.']
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8954/test/json/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_synchronous_test_post_test_json_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_synchronous_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_synchronous_test_post_test_json_with_all_parameters_types] [url=http://localhost:8954/test/json/with/all/parameters/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_synchronous_test_post_test_json_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_synchronous_test_post_test_json_with_all_parameters_types] [url=http://localhost:8954/test/json/with/all/parameters/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_synchronous_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def json_synchronous_test_put_test_json_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=json_synchronous_test_put_test_json_with_all_parameters_types]...")
    request_header = {'Accept': 'application/json'}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return ['query_integer is required.']
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return ['query_integer must be an integer.']

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return ['query_integer32 is required.']
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return ['query_integer32 must be an integer.']

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return ['query_integer64 is required.']
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return ['query_integer64 must be an integer.']

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return ['query_number is required.']
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return ['query_number must be a number.']

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return ['query_float is required.']
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return ['query_float must be a number.']

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return ['query_double is required.']
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return ['query_double must be a number.']

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return ['query_string is required.']
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return ['query_string_byte is required.']
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return ['query_string_binary is required.']
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return ['query_boolean is required.']
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return ['query_boolean must be either "true" or "false".']
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return ['query_date is required.']
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return ['query_date must be a date.']

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return ['query_date_time is required.']
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return ['query_date_time must be a date time.']

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return ['query_password is required.']
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return ['query_array_integer is required.']
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return ['query_array_integer must contain integers.']
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return ['query_array_integer must be an integer.']

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return ['query_array_integer32 is required.']
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return ['query_array_integer32 must contain integers.']
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return ['query_array_integer32 must be an integer.']

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return ['query_array_integer64 is required.']
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return ['query_array_integer64 must contain integers.']
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return ['query_array_integer64 must be an integer.']

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return ['query_array_number is required.']
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return ['query_array_number must contain numbers.']
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return ['query_array_number must be a number.']

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return ['query_array_float is required.']
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return ['query_array_float must contain numbers.']
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return ['query_array_float must be a number.']

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return ['query_array_double is required.']
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return ['query_array_double must contain numbers.']
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return ['query_array_double must be a number.']

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return ['query_array_string is required.']
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return ['query_array_string_byte is required.']
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return ['query_array_string_binary is required.']
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return ['query_array_boolean is required.']
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return ['query_array_boolean must be either "true" or "false".']
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return ['query_array_boolean must contain "true" or "false".']
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return ['query_array_date is required.']
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return ['query_array_date must contain dates.']
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return ['query_array_date must be a date.']

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return ['query_array_date_time is required.']
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return ['query_array_date_time must contain date times.']
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return ['query_array_date_time must be a date time.']

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return ['query_array_password is required.']
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8954/test/json/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_synchronous_test_put_test_json_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_synchronous_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_synchronous_test_put_test_json_with_all_parameters_types] [url=http://localhost:8954/test/json/with/all/parameters/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_synchronous_test_put_test_json_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_synchronous_test_put_test_json_with_all_parameters_types] [url=http://localhost:8954/test/json/with/all/parameters/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_synchronous_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
def json_synchronous_test_delete_test_json_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=json_synchronous_test_delete_test_json_with_all_paths_types]...")
    request_header = {'Accept': 'application/json'}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return ['path_integer is required.']

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return ['path_integer32 is required.']

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return ['path_integer64 is required.']

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return ['path_number is required.']

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return ['path_float is required.']

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return ['path_double is required.']

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return ['path_string is required.']

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return ['path_string_byte is required.']

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return ['path_string_binary is required.']

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return ['path_boolean is required.']

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return ['path_date is required.']

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return ['path_date_time is required.']

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return ['path_password is required.']

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return ['path_array_integer is required.']

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return ['path_array_integer32 is required.']

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return ['path_array_integer64 is required.']

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return ['path_array_number is required.']

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return ['path_array_float is required.']

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return ['path_array_double is required.']

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return ['path_array_string is required.']

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return ['path_array_string_byte is required.']

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return ['path_array_string_binary is required.']

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return ['path_array_boolean is required.']

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return ['path_array_date is required.']

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return ['path_array_date_time is required.']

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return ['path_array_password is required.']


    response = None
    try:
        response = session.get(5).request('delete', 'http://localhost:8954/test/json/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_synchronous_test_delete_test_json_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_synchronous_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_synchronous_test_delete_test_json_with_all_paths_types] [url=http://localhost:8954/test/json/with/all/paths/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_synchronous_test_delete_test_json_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_synchronous_test_delete_test_json_with_all_paths_types] [url=http://localhost:8954/test/json/with/all/paths/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_synchronous_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
def json_synchronous_test_get_test_json_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=json_synchronous_test_get_test_json_with_all_paths_types]...")
    request_header = {'Accept': 'application/json'}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return ['path_integer is required.']

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return ['path_integer32 is required.']

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return ['path_integer64 is required.']

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return ['path_number is required.']

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return ['path_float is required.']

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return ['path_double is required.']

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return ['path_string is required.']

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return ['path_string_byte is required.']

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return ['path_string_binary is required.']

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return ['path_boolean is required.']

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return ['path_date is required.']

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return ['path_date_time is required.']

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return ['path_password is required.']

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return ['path_array_integer is required.']

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return ['path_array_integer32 is required.']

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return ['path_array_integer64 is required.']

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return ['path_array_number is required.']

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return ['path_array_float is required.']

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return ['path_array_double is required.']

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return ['path_array_string is required.']

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return ['path_array_string_byte is required.']

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return ['path_array_string_binary is required.']

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return ['path_array_boolean is required.']

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return ['path_array_date is required.']

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return ['path_array_date_time is required.']

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return ['path_array_password is required.']


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8954/test/json/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_synchronous_test_get_test_json_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_synchronous_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_synchronous_test_get_test_json_with_all_paths_types] [url=http://localhost:8954/test/json/with/all/paths/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_synchronous_test_get_test_json_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_synchronous_test_get_test_json_with_all_paths_types] [url=http://localhost:8954/test/json/with/all/paths/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_synchronous_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
def json_synchronous_test_post_test_json_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=json_synchronous_test_post_test_json_with_all_paths_types]...")
    request_header = {'Accept': 'application/json'}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return ['path_integer is required.']

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return ['path_integer32 is required.']

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return ['path_integer64 is required.']

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return ['path_number is required.']

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return ['path_float is required.']

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return ['path_double is required.']

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return ['path_string is required.']

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return ['path_string_byte is required.']

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return ['path_string_binary is required.']

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return ['path_boolean is required.']

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return ['path_date is required.']

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return ['path_date_time is required.']

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return ['path_password is required.']

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return ['path_array_integer is required.']

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return ['path_array_integer32 is required.']

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return ['path_array_integer64 is required.']

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return ['path_array_number is required.']

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return ['path_array_float is required.']

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return ['path_array_double is required.']

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return ['path_array_string is required.']

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return ['path_array_string_byte is required.']

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return ['path_array_string_binary is required.']

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return ['path_array_boolean is required.']

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return ['path_array_date is required.']

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return ['path_array_date_time is required.']

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return ['path_array_password is required.']


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8954/test/json/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_synchronous_test_post_test_json_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_synchronous_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_synchronous_test_post_test_json_with_all_paths_types] [url=http://localhost:8954/test/json/with/all/paths/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_synchronous_test_post_test_json_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_synchronous_test_post_test_json_with_all_paths_types] [url=http://localhost:8954/test/json/with/all/paths/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='json_synchronous_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
def json_synchronous_test_put_test_json_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=json_synchronous_test_put_test_json_with_all_paths_types]...")
    request_header = {'Accept': 'application/json'}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return ['path_integer is required.']

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return ['path_integer32 is required.']

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return ['path_integer64 is required.']

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return ['path_number is required.']

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return ['path_float is required.']

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return ['path_double is required.']

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return ['path_string is required.']

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return ['path_string_byte is required.']

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return ['path_string_binary is required.']

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return ['path_boolean is required.']

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return ['path_date is required.']

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return ['path_date_time is required.']

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return ['path_password is required.']

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return ['path_array_integer is required.']

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return ['path_array_integer32 is required.']

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return ['path_array_integer64 is required.']

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return ['path_array_number is required.']

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return ['path_array_float is required.']

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return ['path_array_double is required.']

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return ['path_array_string is required.']

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return ['path_array_string_byte is required.']

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return ['path_array_string_binary is required.']

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return ['path_array_boolean is required.']

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return ['path_array_date is required.']

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return ['path_array_date_time is required.']

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return ['path_array_password is required.']


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8954/test/json/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=json_synchronous_test_put_test_json_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'successful operation'), (u'schema', OrderedDict([(u'items', OrderedDict([(u'$ref', u'#/definitions/TestObject')])), (u'type', u'array')]))]))])
            return json_as_list(response, all_responses, all_definitions.get('json_synchronous_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=json_synchronous_test_put_test_json_with_all_paths_types] [url=http://localhost:8954/test/json/with/all/paths/types].")
        return ['Cannot connect to service. Please retry once connection is re-established.']

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=json_synchronous_test_put_test_json_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=json_synchronous_test_put_test_json_with_all_paths_types] [url=http://localhost:8954/test/json/with/all/paths/types].")
        return [describe_error(response, error)]

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

all_definitions['plain_text_test'] = None


@caching
@xw.func(category='plain_text_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def plain_text_test_delete_test_plain_text_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=plain_text_test_delete_test_plain_text_with_all_optional_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('delete', 'http://localhost:8955/test/plain/text/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=plain_text_test_delete_test_plain_text_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('plain_text_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=plain_text_test_delete_test_plain_text_with_all_optional_parameters_types] [url=http://localhost:8955/test/plain/text/with/all/optional/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=plain_text_test_delete_test_plain_text_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=plain_text_test_delete_test_plain_text_with_all_optional_parameters_types] [url=http://localhost:8955/test/plain/text/with/all/optional/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='plain_text_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def plain_text_test_get_test_plain_text_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=plain_text_test_get_test_plain_text_with_all_optional_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8955/test/plain/text/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=plain_text_test_get_test_plain_text_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('plain_text_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=plain_text_test_get_test_plain_text_with_all_optional_parameters_types] [url=http://localhost:8955/test/plain/text/with/all/optional/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=plain_text_test_get_test_plain_text_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=plain_text_test_get_test_plain_text_with_all_optional_parameters_types] [url=http://localhost:8955/test/plain/text/with/all/optional/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='plain_text_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def plain_text_test_post_test_plain_text_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=plain_text_test_post_test_plain_text_with_all_optional_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8955/test/plain/text/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=plain_text_test_post_test_plain_text_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('plain_text_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=plain_text_test_post_test_plain_text_with_all_optional_parameters_types] [url=http://localhost:8955/test/plain/text/with/all/optional/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=plain_text_test_post_test_plain_text_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=plain_text_test_post_test_plain_text_with_all_optional_parameters_types] [url=http://localhost:8955/test/plain/text/with/all/optional/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='plain_text_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def plain_text_test_put_test_plain_text_with_all_optional_parameters_types(query_integer=None, query_integer32=None, query_integer64=None, query_number=None, query_float=None, query_double=None, query_string=None, query_string_byte=None, query_string_binary=None, query_boolean=None, query_date=None, query_date_time=None, query_password=None, query_array_integer=None, query_array_integer32=None, query_array_integer64=None, query_array_number=None, query_array_float=None, query_array_double=None, query_array_string=None, query_array_string_byte=None, query_array_string_binary=None, query_array_boolean=None, query_array_date=None, query_array_date_time=None, query_array_password=None):
    logger.info("[status=Calling] [function=plain_text_test_put_test_plain_text_with_all_optional_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8955/test/plain/text/with/all/optional/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=plain_text_test_put_test_plain_text_with_all_optional_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('plain_text_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=plain_text_test_put_test_plain_text_with_all_optional_parameters_types] [url=http://localhost:8955/test/plain/text/with/all/optional/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=plain_text_test_put_test_plain_text_with_all_optional_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=plain_text_test_put_test_plain_text_with_all_optional_parameters_types] [url=http://localhost:8955/test/plain/text/with/all/optional/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='plain_text_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def plain_text_test_delete_test_plain_text_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=plain_text_test_delete_test_plain_text_with_all_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return 'query_integer is required.'
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return 'query_integer32 is required.'
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return 'query_integer64 is required.'
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return 'query_number is required.'
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return 'query_float is required.'
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return 'query_double is required.'
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return 'query_string is required.'
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return 'query_string_byte is required.'
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return 'query_string_binary is required.'
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return 'query_boolean is required.'
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return 'query_date is required.'
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return 'query_date_time is required.'
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return 'query_password is required.'
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return 'query_array_integer is required.'
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return 'query_array_integer32 is required.'
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return 'query_array_integer64 is required.'
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return 'query_array_number is required.'
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return 'query_array_float is required.'
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return 'query_array_double is required.'
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return 'query_array_string is required.'
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return 'query_array_string_byte is required.'
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return 'query_array_string_binary is required.'
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return 'query_array_boolean is required.'
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return 'query_array_date is required.'
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return 'query_array_date_time is required.'
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return 'query_array_password is required.'
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('delete', 'http://localhost:8955/test/plain/text/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=plain_text_test_delete_test_plain_text_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('plain_text_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=plain_text_test_delete_test_plain_text_with_all_parameters_types] [url=http://localhost:8955/test/plain/text/with/all/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=plain_text_test_delete_test_plain_text_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=plain_text_test_delete_test_plain_text_with_all_parameters_types] [url=http://localhost:8955/test/plain/text/with/all/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='plain_text_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def plain_text_test_get_test_plain_text_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=plain_text_test_get_test_plain_text_with_all_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return 'query_integer is required.'
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return 'query_integer32 is required.'
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return 'query_integer64 is required.'
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return 'query_number is required.'
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return 'query_float is required.'
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return 'query_double is required.'
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return 'query_string is required.'
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return 'query_string_byte is required.'
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return 'query_string_binary is required.'
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return 'query_boolean is required.'
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return 'query_date is required.'
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return 'query_date_time is required.'
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return 'query_password is required.'
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return 'query_array_integer is required.'
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return 'query_array_integer32 is required.'
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return 'query_array_integer64 is required.'
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return 'query_array_number is required.'
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return 'query_array_float is required.'
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return 'query_array_double is required.'
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return 'query_array_string is required.'
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return 'query_array_string_byte is required.'
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return 'query_array_string_binary is required.'
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return 'query_array_boolean is required.'
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return 'query_array_date is required.'
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return 'query_array_date_time is required.'
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return 'query_array_password is required.'
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8955/test/plain/text/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=plain_text_test_get_test_plain_text_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('plain_text_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=plain_text_test_get_test_plain_text_with_all_parameters_types] [url=http://localhost:8955/test/plain/text/with/all/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=plain_text_test_get_test_plain_text_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=plain_text_test_get_test_plain_text_with_all_parameters_types] [url=http://localhost:8955/test/plain/text/with/all/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='plain_text_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def plain_text_test_post_test_plain_text_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=plain_text_test_post_test_plain_text_with_all_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return 'query_integer is required.'
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return 'query_integer32 is required.'
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return 'query_integer64 is required.'
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return 'query_number is required.'
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return 'query_float is required.'
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return 'query_double is required.'
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return 'query_string is required.'
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return 'query_string_byte is required.'
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return 'query_string_binary is required.'
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return 'query_boolean is required.'
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return 'query_date is required.'
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return 'query_date_time is required.'
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return 'query_password is required.'
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return 'query_array_integer is required.'
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return 'query_array_integer32 is required.'
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return 'query_array_integer64 is required.'
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return 'query_array_number is required.'
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return 'query_array_float is required.'
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return 'query_array_double is required.'
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return 'query_array_string is required.'
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return 'query_array_string_byte is required.'
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return 'query_array_string_binary is required.'
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return 'query_array_boolean is required.'
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return 'query_array_date is required.'
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return 'query_array_date_time is required.'
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return 'query_array_password is required.'
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8955/test/plain/text/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=plain_text_test_post_test_plain_text_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('plain_text_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=plain_text_test_post_test_plain_text_with_all_parameters_types] [url=http://localhost:8955/test/plain/text/with/all/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=plain_text_test_post_test_plain_text_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=plain_text_test_post_test_plain_text_with_all_parameters_types] [url=http://localhost:8955/test/plain/text/with/all/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='plain_text_test', call_in_wizard=False)
@xw.arg('query_integer', numbers=int, doc='integer parameter')
@xw.arg('query_integer32', numbers=int, doc='integer 32 parameter')
@xw.arg('query_integer64', numbers=int, doc='integer 64 parameter')
@xw.arg('query_number', numbers=float, doc='number parameter')
@xw.arg('query_float', numbers=float, doc='number float parameter')
@xw.arg('query_double', numbers=float, doc='number double parameter')
@xw.arg('query_string', doc='string parameter')
@xw.arg('query_string_byte', doc='string byte parameter')
@xw.arg('query_string_binary', doc='string binary parameter')
@xw.arg('query_boolean', doc='boolean parameter')
@xw.arg('query_date', dates=datetime.date, doc='date parameter')
@xw.arg('query_date_time', dates=datetime.datetime, doc='date time parameter')
@xw.arg('query_password', doc='password parameter')
@xw.arg('query_array_integer', doc='integer array parameter')
@xw.arg('query_array_integer32', doc='integer 32 array parameter')
@xw.arg('query_array_integer64', doc='integer 64 array parameter')
@xw.arg('query_array_number', doc='number array parameter')
@xw.arg('query_array_float', doc='number float array parameter')
@xw.arg('query_array_double', doc='number double array parameter')
@xw.arg('query_array_string', doc='string array parameter')
@xw.arg('query_array_string_byte', doc='string byte array parameter')
@xw.arg('query_array_string_binary', doc='string binary array parameter')
@xw.arg('query_array_boolean', doc='boolean array parameter')
@xw.arg('query_array_date', doc='date array parameter')
@xw.arg('query_array_date_time', doc='date time array parameter')
@xw.arg('query_array_password', doc='password array parameter')
def plain_text_test_put_test_plain_text_with_all_parameters_types(query_integer, query_integer32, query_integer64, query_number, query_float, query_double, query_string, query_string_byte, query_string_binary, query_boolean, query_date, query_date_time, query_password, query_array_integer, query_array_integer32, query_array_integer64, query_array_number, query_array_float, query_array_double, query_array_string, query_array_string_byte, query_array_string_binary, query_array_boolean, query_array_date, query_array_date_time, query_array_password):
    logger.info("[status=Calling] [function=plain_text_test_put_test_plain_text_with_all_parameters_types]...")
    request_header = {}
    request_parameters = {}

    if query_integer is None or isinstance(query_integer, list) and all(x is None for x in query_integer):
        logger.error('query_integer is required.')
        return 'query_integer is required.'
    if query_integer is not None:
        if not isinstance(query_integer, int):
            logger.error('query_integer must be an integer.')
            return 'query_integer must be an integer.'

        request_parameters['query_integer'] = query_integer

    if query_integer32 is None or isinstance(query_integer32, list) and all(x is None for x in query_integer32):
        logger.error('query_integer32 is required.')
        return 'query_integer32 is required.'
    if query_integer32 is not None:
        if not isinstance(query_integer32, int):
            logger.error('query_integer32 must be an integer.')
            return 'query_integer32 must be an integer.'

        request_parameters['query_integer32'] = query_integer32

    if query_integer64 is None or isinstance(query_integer64, list) and all(x is None for x in query_integer64):
        logger.error('query_integer64 is required.')
        return 'query_integer64 is required.'
    if query_integer64 is not None:
        if not isinstance(query_integer64, int):
            logger.error('query_integer64 must be an integer.')
            return 'query_integer64 must be an integer.'

        request_parameters['query_integer64'] = query_integer64

    if query_number is None or isinstance(query_number, list) and all(x is None for x in query_number):
        logger.error('query_number is required.')
        return 'query_number is required.'
    if query_number is not None:
        if not isinstance(query_number, float):
            logger.error('query_number must be a number.')
            return 'query_number must be a number.'

        request_parameters['query_number'] = query_number

    if query_float is None or isinstance(query_float, list) and all(x is None for x in query_float):
        logger.error('query_float is required.')
        return 'query_float is required.'
    if query_float is not None:
        if not isinstance(query_float, float):
            logger.error('query_float must be a number.')
            return 'query_float must be a number.'

        request_parameters['query_float'] = query_float

    if query_double is None or isinstance(query_double, list) and all(x is None for x in query_double):
        logger.error('query_double is required.')
        return 'query_double is required.'
    if query_double is not None:
        if not isinstance(query_double, float):
            logger.error('query_double must be a number.')
            return 'query_double must be a number.'

        request_parameters['query_double'] = query_double

    if query_string is None or isinstance(query_string, list) and all(x is None for x in query_string):
        logger.error('query_string is required.')
        return 'query_string is required.'
    if query_string is not None:

        request_parameters['query_string'] = query_string

    if query_string_byte is None or isinstance(query_string_byte, list) and all(x is None for x in query_string_byte):
        logger.error('query_string_byte is required.')
        return 'query_string_byte is required.'
    if query_string_byte is not None:

        request_parameters['query_string_byte'] = query_string_byte

    if query_string_binary is None or isinstance(query_string_binary, list) and all(x is None for x in query_string_binary):
        logger.error('query_string_binary is required.')
        return 'query_string_binary is required.'
    if query_string_binary is not None:

        request_parameters['query_string_binary'] = query_string_binary

    if query_boolean is None or isinstance(query_boolean, list) and all(x is None for x in query_boolean):
        logger.error('query_boolean is required.')
        return 'query_boolean is required.'
    if query_boolean is not None:
        if query_boolean not in ['true', 'false']:
            logger.error('query_boolean must be either "true" or "false".')
            return 'query_boolean must be either "true" or "false".'
        query_boolean = query_boolean == 'true'

        request_parameters['query_boolean'] = query_boolean

    if query_date is None or isinstance(query_date, list) and all(x is None for x in query_date):
        logger.error('query_date is required.')
        return 'query_date is required.'
    if query_date is not None:
        if not isinstance(query_date, datetime.date):
            logger.error('query_date must be a date.')
            return 'query_date must be a date.'

        request_parameters['query_date'] = query_date

    if query_date_time is None or isinstance(query_date_time, list) and all(x is None for x in query_date_time):
        logger.error('query_date_time is required.')
        return 'query_date_time is required.'
    if query_date_time is not None:
        if not isinstance(query_date_time, datetime.datetime):
            logger.error('query_date_time must be a date time.')
            return 'query_date_time must be a date time.'

        request_parameters['query_date_time'] = query_date_time

    if query_password is None or isinstance(query_password, list) and all(x is None for x in query_password):
        logger.error('query_password is required.')
        return 'query_password is required.'
    if query_password is not None:

        request_parameters['query_password'] = query_password

    if query_array_integer is None or isinstance(query_array_integer, list) and all(x is None for x in query_array_integer):
        logger.error('query_array_integer is required.')
        return 'query_array_integer is required.'
    if query_array_integer is not None:
        if isinstance(query_array_integer, list):
            query_array_integer = [item for item in query_array_integer if item is not None]
            for query_array_integer_item in query_array_integer:
                if not isinstance(query_array_integer_item, int):
                    logger.error('query_array_integer must contain integers.')
                    return 'query_array_integer must contain integers.'
        else:
            if not isinstance(query_array_integer, int):
                logger.error('query_array_integer must be an integer.')
                return 'query_array_integer must be an integer.'

        request_parameters['query_array_integer'] = query_array_integer

    if query_array_integer32 is None or isinstance(query_array_integer32, list) and all(x is None for x in query_array_integer32):
        logger.error('query_array_integer32 is required.')
        return 'query_array_integer32 is required.'
    if query_array_integer32 is not None:
        if isinstance(query_array_integer32, list):
            query_array_integer32 = [item for item in query_array_integer32 if item is not None]
            for query_array_integer32_item in query_array_integer32:
                if not isinstance(query_array_integer32_item, int):
                    logger.error('query_array_integer32 must contain integers.')
                    return 'query_array_integer32 must contain integers.'
        else:
            if not isinstance(query_array_integer32, int):
                logger.error('query_array_integer32 must be an integer.')
                return 'query_array_integer32 must be an integer.'

        request_parameters['query_array_integer32'] = query_array_integer32

    if query_array_integer64 is None or isinstance(query_array_integer64, list) and all(x is None for x in query_array_integer64):
        logger.error('query_array_integer64 is required.')
        return 'query_array_integer64 is required.'
    if query_array_integer64 is not None:
        if isinstance(query_array_integer64, list):
            query_array_integer64 = [item for item in query_array_integer64 if item is not None]
            for query_array_integer64_item in query_array_integer64:
                if not isinstance(query_array_integer64_item, int):
                    logger.error('query_array_integer64 must contain integers.')
                    return 'query_array_integer64 must contain integers.'
        else:
            if not isinstance(query_array_integer64, int):
                logger.error('query_array_integer64 must be an integer.')
                return 'query_array_integer64 must be an integer.'

        request_parameters['query_array_integer64'] = query_array_integer64

    if query_array_number is None or isinstance(query_array_number, list) and all(x is None for x in query_array_number):
        logger.error('query_array_number is required.')
        return 'query_array_number is required.'
    if query_array_number is not None:
        if isinstance(query_array_number, list):
            query_array_number = [item for item in query_array_number if item is not None]
            for query_array_number_item in query_array_number:
                if not isinstance(query_array_number_item, float):
                    logger.error('query_array_number must contain numbers.')
                    return 'query_array_number must contain numbers.'
        else:
            if not isinstance(query_array_number, float):
                logger.error('query_array_number must be a number.')
                return 'query_array_number must be a number.'

        request_parameters['query_array_number'] = query_array_number

    if query_array_float is None or isinstance(query_array_float, list) and all(x is None for x in query_array_float):
        logger.error('query_array_float is required.')
        return 'query_array_float is required.'
    if query_array_float is not None:
        if isinstance(query_array_float, list):
            query_array_float = [item for item in query_array_float if item is not None]
            for query_array_float_item in query_array_float:
                if not isinstance(query_array_float_item, float):
                    logger.error('query_array_float must contain numbers.')
                    return 'query_array_float must contain numbers.'
        else:
            if not isinstance(query_array_float, float):
                logger.error('query_array_float must be a number.')
                return 'query_array_float must be a number.'

        request_parameters['query_array_float'] = query_array_float

    if query_array_double is None or isinstance(query_array_double, list) and all(x is None for x in query_array_double):
        logger.error('query_array_double is required.')
        return 'query_array_double is required.'
    if query_array_double is not None:
        if isinstance(query_array_double, list):
            query_array_double = [item for item in query_array_double if item is not None]
            for query_array_double_item in query_array_double:
                if not isinstance(query_array_double_item, float):
                    logger.error('query_array_double must contain numbers.')
                    return 'query_array_double must contain numbers.'
        else:
            if not isinstance(query_array_double, float):
                logger.error('query_array_double must be a number.')
                return 'query_array_double must be a number.'

        request_parameters['query_array_double'] = query_array_double

    if query_array_string is None or isinstance(query_array_string, list) and all(x is None for x in query_array_string):
        logger.error('query_array_string is required.')
        return 'query_array_string is required.'
    if query_array_string is not None:

        request_parameters['query_array_string'] = query_array_string

    if query_array_string_byte is None or isinstance(query_array_string_byte, list) and all(x is None for x in query_array_string_byte):
        logger.error('query_array_string_byte is required.')
        return 'query_array_string_byte is required.'
    if query_array_string_byte is not None:

        request_parameters['query_array_string_byte'] = query_array_string_byte

    if query_array_string_binary is None or isinstance(query_array_string_binary, list) and all(x is None for x in query_array_string_binary):
        logger.error('query_array_string_binary is required.')
        return 'query_array_string_binary is required.'
    if query_array_string_binary is not None:

        request_parameters['query_array_string_binary'] = query_array_string_binary

    if query_array_boolean is None or isinstance(query_array_boolean, list) and all(x is None for x in query_array_boolean):
        logger.error('query_array_boolean is required.')
        return 'query_array_boolean is required.'
    if query_array_boolean is not None:
        if isinstance(query_array_boolean, list):
            query_array_boolean = [item for item in query_array_boolean if item is not None]
            for query_array_boolean_item in query_array_boolean:
                if query_array_boolean_item not in ['true', 'false']:
                    logger.error('query_array_boolean must be either "true" or "false".')
                    return 'query_array_boolean must be either "true" or "false".'
                else:
                    query_array_boolean_item = query_array_boolean_item == 'true'
        else:
            if query_array_boolean not in ['true', 'false']:
                logger.error('query_array_boolean must contain "true" or "false".')
                return 'query_array_boolean must contain "true" or "false".'
            query_array_boolean = query_array_boolean == 'true'

        request_parameters['query_array_boolean'] = query_array_boolean

    if query_array_date is None or isinstance(query_array_date, list) and all(x is None for x in query_array_date):
        logger.error('query_array_date is required.')
        return 'query_array_date is required.'
    if query_array_date is not None:
        if isinstance(query_array_date, list):
            query_array_date = [item for item in query_array_date if item is not None]
            for query_array_date_item in query_array_date:
                if not isinstance(query_array_date_item, datetime.date):
                    logger.error('query_array_date must contain dates.')
                    return 'query_array_date must contain dates.'
        else:
            if not isinstance(query_array_date, datetime.date):
                logger.error('query_array_date must be a date.')
                return 'query_array_date must be a date.'

        request_parameters['query_array_date'] = query_array_date

    if query_array_date_time is None or isinstance(query_array_date_time, list) and all(x is None for x in query_array_date_time):
        logger.error('query_array_date_time is required.')
        return 'query_array_date_time is required.'
    if query_array_date_time is not None:
        if isinstance(query_array_date_time, list):
            query_array_date_time = [item for item in query_array_date_time if item is not None]
            for query_array_date_time_item in query_array_date_time:
                if not isinstance(query_array_date_time_item, datetime.datetime):
                    logger.error('query_array_date_time must contain date times.')
                    return 'query_array_date_time must contain date times.'
        else:
            if not isinstance(query_array_date_time, datetime.datetime):
                logger.error('query_array_date_time must be a date time.')
                return 'query_array_date_time must be a date time.'

        request_parameters['query_array_date_time'] = query_array_date_time

    if query_array_password is None or isinstance(query_array_password, list) and all(x is None for x in query_array_password):
        logger.error('query_array_password is required.')
        return 'query_array_password is required.'
    if query_array_password is not None:

        request_parameters['query_array_password'] = query_array_password


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8955/test/plain/text/with/all/parameters/types'.format(), params=request_parameters, verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=plain_text_test_put_test_plain_text_with_all_parameters_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('plain_text_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=plain_text_test_put_test_plain_text_with_all_parameters_types] [url=http://localhost:8955/test/plain/text/with/all/parameters/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=plain_text_test_put_test_plain_text_with_all_parameters_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=plain_text_test_put_test_plain_text_with_all_parameters_types] [url=http://localhost:8955/test/plain/text/with/all/parameters/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='plain_text_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
def plain_text_test_delete_test_plain_text_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=plain_text_test_delete_test_plain_text_with_all_paths_types]...")
    request_header = {}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return 'path_integer is required.'

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return 'path_integer32 is required.'

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return 'path_integer64 is required.'

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return 'path_number is required.'

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return 'path_float is required.'

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return 'path_double is required.'

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return 'path_string is required.'

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return 'path_string_byte is required.'

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return 'path_string_binary is required.'

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return 'path_boolean is required.'

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return 'path_date is required.'

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return 'path_date_time is required.'

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return 'path_password is required.'

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return 'path_array_integer is required.'

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return 'path_array_integer32 is required.'

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return 'path_array_integer64 is required.'

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return 'path_array_number is required.'

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return 'path_array_float is required.'

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return 'path_array_double is required.'

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return 'path_array_string is required.'

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return 'path_array_string_byte is required.'

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return 'path_array_string_binary is required.'

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return 'path_array_boolean is required.'

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return 'path_array_date is required.'

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return 'path_array_date_time is required.'

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return 'path_array_password is required.'


    response = None
    try:
        response = session.get(5).request('delete', 'http://localhost:8955/test/plain/text/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=plain_text_test_delete_test_plain_text_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('plain_text_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=plain_text_test_delete_test_plain_text_with_all_paths_types] [url=http://localhost:8955/test/plain/text/with/all/paths/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=plain_text_test_delete_test_plain_text_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=plain_text_test_delete_test_plain_text_with_all_paths_types] [url=http://localhost:8955/test/plain/text/with/all/paths/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='plain_text_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
def plain_text_test_get_test_plain_text_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=plain_text_test_get_test_plain_text_with_all_paths_types]...")
    request_header = {}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return 'path_integer is required.'

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return 'path_integer32 is required.'

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return 'path_integer64 is required.'

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return 'path_number is required.'

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return 'path_float is required.'

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return 'path_double is required.'

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return 'path_string is required.'

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return 'path_string_byte is required.'

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return 'path_string_binary is required.'

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return 'path_boolean is required.'

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return 'path_date is required.'

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return 'path_date_time is required.'

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return 'path_password is required.'

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return 'path_array_integer is required.'

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return 'path_array_integer32 is required.'

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return 'path_array_integer64 is required.'

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return 'path_array_number is required.'

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return 'path_array_float is required.'

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return 'path_array_double is required.'

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return 'path_array_string is required.'

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return 'path_array_string_byte is required.'

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return 'path_array_string_binary is required.'

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return 'path_array_boolean is required.'

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return 'path_array_date is required.'

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return 'path_array_date_time is required.'

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return 'path_array_password is required.'


    response = None
    try:
        response = session.get(5).request('get', 'http://localhost:8955/test/plain/text/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=plain_text_test_get_test_plain_text_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('plain_text_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=plain_text_test_get_test_plain_text_with_all_paths_types] [url=http://localhost:8955/test/plain/text/with/all/paths/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=plain_text_test_get_test_plain_text_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=plain_text_test_get_test_plain_text_with_all_paths_types] [url=http://localhost:8955/test/plain/text/with/all/paths/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='plain_text_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
def plain_text_test_post_test_plain_text_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=plain_text_test_post_test_plain_text_with_all_paths_types]...")
    request_header = {}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return 'path_integer is required.'

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return 'path_integer32 is required.'

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return 'path_integer64 is required.'

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return 'path_number is required.'

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return 'path_float is required.'

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return 'path_double is required.'

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return 'path_string is required.'

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return 'path_string_byte is required.'

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return 'path_string_binary is required.'

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return 'path_boolean is required.'

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return 'path_date is required.'

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return 'path_date_time is required.'

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return 'path_password is required.'

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return 'path_array_integer is required.'

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return 'path_array_integer32 is required.'

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return 'path_array_integer64 is required.'

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return 'path_array_number is required.'

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return 'path_array_float is required.'

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return 'path_array_double is required.'

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return 'path_array_string is required.'

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return 'path_array_string_byte is required.'

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return 'path_array_string_binary is required.'

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return 'path_array_boolean is required.'

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return 'path_array_date is required.'

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return 'path_array_date_time is required.'

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return 'path_array_password is required.'


    response = None
    try:
        response = session.get(5).request('post', 'http://localhost:8955/test/plain/text/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=plain_text_test_post_test_plain_text_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('plain_text_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=plain_text_test_post_test_plain_text_with_all_paths_types] [url=http://localhost:8955/test/plain/text/with/all/paths/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=plain_text_test_post_test_plain_text_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=plain_text_test_post_test_plain_text_with_all_paths_types] [url=http://localhost:8955/test/plain/text/with/all/paths/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

@caching
@xw.func(category='plain_text_test', call_in_wizard=False)
@xw.arg('path_integer', numbers=int, doc='integer path')
@xw.arg('path_integer32', numbers=int, doc='integer 32 path')
@xw.arg('path_integer64', numbers=int, doc='integer 64 path')
@xw.arg('path_number', numbers=float, doc='number path')
@xw.arg('path_float', numbers=float, doc='number float path')
@xw.arg('path_double', numbers=float, doc='number double path')
@xw.arg('path_string', doc='string path')
@xw.arg('path_string_byte', doc='string byte path')
@xw.arg('path_string_binary', doc='string binary path')
@xw.arg('path_boolean', doc='boolean path')
@xw.arg('path_date', dates=datetime.date, doc='date path')
@xw.arg('path_date_time', dates=datetime.datetime, doc='date time path')
@xw.arg('path_password', doc='password path')
@xw.arg('path_array_integer', doc='integer array path')
@xw.arg('path_array_integer32', doc='integer 32 array path')
@xw.arg('path_array_integer64', doc='integer 64 array path')
@xw.arg('path_array_number', doc='number array path')
@xw.arg('path_array_float', doc='number float array path')
@xw.arg('path_array_double', doc='number double array path')
@xw.arg('path_array_string', doc='string array path')
@xw.arg('path_array_string_byte', doc='string byte array path')
@xw.arg('path_array_string_binary', doc='string binary array path')
@xw.arg('path_array_boolean', doc='boolean array path')
@xw.arg('path_array_date', doc='date array path')
@xw.arg('path_array_date_time', doc='date time array path')
@xw.arg('path_array_password', doc='password array path')
def plain_text_test_put_test_plain_text_with_all_paths_types(path_integer, path_integer32, path_integer64, path_number, path_float, path_double, path_string, path_string_byte, path_string_binary, path_boolean, path_date, path_date_time, path_password, path_array_integer, path_array_integer32, path_array_integer64, path_array_number, path_array_float, path_array_double, path_array_string, path_array_string_byte, path_array_string_binary, path_array_boolean, path_array_date, path_array_date_time, path_array_password):
    logger.info("[status=Calling] [function=plain_text_test_put_test_plain_text_with_all_paths_types]...")
    request_header = {}

    if path_integer is None or isinstance(path_integer, list) and all(x is None for x in path_integer):
        logger.error('path_integer is required.')
        return 'path_integer is required.'

    if path_integer32 is None or isinstance(path_integer32, list) and all(x is None for x in path_integer32):
        logger.error('path_integer32 is required.')
        return 'path_integer32 is required.'

    if path_integer64 is None or isinstance(path_integer64, list) and all(x is None for x in path_integer64):
        logger.error('path_integer64 is required.')
        return 'path_integer64 is required.'

    if path_number is None or isinstance(path_number, list) and all(x is None for x in path_number):
        logger.error('path_number is required.')
        return 'path_number is required.'

    if path_float is None or isinstance(path_float, list) and all(x is None for x in path_float):
        logger.error('path_float is required.')
        return 'path_float is required.'

    if path_double is None or isinstance(path_double, list) and all(x is None for x in path_double):
        logger.error('path_double is required.')
        return 'path_double is required.'

    if path_string is None or isinstance(path_string, list) and all(x is None for x in path_string):
        logger.error('path_string is required.')
        return 'path_string is required.'

    if path_string_byte is None or isinstance(path_string_byte, list) and all(x is None for x in path_string_byte):
        logger.error('path_string_byte is required.')
        return 'path_string_byte is required.'

    if path_string_binary is None or isinstance(path_string_binary, list) and all(x is None for x in path_string_binary):
        logger.error('path_string_binary is required.')
        return 'path_string_binary is required.'

    if path_boolean is None or isinstance(path_boolean, list) and all(x is None for x in path_boolean):
        logger.error('path_boolean is required.')
        return 'path_boolean is required.'

    if path_date is None or isinstance(path_date, list) and all(x is None for x in path_date):
        logger.error('path_date is required.')
        return 'path_date is required.'

    if path_date_time is None or isinstance(path_date_time, list) and all(x is None for x in path_date_time):
        logger.error('path_date_time is required.')
        return 'path_date_time is required.'

    if path_password is None or isinstance(path_password, list) and all(x is None for x in path_password):
        logger.error('path_password is required.')
        return 'path_password is required.'

    if path_array_integer is None or isinstance(path_array_integer, list) and all(x is None for x in path_array_integer):
        logger.error('path_array_integer is required.')
        return 'path_array_integer is required.'

    if path_array_integer32 is None or isinstance(path_array_integer32, list) and all(x is None for x in path_array_integer32):
        logger.error('path_array_integer32 is required.')
        return 'path_array_integer32 is required.'

    if path_array_integer64 is None or isinstance(path_array_integer64, list) and all(x is None for x in path_array_integer64):
        logger.error('path_array_integer64 is required.')
        return 'path_array_integer64 is required.'

    if path_array_number is None or isinstance(path_array_number, list) and all(x is None for x in path_array_number):
        logger.error('path_array_number is required.')
        return 'path_array_number is required.'

    if path_array_float is None or isinstance(path_array_float, list) and all(x is None for x in path_array_float):
        logger.error('path_array_float is required.')
        return 'path_array_float is required.'

    if path_array_double is None or isinstance(path_array_double, list) and all(x is None for x in path_array_double):
        logger.error('path_array_double is required.')
        return 'path_array_double is required.'

    if path_array_string is None or isinstance(path_array_string, list) and all(x is None for x in path_array_string):
        logger.error('path_array_string is required.')
        return 'path_array_string is required.'

    if path_array_string_byte is None or isinstance(path_array_string_byte, list) and all(x is None for x in path_array_string_byte):
        logger.error('path_array_string_byte is required.')
        return 'path_array_string_byte is required.'

    if path_array_string_binary is None or isinstance(path_array_string_binary, list) and all(x is None for x in path_array_string_binary):
        logger.error('path_array_string_binary is required.')
        return 'path_array_string_binary is required.'

    if path_array_boolean is None or isinstance(path_array_boolean, list) and all(x is None for x in path_array_boolean):
        logger.error('path_array_boolean is required.')
        return 'path_array_boolean is required.'

    if path_array_date is None or isinstance(path_array_date, list) and all(x is None for x in path_array_date):
        logger.error('path_array_date is required.')
        return 'path_array_date is required.'

    if path_array_date_time is None or isinstance(path_array_date_time, list) and all(x is None for x in path_array_date_time):
        logger.error('path_array_date_time is required.')
        return 'path_array_date_time is required.'

    if path_array_password is None or isinstance(path_array_password, list) and all(x is None for x in path_array_password):
        logger.error('path_array_password is required.')
        return 'path_array_password is required.'


    response = None
    try:
        response = session.get(5).request('put', 'http://localhost:8955/test/plain/text/with/all/paths/types'.format(path_integer=path_integer, path_integer32=path_integer32, path_integer64=path_integer64, path_number=path_number, path_float=path_float, path_double=path_double, path_string=path_string, path_string_byte=path_string_byte, path_string_binary=path_string_binary, path_boolean=path_boolean, path_date=path_date, path_date_time=path_date_time, path_password=path_password, path_array_integer=path_array_integer, path_array_integer32=path_array_integer32, path_array_integer64=path_array_integer64, path_array_number=path_array_number, path_array_float=path_array_float, path_array_double=path_array_double, path_array_string=path_array_string, path_array_string_byte=path_array_string_byte, path_array_string_binary=path_array_string_binary, path_array_boolean=path_array_boolean, path_array_date=path_array_date, path_array_date_time=path_array_date_time, path_array_password=path_array_password), verify=False, headers=request_header, proxies={}, timeout=(1.0, None))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function=plain_text_test_put_test_plain_text_with_all_paths_types] [url={0}].".format(response.request.url))
        if response.headers['content-type'] == 'application/json':
            all_responses = OrderedDict([(u'200', OrderedDict([(u'description', u'return value')]))])
            return json_as_list(response, all_responses, all_definitions.get('plain_text_test'), False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function=plain_text_test_put_test_plain_text_with_all_paths_types] [url=http://localhost:8955/test/plain/text/with/all/paths/types].")
        return 'Cannot connect to service. Please retry once connection is re-established.'

    except Exception as error:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function=plain_text_test_put_test_plain_text_with_all_paths_types] [url={1}] response: [response={0}].".format(response.text[:64],response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function=plain_text_test_put_test_plain_text_with_all_paths_types] [url=http://localhost:8955/test/plain/text/with/all/paths/types].")
        return describe_error(response, error)

    finally:
        # Check "is not None" because response.ok is overrided according to HTTP status code.
        if response is not None:
            response.close()

all_definitions['octet_stream_test'] = None



def json_as_list(response, all_responses, all_definitions, rely_on_definitions):
    if rely_on_definitions:
        definition_deserializer.all_definitions = {}
        response_text = response.text
        logger.debug('Converting JSON string to corresponding python structure using ujson (relying on definitions)...')
        json_data = ujson.loads(response_text) if response_text != '' else response_text
        return Response(all_responses, response.status_code, all_definitions).rows(json_data)

    logger.debug('Converting JSON string to corresponding python structure...')
    json_data = response.json(object_pairs_hook=OrderedDict) if len(response.content) else ''
    return Flattenizer(all_responses, response.status_code, all_definitions).to_list(json_data)


def msgpackpandas_as_list(msgpack_pandas):
    logger.warning('Pandas module is required to decode response.')
    return ['Please install pandas module to be able to decode result.']


def describe_error(response, error):
    # Check "is not None" because response.ok is overrided according to HTTP status code.
    if response is not None:
        return 'An error occurred. Please check logs for full details: "{0}"'.format(response.text[:198])
    return 'An error occurred. Please check logs for full details: "{0}"'.format(str(error)[:198])