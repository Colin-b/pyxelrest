"""
This file was generated. DO NOT EDIT manually.
Source file: {{ self._TemplateReference__context.name }}
Generation date (UTC): {{ current_utc_time }}
"""
import xlwings as xw
import requests
import requests.exceptions
import datetime
import logging
import sys
from pyxelrest import custom_logging
from pyxelrest.caching import caching
from pyxelrest import session
{% if support_ujson %}
import ujson
{% endif %}
from collections import OrderedDict
{% if support_pandas %}
import pandas
{% endif %}
from pyxelrest.fast_deserializer import Flattenizer
from pyxelrest.definition_deserializer import Response
from pyxelrest import definition_deserializer
from pyxelrest import authentication
from pyxelrest.swagger import RequestContent, list_to_dict, list_to_dict_list

logger = logging.getLogger(__name__)
swagger_methods = None  # Will be set after load

{% macro convert_to_return_type(str_value, swagger_method) %}
{% if swagger_method.return_a_list() -%}
[{{ str_value }}]
{% else -%}
{{ str_value }}
{% endif %}
{% endmacro %}

{# Macro generating the converter for the parameter if needed #}
{% macro param_converter(parameter) %}
{%- if parameter.type == 'integer' %}
 numbers=int,
{%- elif parameter.type == 'number' %}
 numbers=float,
{%- elif parameter.type == 'string' %}
    {%- if parameter.format == 'date' %}
 dates=datetime.date,
    {%- elif parameter.format == 'date-time' %}
 dates=datetime.datetime,
    {%- endif %}
{% endif %}
{% endmacro %}

{# Macro generating the UDF related to provided method #}
{% macro add_udf(swagger_method) %}
{% if 'get' == swagger_method.requests_method %}@caching
{% endif %}
@xw.func(category='{{ swagger_method.service.config.name }}', call_in_wizard=False{% if swagger_method.help_url %}, help_file='{{ swagger_method.help_url }}'{% endif %})
{% for parameter in swagger_method.path_parameters %}
@xw.arg('{{ parameter.name }}',{{ param_converter(parameter) }} doc='{{ parameter.description }}')
{% endfor %}
{% for parameter in swagger_method.required_parameters %}
@xw.arg('{{ parameter.name }}',{{ param_converter(parameter) }} doc='{{ parameter.description }}')
{% endfor %}
{% for parameter in swagger_method.optional_parameters %}
@xw.arg('{{ parameter.name }}',{{ param_converter(parameter) }} doc='{{ parameter.description }}')
{% endfor %}
{% if swagger_method.return_a_list() and swagger_method.is_asynchronous %}
@xw.ret(expand='table')
{% endif %}
def {{ swagger_method.udf_name }}(
    {%- for parameter in swagger_method.path_parameters %}{{ parameter.name }}{% if not loop.last or swagger_method.has_required_parameters() or swagger_method.has_optional_parameters() %}, {% endif %}{% endfor %}
    {%- for parameter in swagger_method.required_parameters %}{{ parameter.name }}{% if not loop.last or swagger_method.has_optional_parameters() %}, {% endif %}{% endfor %}
    {%- for parameter in swagger_method.optional_parameters %}{{ parameter.name }}=None{% if not loop.last %}, {% endif %}{% endfor %}):
{% if swagger_method.summary() %}
    """{{ swagger_method.summary() }}"""
{% endif %}
    logger.info("[status=Calling] [function={{ swagger_method.udf_name }}]...")
    swagger_method = swagger_methods['{{ swagger_method.udf_name }}']
    request_content = RequestContent(swagger_method)
{% if swagger_method.has_path_parameters() or swagger_method.has_required_parameters() or swagger_method.has_optional_parameters() %}

    try:
{% for parameter in swagger_method.path_parameters %}
        swagger_method.parameters['{{ parameter.name }}'].validate_path({{ parameter.name }})
{% endfor %}
{% for parameter in swagger_method.required_parameters %}
        swagger_method.parameters['{{ parameter.name }}'].validate_required({{ parameter.name }}, request_content)
{% endfor %}
{% for parameter in swagger_method.optional_parameters %}
        swagger_method.parameters['{{ parameter.name }}'].validate_optional({{ parameter.name }}, request_content)
{% endfor %}
    except Exception as e:
        logger.exception("Unable to validate parameters.")
        return {{ convert_to_return_type('str(e)', swagger_method) }}
{% endif %}
    response = None
    try:
        response = session.get({{ swagger_method.service.config.max_retries }}).request('{{ swagger_method.requests_method }}', '{{ swagger_method.uri }}'.format(
            {%- for path_parameter in swagger_method.path_parameters %}{{ path_parameter.server_param_name }}={{ path_parameter.name }}{% if not loop.last %}, {% endif %}{% endfor -%}
        ){% if swagger_method.contains_body_parameters %}, json=request_content.payload{% endif %}{% if swagger_method.contains_query_parameters %}, params=request_content.parameters{% endif %}{% if swagger_method.contains_file_parameters %}, files=request_content.files{% endif %}{% if swagger_method.requires_authentication() %}, auth={{ authentication.get_auth(swagger_method.service.config.name, swagger_method.security()) }}{% endif %}, verify=False, headers=request_content.header, proxies={{ swagger_method.service.config.proxies }}, timeout=({{ swagger_method.service.config.connect_timeout }}, {{ swagger_method.service.config.read_timeout }}))
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function={{ swagger_method.udf_name }}] [url={0}].".format(response.request.url))
        if 202 == response.status_code:
            return [['Status URL'], [response.headers['location']]]
        if response.headers['content-type'] == 'application/json':
            all_responses = {{ swagger_method.responses }}
            return json_as_list(response, all_responses, all_definitions.get('{{ swagger_method.service.config.name }}'), {{ swagger_method.service.config.rely_on_definitions }})
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function={{ swagger_method.udf_name }}] [url={{ swagger_method.uri }}].")
        return {{ convert_to_return_type("'Cannot connect to service. Please retry once connection is re-established.'", swagger_method) }}
    except Exception as error:
        # Check "is not None" because response.ok is overridden according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function={{ swagger_method.udf_name }}] [url={1}] response: [response={0}].".format(response.text[:64], response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function={{ swagger_method.udf_name }}] [url={{ swagger_method.uri }}].")
        return {{ convert_to_return_type('describe_error(response, error)', swagger_method) }}
    finally:
        # Check "is not None" because response.ok is overridden according to HTTP status code.
        if response is not None:
            response.close()


{% endmacro %}
all_definitions = {}

{% for service in services %}
all_definitions['{{ service.config.name }}'] = {{ service.swagger_definitions }}


    {% for method_path, methods in service.swagger['paths'].items() %}
        {% for http_method, swagger_method in methods.items() %}
            {%- if service.config.should_provide_method(http_method, swagger_method) -%}
                {% for udf_return_type in service.config.udf_return_types %}
                    {{- add_udf(service.create_method(http_method, swagger_method, method_path, udf_return_type)) -}}
                {% endfor %}
            {%- endif -%}
        {% endfor %}
    {%- endfor %}
{% endfor %}

{# Macro generating the UDF related to provided method #}
{% macro handle_pyxelrest_response(method_name) %}
        response.raise_for_status()
        logger.info("[status=Valid] response received for [function={{ nethod_name }}] [url={0}].".format(response.request.url))
        if 202 == response.status_code:
            return [['Status URL'], [response.headers['location']]]
        if response.headers['content-type'] == 'application/json':
            return json_as_list(response, {}, None, False)
        elif response.headers['content-type'] == 'application/msgpackpandas':
            return msgpackpandas_as_list(response.content)
        else:
            return response.text[:255]
    except requests.exceptions.ConnectionError:
        logger.exception("Connection [status=error] occurred while calling [function={{ nethod_name }}] [url={0}].".format(url))
        return ["'Cannot connect to service. Please retry once connection is re-established.'"]
    except Exception as error:
        # Check "is not None" because response.ok is overridden according to HTTP status code.
        if response is not None:
            logger.exception("[status=Error] occurred while handling [function={{ nethod_name }}] [url={1}] response: [response={0}].".format(response.text[:64], response.request.url))
        else:
            logger.exception("[status=Error] occurred while calling [function={{ nethod_name }}] [url={0}].".format(url))
        return [describe_error(response, error)]
    finally:
        # Check "is not None" because response.ok is overridden according to HTTP status code.
        if response is not None:
            response.close()

{% endmacro %}

{% if pyxelrest_config %}

{% for udf_return_type in pyxelrest_config.udf_return_types %}
{% if pyxelrest_config.should_provide_method('get') %}
@caching
@xw.func(category='{{ pyxelrest_config.name }}', call_in_wizard=False)
@xw.arg('url', doc='URL to query.')
@xw.arg('extra_headers', doc='Extra headers to send in the query.')
{% if pyxelrest_config.is_asynchronous(udf_return_type) %}
@xw.ret(expand='table')
{% endif %}
def {{ pyxelrest_config.udf_prefix(udf_return_type) }}_get_url(url, extra_headers=None):
    """Send a HTTP GET request to specified URL."""
    logger.info("[status=Calling] [function={{ pyxelrest_config.udf_prefix(udf_return_type) }}_get_url]...")
    request_header = {{ pyxelrest_config.custom_headers }}
    if extra_headers:
        request_header.update(extra_headers)

    if not url:
        logger.error('url is required.')
        return ['url is required.']

    response = None
    try:
        response = session.get({{ pyxelrest_config.max_retries }}).request('get', url{% if pyxelrest_config.auth %}, auth={{ authentication.get_auth(pyxelrest_config.name, None) }}{% endif %}, verify=False, headers=request_header, proxies={{ pyxelrest_config.proxies }}, timeout=({{ pyxelrest_config.connect_timeout }}, {{ pyxelrest_config.read_timeout }}))
{{ handle_pyxelrest_response('pyxelrest_get_url') }}
{% endif %}

{% if pyxelrest_config.should_provide_method('post') %}
@xw.func(category='{{ pyxelrest_config.name }}', call_in_wizard=False)
@xw.arg('url', doc='URL to POST to.')
@xw.arg('body', doc='Content of the body.')
@xw.arg('extra_headers', doc='Extra headers to send in the query.')
@xw.arg('parse_body_as', doc='How the body should be sent (dict, dict_list).')
{% if pyxelrest_config.is_asynchronous(udf_return_type) %}
@xw.ret(expand='table')
{% endif %}
def {{ pyxelrest_config.udf_prefix(udf_return_type) }}_post_url(url, body, extra_headers=None, parse_body_as=None):
    """Send a HTTP POST request to specified URL."""
    logger.info("[status=Calling] [function={{ pyxelrest_config.udf_prefix(udf_return_type) }}_post_url]...")
    request_header = {{ pyxelrest_config.custom_headers }}
    if extra_headers:
        request_header.update(extra_headers)

    if not url:
        logger.error('url is required.')
        return ['url is required.']

    if not body:
        logger.error('body is required.')
        return ['body is required.']

    json_body = list_as_json(body, parse_body_as)

    response = None
    try:
        response = session.get({{ pyxelrest_config.max_retries }}).request('post', url, json=json_body{% if pyxelrest_config.auth %}, auth={{ authentication.get_auth(pyxelrest_config.name, None) }}{% endif %}, verify=False, headers=request_header, proxies={{ pyxelrest_config.proxies }}, timeout=({{ pyxelrest_config.connect_timeout }}, {{ pyxelrest_config.read_timeout }}))
{{ handle_pyxelrest_response('pyxelrest_post_url') }}
{% endif %}

{% if pyxelrest_config.should_provide_method('put') %}
@xw.func(category='{{ pyxelrest_config.name }}', call_in_wizard=False)
@xw.arg('url', doc='URL to PUT to.')
@xw.arg('body', doc='Content of the body.')
@xw.arg('extra_headers', doc='Extra headers to send in the query.')
@xw.arg('parse_body_as', doc='How the body should be sent (dict, dict_list).')
{% if pyxelrest_config.is_asynchronous(udf_return_type) %}
@xw.ret(expand='table')
{% endif %}
def {{ pyxelrest_config.udf_prefix(udf_return_type) }}_put_url(url, body, extra_headers=None, parse_body_as=None):
    """Send a HTTP PUT request to specified URL."""
    logger.info("[status=Calling] [function={{ pyxelrest_config.udf_prefix(udf_return_type) }}_put_url]...")
    request_header = {{ pyxelrest_config.custom_headers }}
    if extra_headers:
        request_header.update(extra_headers)

    if not url:
        logger.error('url is required.')
        return ['url is required.']

    if not body:
        logger.error('body is required.')
        return ['body is required.']

    json_body = list_as_json(body, parse_body_as)

    response = None
    try:
        response = session.get({{ pyxelrest_config.max_retries }}).request('put', url, json=json_body{% if pyxelrest_config.auth %}, auth={{ authentication.get_auth(pyxelrest_config.name, None) }}{% endif %}, verify=False, headers=request_header, proxies={{ pyxelrest_config.proxies }}, timeout=({{ pyxelrest_config.connect_timeout }}, {{ pyxelrest_config.read_timeout }}))
{{ handle_pyxelrest_response('pyxelrest_put_url') }}
{% endif %}

{% if pyxelrest_config.should_provide_method('delete') %}
@xw.func(category='{{ pyxelrest_config.name }}', call_in_wizard=False)
@xw.arg('url', doc='URL to query.')
@xw.arg('extra_headers', doc='Extra headers to send in the query.')
{% if pyxelrest_config.is_asynchronous(udf_return_type) %}
@xw.ret(expand='table')
{% endif %}
def {{ pyxelrest_config.udf_prefix(udf_return_type) }}_delete_url(url, extra_headers=None):
    """Send a HTTP DELETE request to specified URL."""
    logger.info("[status=Calling] [function={{ pyxelrest_config.udf_prefix(udf_return_type) }}_delete_url]...")
    request_header = {{ pyxelrest_config.custom_headers }}
    if extra_headers:
        request_header.update(extra_headers)

    if not url:
        logger.error('url is required.')
        return ['url is required.']

    response = None
    try:
        response = session.get({{ pyxelrest_config.max_retries }}).request('delete', url{% if pyxelrest_config.auth %}, auth={{ authentication.get_auth(pyxelrest_config.name, None) }}{% endif %}, verify=False, headers=request_header, proxies={{ pyxelrest_config.proxies }}, timeout=({{ pyxelrest_config.connect_timeout }}, {{ pyxelrest_config.read_timeout }}))
{{ handle_pyxelrest_response('pyxelrest_delete_url') }}
{% endif %}

{% if pyxelrest_config.should_provide_method('patch') %}
@xw.func(category='{{ pyxelrest_config.name }}', call_in_wizard=False)
@xw.arg('url', doc='URL to query.')
@xw.arg('extra_headers', doc='Extra headers to send in the query.')
{% if pyxelrest_config.is_asynchronous(udf_return_type) %}
@xw.ret(expand='table')
{% endif %}
def {{ pyxelrest_config.udf_prefix(udf_return_type) }}_patch_url(url, extra_headers=None):
    """Send a HTTP PATCH request to specified URL."""
    logger.info("[status=Calling] [function={{ pyxelrest_config.udf_prefix(udf_return_type) }}_patch_url]...")
    request_header = {{ pyxelrest_config.custom_headers }}
    if extra_headers:
        request_header.update(extra_headers)

    if not url:
        logger.error('url is required.')
        return ['url is required.']

    response = None
    try:
        response = session.get({{ pyxelrest_config.max_retries }}).request('patch', url{% if pyxelrest_config.auth %}, auth={{ authentication.get_auth(pyxelrest_config.name, None) }}{% endif %}, verify=False, headers=request_header, proxies={{ pyxelrest_config.proxies }}, timeout=({{ pyxelrest_config.connect_timeout }}, {{ pyxelrest_config.read_timeout }}))
{{ handle_pyxelrest_response('pyxelrest_patch_url') }}
{% endif %}

{% if pyxelrest_config.should_provide_method('options') %}
@xw.func(category='{{ pyxelrest_config.name }}', call_in_wizard=False)
@xw.arg('url', doc='URL to query.')
@xw.arg('extra_headers', doc='Extra headers to send in the query.')
{% if pyxelrest_config.is_asynchronous(udf_return_type) %}
@xw.ret(expand='table')
{% endif %}
def {{ pyxelrest_config.udf_prefix(udf_return_type) }}_options_url(url, extra_headers=None):
    """Send a HTTP OPTIONS request to specified URL."""
    logger.info("[status=Calling] [function={{ pyxelrest_config.udf_prefix(udf_return_type) }}_options_url]...")
    request_header = {{ pyxelrest_config.custom_headers }}
    if extra_headers:
        request_header.update(extra_headers)

    if not url:
        logger.error('url is required.')
        return ['url is required.']

    response = None
    try:
        response = session.get({{ pyxelrest_config.max_retries }}).request('options', url{% if pyxelrest_config.auth %}, auth={{ authentication.get_auth(pyxelrest_config.name, None) }}{% endif %}, verify=False, headers=request_header, proxies={{ pyxelrest_config.proxies }}, timeout=({{ pyxelrest_config.connect_timeout }}, {{ pyxelrest_config.read_timeout }}))
{{ handle_pyxelrest_response('pyxelrest_options_url') }}
{% endif %}

{% if pyxelrest_config.should_provide_method('head') %}
@xw.func(category='{{ pyxelrest_config.name }}', call_in_wizard=False)
@xw.arg('url', doc='URL to query.')
@xw.arg('extra_headers', doc='Extra headers to send in the query.')
{% if pyxelrest_config.is_asynchronous(udf_return_type) %}
@xw.ret(expand='table')
{% endif %}
def {{ pyxelrest_config.udf_prefix(udf_return_type) }}_head_url(url, extra_headers=None):
    """Send a HTTP HEAD request to specified URL."""
    logger.info("[status=Calling] [function={{ pyxelrest_config.udf_prefix(udf_return_type) }}_head_url]...")
    request_header = {{ pyxelrest_config.custom_headers }}
    if extra_headers:
        request_header.update(extra_headers)

    if not url:
        logger.error('url is required.')
        return ['url is required.']

    response = None
    try:
        response = session.get({{ pyxelrest_config.max_retries }}).request('head', url{% if pyxelrest_config.auth %}, auth={{ authentication.get_auth(pyxelrest_config.name, None) }}{% endif %}, verify=False, headers=request_header, proxies={{ pyxelrest_config.proxies }}, timeout=({{ pyxelrest_config.connect_timeout }}, {{ pyxelrest_config.read_timeout }}))
{{ handle_pyxelrest_response('pyxelrest_head_url') }}
{% endif %}
{% endfor %}

{% endif %}

def json_as_list(response, all_responses, all_definitions, rely_on_definitions):
    if rely_on_definitions:
        definition_deserializer.all_definitions = {}
{% if support_ujson %}
        response_text = response.text
        logger.debug('Converting JSON string to corresponding python structure using ujson (relying on definitions)...')
        json_data = ujson.loads(response_text) if response_text != '' else response_text
{% else %}
        logger.debug('Converting JSON string to corresponding python structure (relying on definitions)...')
        json_data = response.json(object_pairs_hook=OrderedDict) if len(response.content) else ''
{% endif %}
        return Response(all_responses, response.status_code, all_definitions).rows(json_data)

    logger.debug('Converting JSON string to corresponding python structure...')
    json_data = response.json(object_pairs_hook=OrderedDict) if len(response.content) else ''
{% if flattenize %}
    return Flattenizer(all_responses, response.status_code, all_definitions).to_list(json_data)
{% else %}
    return json_data
{% endif %}


def msgpackpandas_as_list(msgpack_pandas):
{% if support_pandas %}
    logger.debug('Converting message pack pandas to list...')
    data = pandas.read_msgpack(msgpack_pandas)
    logger.debug('Converting dictionary to list...')
    if sys.version_info[0] < 3:
        header = [header_name.decode() for header_name in data.columns.values.tolist()]
    else:
        header = data.columns.tolist()
    values = data.values.tolist()
    flatten_data = [header] + values if values else [header]
    logger.debug('Data converted to list.')
    return flatten_data
{% else %}
    logger.warning('Pandas module is required to decode response.')
    return ['Please install pandas module to be able to decode result.']
{% endif %}


def describe_error(response, error):
    # Check "is not None" because response.ok is overridden according to HTTP status code.
    if response is not None:
        return 'An error occurred. Please check logs for full details: "{0}"'.format(response.text[:198])
    return 'An error occurred. Please check logs for full details: "{0}"'.format(str(error)[:198])


def list_as_json(lists, parse_as):
    if 'dict' == parse_as:
        if len(lists) != 2:
            return ['There should be only two rows. Header and values.']
        return list_to_dict(lists[0], lists[1])

    if 'dict_list' == parse_as:
        if len(lists) < 2:
            return ['There should be at least two rows. Header and first dictionary values.']
        return list_to_dict_list(lists[0], lists[1:])

    return lists
