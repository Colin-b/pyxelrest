"""
This file was generated. DO NOT EDIT manually.
Source file: {{ self._TemplateReference__context.name }}
Generation date (UTC): {{ current_utc_time }}
"""
import flask
import webbrowser
import threading
import logging
import os
import base64
import json
import datetime
import requests
from pyxelresterrors import *

auth_tokens = {}
authentication_response = threading.Lock()
# Lock the authentication response
authentication_response.acquire()
app = flask.Flask(__name__)


def decode_base64(base64_encoded_string):
    """
    Decode base64, padding being optional.

    :param base64_encoded_string: Base64 data as an ASCII byte string
    :returns: The decoded byte string.
    """
    missing_padding = len(base64_encoded_string) % 4
    if missing_padding != 0:
        base64_encoded_string += '=' * (4 - missing_padding)
    return base64.b64decode(base64_encoded_string).decode('unicode_escape')
{% for security_definition in security_definitions %}


@app.route("/{{ security_definition.service_name }}/{{ security_definition.security_definition_key }}", methods=['POST'])
def {{ security_definition.service_name }}_{{ security_definition.security_definition_key }}_post():
    try:
        if '{{ security_definition.token_name }}' not in flask.request.form:
            raise TokenNotProvided('{{ security_definition.token_name }}')
        {{ security_definition.token_name }} = flask.request.form['{{ security_definition.token_name }}']
        if not {{ security_definition.token_name }}:
            raise InvalidToken('{{ security_definition.token_name }}')
        header, body, other = {{ security_definition.token_name }}.split('.')
        body = json.loads(decode_base64(body))
        if 'exp' not in body:
            raise TokenExpiryNotProvided(body)
        token_expiry_datetime = datetime.datetime.utcfromtimestamp(body['exp'])
        auth_tokens['{{ security_definition.service_name }}', '{{ security_definition.security_definition_key }}'] = {{ security_definition.token_name }}, token_expiry_datetime
        logging.debug("{{ security_definition.key }} authentication response received: '{0}'. Expiry is {1} (UTC).".format({{ security_definition.token_name }}, token_expiry_datetime))
        return success_page("You are now authenticated on {{ security_definition.key }}. You may close this tab.")
    except Exception as e:
        logging.exception("Unable to properly perform authentication on {{ security_definition.key }}.")
        return error_page("Unable to properly perform authentication on {{ security_definition.key }}: {0}".format(e))
    finally:
        try:
            authentication_response.release()
        except:
            logging.error('An error occurred while signaling that an authentication was received.')
            pass
{% endfor %}


@app.route('/shutdown', methods=['POST'])
def shutdown():
    logging.info('Shutdown OAuth2 authentication responses server...')
    flask_server_shutdown = flask.request.environ.get('werkzeug.server.shutdown')
    if flask_server_shutdown is None:
        raise RuntimeError('Not running with the Werkzeug Server')
    logging.info('Start shutdown...')
    flask_server_shutdown()
    logging.info('Shutdown completed')
    return success_page('Server is now closed.')


def get_bearer(security_definition):
    if security_definition.key in auth_tokens:
        bearer, expiry = auth_tokens[security_definition.key]
        if expiry < datetime.datetime.utcnow():
            logging.debug('Authentication token is expired.')
            del auth_tokens[security_definition.key]
        else:
            logging.debug('Using already received authentication, will expire in {0} (UTC).'.format(expiry))
            return bearer

    return request_new_token(security_definition)


def request_new_token(security_definition):
    logging.debug('Requesting user authentication...')
    # Default to Microsoft Internet Explorer to be able to open a new window
    # otherwise this parameter is not taken into account by most browsers
    # Opening a new window allows to focus back to Microsoft Excel once authenticated (Javascript is closing the only tab)
    ie = webbrowser.get(webbrowser.iexplore)
    if not ie.open(security_definition.full_url, 1):
        # fallback on simple request if no browser was opened
        requests.get(security_definition.full_url)

    logging.debug('Waiting for user authentication...')
{% if run_with_python_3 %}
    response_received = authentication_response.acquire(timeout=security_definition.timeout)
{% else %}
    # TODO Find a mechanism to also have a timeout on Python 2.7
    response_received = authentication_response.acquire()
{% endif %}
    if not response_received:
        logging.warning('No response received within {0} seconds. Aborting...'.format(security_definition.timeout))
    if security_definition.key in auth_tokens:
        logging.debug('User authenticated.')
        bearer, expiry = auth_tokens[security_definition.key]
        return bearer

    logging.error('User was not authenticated.')
    raise AuthenticationFailed()


def success_page(text):
    return """<body onload="window.open('', '_self', ''); window.setTimeout(close, 2000)" style="
color: #4F8A10;
background-color: #DFF2BF;
font-size: xx-large;
display: flex;
align-items: center;
justify-content: center;">
    <div style="border: 1px solid;">{0}</div>
</body>""".format(text)


def error_page(text):
    return """<body onload="window.open('', '_self', ''); window.setTimeout(close, 5000)" style="
color: #D8000C;
background-color: #FFBABA;
font-size: xx-large;
display: flex;
align-items: center;
justify-content: center;">
    <div style="border: 1px solid;">{0}</div>
</body>""".format(text)


def start_server():
    logging.debug('Starting OAuth2 authentication responses server...')
    app.run(port={{ port }})


if __name__ == "__main__":
    start_server()
